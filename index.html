<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GoodBoy - Sniffing out coded language</title>
    <!-- Favicons -->
    <link rel="icon" href="images/favicon/favicon.ico" type="image/x-icon" />
    <link rel="icon" type="image/png" href="images/favicon/favicon-96x96.png" sizes="96x96" />
    <link rel="apple-touch-icon" sizes="180x180" href="images/favicon/apple-touch-icon.png" />
    <meta name="apple-mobile-web-app-title" content="GoodBoy" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            overscroll-behavior: none;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--bg-page);
            background-image: url('images/page_background.png');
            background-repeat: repeat;
            min-height: 100vh;
            padding: var(--spacing-xl);
            color: var(--text-primary);
        }

        @font-face {
            font-family: 'Magic Red';
            src: url('fonts/Magic%20Red.ttf') format('truetype'),
                url('fonts/Magic%20Red.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
        }

        a:link {
            color: var(--link-unvisited);
        }

        a:visited {
            color: var(--link-visited);
        }

        a:hover {
            color: var(--link-hover);
        }

        a:active {
            color: var(--link-active);
        }

        p {
            margin-bottom: var(--spacing-lg);
        }

        mark {
            color: var(--text-muted);
            background-color: var(--color-demo);
            border-radius: var(--radius-sm);
        }

        u {
            color: var(--text-muted);
            text-decoration-color: var(--color-demo);
            text-decoration-thickness: var(--flagged-underline);
            text-decoration-line: underline;
            text-decoration-skip-ink: none;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto var(--spacing-sm) auto;
        }

        .overlay-logo {
            position: fixed;
            bottom: calc(var(--spacing-sm) + var(--ticker-height));
            right: var(--spacing-sm);
            width: var(--logo-size);
            height: auto;
            pointer-events: none;
            z-index: -1;
        }

        header {
            text-align: center;
            color: var(--text-white);
            margin-bottom: var(--spacing-sm);
        }

        .title-container {
            position: relative;
            display: inline-block;
            /* important for absolute positioning of beta */
            text-align: center;
        }

        h1 {
            font-family: 'Magic Red', sans-serif;
            font-size: var(--font-size-xxl);
            margin-bottom: var(--spacing-sm);
            text-shadow: 2px 2px 4px var(--shadow-light);
            display: inline-block;
            margin: 0;
        }

        .betaText {
            font-family: 'Magic Red', sans-serif;
            font-size: var(--font-size-lg);
            margin-left: var(--spacing-sm);
            margin-top: var(--spacing-sm);
            font-weight: var(--weight-normal);
            vertical-align: top;
            position: absolute;
        }

        .tagline {
            font-size: var(--font-size-lg);
            opacity: 0.95;
            margin-top: var(--spacing-tagline);
            text-shadow: 2px 2px 4px var(--shadow-light);
        }

        #ticker-container {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: var(--ticker-height);
            background-color: var(--ticker-background);
            color: var(--ticker-text);
            font-size: var(--font-size-sm);
            white-space: nowrap;
            overflow: hidden;
            height: var(--ticker-height);
            display: flex;
            align-items: center;
            z-index: 9999;
            cursor: default;
            opacity: 90%;
        }

        #ticker-wrapper {
            display: inline-flex;
        }

        #ticker-text,
        #ticker-text-duplicate {
            display: inline-block;
            white-space: nowrap;
            padding-right: 15px;
            padding-left: var(--spacing-md);
        }

        /* Keyframes for ticker */
        /* move by half, then loop */
        @keyframes scroll {
            0% {
                transform: translateX(0);
            }

            100% {
                transform: translateX(-50%);
            }
        }

        .card,
        .card-toggleable {
            background: var(--bg-card);
            border-radius: var(--radius-xl);
            padding: var(--spacing-xl);
            box-shadow: var(--box-shadow-h) var(--box-shadow-v-lg) var(--box-shadow-b-lg) var(--shadow-light);
        }

        .card-toggleable {
            margin-top: var(--spacing-sm);
            font-size: var(--font-size-sm);
            color: var(--text-muted);
        }

        .card-toggleable a {
            color: var(--link-unvisited);
            text-decoration: none;
        }

        .card-toggleable a:hover {
            text-decoration: underline;
        }

        .input-section {
            margin-bottom: var(--spacing-sm);
        }

        label,
        h3 {
            color: var(--text-primary);
            font-size: var(--font-size-lg);
            display: block;
            font-weight: var(--font-weight-semibold);
            margin-bottom: var(--spacing-sm);
        }

        #text-input {
            width: 100%;
            min-height: 200px;
            padding: var(--spacing-lg);
            border: var(--spacing-xxs) solid var(--border-default);
            border-radius: var(--radius-lg);
            font-size: var(--font-size-md);
            font-family: inherit;
            resize: vertical;
            transition: border-color var(--transition-md);
            display: block;
            transition: var(--transition-md);

        }

        #text-input:hover {
            border-color: var(--border-focus);
            transition: var(--transition-md);
        }

        #text-input:focus {
            outline: none;
            border-color: var(--border-focus);
        }

        #text-input.hidden {
            display: none;
        }

        #text-display {
            display: none;
            width: 100%;
            min-height: 200px;
            padding: var(--spacing-lg);
            border: var(--spacing-xxs) solid var(--color-primary);
            border-radius: var(--radius-lg);
            font-size: var(--font-size-md);
            font-family: inherit;
            resize: vertical;
            overflow: auto;
            background: var(--bg-input);
            line-height: 1.8;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        #text-display.visible {
            display: block;
        }

        .button-row {
            display: flex;
            gap: var(--spacing-sm);
            align-items: center;
        }

        button {
            background: var(--btn-primary-bg);
            color: var(--btn-primary-text);
            border: none;
            padding: var(--spacing-md) var(--spacing-xxl);
            border-radius: var(--radius-lg);
            font-size: var(--font-size-md);
            font-weight: var(--font-weight-semibold);
            cursor: pointer;
            transition: transform var(--transition-fs), box-shadow var(--transition-fs);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: var(--box-shadow-h) var(--box-shadow-v-sm) var(--box-shadow-b-sm) var(--shadow-medium);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled,
        .copy-btn:disabled,
        .clear-btn:disabled {
            background: var(--btn-disabled-bg) !important;
            color: var(--btn-disabled-text) !important;
            cursor: not-allowed;
            pointer-events: auto;
            opacity: 1;
            transform: none;
            box-shadow: none;
        }

        /* Special cursor for analyzing state */
        body.analyzing button:disabled,
        body.analyzing .copy-btn:disabled,
        body.analyzing .clear-btn:disabled {
            cursor: wait;
        }

        .clear-btn {
            background: var(--btn-primary-bg);
            color: var(--btn-primary-text);
        }

        .copy-btn {
            background: var(--btn-primary-bg);
            color: var(--btn-primary-text);
        }

        .hidden {
            display: none !important;
        }

        #results {
            margin-top: var(--spacing-xl);
        }

        .stats-row {
            display: flex;
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-xl);
            flex-wrap: wrap;
        }

        .stat-box {
            flex: 1;
            min-width: 150px;
            padding: var(--spacing-md);
            background: var(--bg-input);
            border-radius: var(--radius-lg);
            text-align: center;
        }

        .stat-value {
            font-size: var(--font-size-xl);
            font-weight: var(--font-weight-bold);
            color: var(--color-primary);
            margin-bottom: var(--spacing-xs);
        }

        .stat-label {
            font-size: var(--font-size-sm);
            color: var(--text-muted);
        }

        .signal-indicator {
            display: inline-block;
            margin-top: var(--spacing-xs);
            padding: var(--spacing-xs) var(--spacing-sm);
            border-radius: var(--radius-xl);
            font-size: var(--font-size-xxs);
            font-weight: var(--font-weight-semibold);
            text-transform: uppercase;
        }

        .signal-low {
            background-color: var(--state-success-bg);
            color: var(--state-success-text);
        }

        .signal-moderate {
            background-color: var(--state-warning-bg);
            color: var(--state-warning-text);
        }

        .signal-high {
            background-color: var(--state-danger-bg);
            color: var(--state-danger-text);
        }

        .signal-severe {
            background-color: var(--state-danger-border);
            color: var(--text-white);
        }

        .info-icon {
            display: inline-block;
            margin-left: var(--spacing-sm);
            cursor: help;
            opacity: 0.6;
            font-size: var(--font-size-sm);
        }

        .info-icon:hover,
        .info-icon:has(.tooltip.tooltip-pinned) {
            opacity: 1;
        }

        .signal-placeholder {
            background: var(--state-warning-bg);
            border-left: var(--spacing-xs) solid var(--state-warning-border);
            padding: var(--spacing-lg);
            border-radius: var(--radius-md);
            margin-bottom: var(--spacing-xl);
        }

        .no-results {
            padding: var(--spacing-lg);
            background: var(--state-success-bg);
            border-left: var(--spacing-xs) solid var(--state-success-border);
            border-radius: var(--radius-md);
            color: var(--state-success-text);
            font-weight: var(--font-weight-semibold);
            margin-top: var(--spacing-sm);
        }

        .flagged {
            padding: var(--spacing-xs) 0;
            border-radius: var(--radius-sm);
            cursor: help;
            position: relative;
            transition: background-color var(--transition-fs);
        }

        /* coded terms: Background color, NO underline */
        .flagged.codedTerm {
            text-decoration: none;
        }

        /* Harmful terms: ONLY underline, NO background color */
        .flagged.harmfulTerm {
            background-color: transparent !important;
            text-decoration: none;
        }

        .tooltip {
            position: fixed;
            background: var(--bg-tooltip);
            color: var(--text-white);
            padding: var(--spacing-md);
            border-radius: var(--radius-lg);
            width: 320px;
            max-width: 90vw;
            box-shadow: var(--box-shadow-h) var(--box-shadow-v-sm) var(--box-shadow-b-md) var(--shadow-light);
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity var(--transition-md);
        }

        /* Only enable hover when no tooltip is pinned */
        body:not(.tooltip-is-pinned) .flagged:hover .tooltip,
        body:not(.tooltip-is-pinned) .info-icon:hover .tooltip {
            opacity: 1;
            pointer-events: auto;
        }

        /* Mobile touch and click/touch pin visibility control */
        .tooltip.tooltip-pinned {
            opacity: 1 !important;
            pointer-events: auto !important;
        }

        /* Tooltip arrow - default (pointing down from top tooltip) */
        .tooltip::after {
            content: '';
            position: absolute;
            border: 8px solid transparent;
        }

        /* Default: tooltip above, arrow points down */
        .tooltip.top::after {
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border-top-color: var(--bg-tooltip);
        }

        /* Tooltip below, arrow points up */
        .tooltip.bottom::after {
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            border-bottom-color: var(--bg-tooltip);
        }

        /* Arrow on left when tooltip is aligned right */
        .tooltip.align-left::after {
            left: 20px;
        }

        /* Arrow on right when tooltip is aligned left */
        .tooltip.align-right::after {
            left: auto;
            right: 20px;
            transform: translateX(0);
        }

        .tooltip-category {
            display: block;
            padding: var(--spacing-sm) var(--spacing-md);
            margin: calc(-1 * var(--spacing-md)) calc(-1 * var(--spacing-md)) var(--spacing-sm) calc(-1 * var(--spacing-md));
            border-radius: var(--radius-lg) var(--radius-lg) 0 0;
            font-size: var(--font-size-xs);
            font-weight: var(--font-weight-semibold);
            text-transform: uppercase;
            text-align: center;
            color: var(--text-white);
            position: relative;
        }

        .tooltip-flag-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 0;
            margin: 0;
            font-size: var(--font-size-xl);
            line-height: 1;
            position: absolute;
            right: var(--spacing-md);
            top: 50%;
            transform: translateY(-50%);
            display: inline-block;
        }

        .tooltip-flag-btn:hover {
            transform: translateY(-50%) scale(1.1);
            filter: brightness(1.2);
        }

        /* Tooltip that appears when hovering over the flag button */
        .flag-button-tooltip {
            position: fixed;
            /* Positioned by JS, width set dynamically */
            display: none;
            transform: translateX(-100%);
            padding: var(--spacing-sm) var(--spacing-md) var(--spacing-sm) calc(var(--radius-lg) + var(--spacing-md));
            border-radius: 0 var(--radius-lg) var(--radius-lg) 0;
            box-shadow: var(--box-shadow-h) var(--box-shadow-v-sm) var(--box-shadow-b-md) var(--shadow-light);
            white-space: nowrap;
            background: var(--bg-tooltip);
            color: var(--text-white);
            font-size: var(--font-size-xs);
            font-weight: var(--font-weight-semibold);
            text-transform: none;
            z-index: 999;
            /* Below main tooltip (1000) */
            pointer-events: none;
            transition: transform var(--transition-sl) ease-out;
        }

        /* Show flag button tooltip on hover - slide out from left to right */
        .flag-button-tooltip.visible {
            display: block;
            transform: translateX(0%);
        }

        .category-badge {
            display: block;
            padding: var(--spacing-xs) var(--spacing-sm);
            border-radius: var(--radius-md);
            font-size: var(--font-size-xs);
            font-weight: var(--font-weight-semibold);
            margin: var(--spacing-xs) 0;
            color: var(--text-white);
        }

        .tooltip-item {
            margin-bottom: var(--spacing-sm);
            font-size: var(--font-size-xs);
            line-height: 1.3;
        }

        .tooltip-item:last-child {
            margin-bottom: 0;
        }

        .tooltip-item-label {
            font-weight: var(--font-weight-bold);
            color: var(--text-white);
            margin-bottom: var(--spacing-xs);
            font-size: var(--font-size-sm);
        }

        .tooltip-item-value {
            color: var(--tooltip-text);
            line-height: 1.4;
        }

        .tooltip-variations {
            color: var(--tooltip-text-muted);
            font-style: italic;
        }

        .tooltip-source {
            margin-top: var(--spacing-sm);
            padding-top: var(--spacing-sm);
            border-top: 1px solid var(--tooltip-border);
            font-size: var(--font-size-tiny);
            color: var(--tooltip-text-muted);
        }

        .tooltip-source a {
            color: var(--link-tooltip);
            text-decoration: none;
        }

        .tooltip-source a:hover {
            text-decoration: underline;
        }

        .expandable-div {
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            user-select: none;
            padding: var(--spacing-xs) 0;
        }

        .expandable-div h3 {
            margin: 0;
        }

        .expand-div-toggle {
            font-size: var(--font-size-lg);
            transition: transform var(--transition-md);
            color: var(--btn-primary-bg);
        }

        .expand-div-toggle.expanded {
            transform: rotate(180deg);
        }

        .expandable-div-content {
            display: none;
            margin-top: var(--spacing-lg);
        }

        .expandable-div-content.visible {
            display: block;
        }

        .progress-container {
            width: 100%;
            height: calc(var(--progress-height) + var(--spacing-lg));
            box-sizing: border-box;
            border: var(--spacing-xxs) solid var(--border-default);
            border-radius: var(--radius-lg);
            margin: var(--spacing-sm) 0;
            align-items: center;
            display: none;
        }

        body.analyzing .progress-container {
            display: flex;
        }

        .progress-track {
            width: 100%;
            height: var(--progress-height);
            box-sizing: border-box;
            background-color: var(--progress-track);
            margin: 0 var(--spacing-xs);
        }

        .progress-bar {
            width: 100%;
            height: 100%;
            background-color: var(--progress-bar);
            transform-origin: left center;
            transform: scaleX(var(--progress, 0));
        }

        .progress-text {
            color: var(--color-primary);
            font-weight: var(--font-weight-semibold);
            display: none;
        }

        body.analyzing .progress-text {
            display: inline;
        }

        .term-breakdown-text {
            font-size: var(--font-size-xxs);
            color: var(--color-muted);
            margin-top: var(--spacing-sm);
        }

        /* Responsive button styling for small screens */
        @media (max-width: 600px) {
            h1 {
                font-size: var(--font-size-xl);
            }

            .tagline {
                display: none;
            }

            .stats-row {
                flex-direction: column;
            }

            .tooltip {
                width: 280px;
            }

            #ticker-container {
                font-size: var(--font-size-xs);
                height: calc(var(--ticker-height) * 0.8);
            }

            .overlay-logo {
                width: calc(var(--logo-size) * 0.8);
            }

            .button-row {
                flex-wrap: wrap;
                gap: var(--spacing-xs);
            }

            button {
                padding: var(--spacing-sm) var(--spacing-md);
                font-size: var(--font-size-sm);
                flex: 1 1 auto;
                min-width: 70px;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <header>
            <div class="title-container">
                <h1>GoodBoy</h1>
                <span class="betaText">beta</span>
            </div>
            <p class="tagline">
                Sniffing out coded language
            </p>
        </header>

        <div class="card">
            <div class="input-section">
                <label for="text-input" id="inputLabel">Input</label>
                <textarea id="text-input"
                    placeholder="Enter or paste text here to check for coded and harmful language..."></textarea>
                <div id="text-display"></div>
            </div>
            <div class="progress-container">
                <div class="progress-track">
                    <div class="progress-bar"></div>
                </div>
            </div>
            <div class="button-row">
                <button id="analyzeBtn" onclick="analyzeText()">Analyze</button>
                <button class="hidden" id="editBtn" onclick="editText()">Edit</button>
                <button class="copy-btn" id="copyBtn" onclick="copyText()">Copy</button>
                <button class="clear-btn" id="clearBtn" onclick="clearAll()">Clear</button>
                <span class="progress-text" id="progress-text">Analyzing...</span>
            </div>
            <div id="results" class="hidden">
                <div class="stats-row">
                    <div class="stat-box">
                        <div class="stat-value" id="termCount">0</div>
                        <div class="stat-label">Terms Flagged</div>
                        <div id="termBreakdown" class="term-breakdown-text">
                        </div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="mainCategoryCount">0</div>
                        <div class="stat-label">Main Categories</div>
                        <div id="mainCategoryList"></div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="subCategoryCount">0</div>
                        <div class="stat-label">Subcategories</div>
                        <div id="subCategoryList"></div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="signalScore">0%</div>
                        <div class="stat-label">Signal Score</div>
                        <div id="signalIndicator"></div>
                    </div>
                </div>
            </div>
        </div>

        <div class="card-toggleable">
            <div class="expandable-div" onclick="toggleSection('instructionContent')">
                <h3>Help</h3>
                <span class="expand-div-toggle">▼</span>
            </div>
            <div class="expandable-div-content" id="instructionContent">
                <table style="width: 100%">
                    <tr>
                        <td style="width: 70%; vertical-align:top">
                            <h3>Instructions</h3>
                            <p>
                                <br>
                                <b>1.</b> Type or paste your text into the input area, then click 'Analyze'.<br>
                                <b>2.</b> Hover over highlighted / underlined terms to see their meanings.
                                <br>
                                Clicking pins a tooltip open. Click outside the tooltip / term to unpin it.
                                <br>
                                <mark>Highlighting</mark> indicates coded language and <u>underlining</u>
                                indicates harmful terms. The color signifies the category.
                                <br>
                                <b>3.</b> Click the flag icon on the term tooltip to unflag or reflag a term.
                                <br> Terms which have been unflagged will be highlighted / underlined in gray.
                                <br>
                                <b>4.</b> Check the signal score to see how much coded or harmful language appears.
                                <br>
                                <b>5.</b> Hover over or click the ⓘ icon for signal score calculation details.
                            </p>
                            <p>
                                <b>Notes:</b>
                            <p>
                                A high signal score doesn't automatically indicate harmful intent. We recommend you
                                appraise each term individually and use the unflagging tool to remove any false
                                positives.
                                Use context clues in the text to help you decipher the intent.
                            </p>
                            <p>
                                There is often considerable crossover between categories, we have done our best to
                                categorise broadly however due to the nature of coded language it is difficult to be
                                absolute.
                            </p>
                            </p>
                        </td>
                        <td
                            style="padding-left: var(--spacing-lg); padding-right: var(--spacing-lg); vertical-align:top">
                            <h3>Legend</h3>
                            <div id="legend"></div>
                        </td>
                    </tr>
                </table>
            </div>
        </div>

        <div class="card-toggleable">
            <div class="expandable-div" onclick="toggleSection('aboutContent')">
                <h3>About</h3>
                <span class="expand-div-toggle">▼</span>
            </div>
            <div class="expandable-div-content" id="aboutContent">
                <p>
                    GoodBoy is a free, open-source tool for identifying coded terms and harmful language, designed to
                    promote understanding of coded rhetoric and help users recognise hateful or discriminatory content.
                </p>
                <p>
                    All analysis happens locally in your browser — no data is sent anywhere.
                </p>
                <p>
                    We built GoodBoy to support social awareness and understanding, so it’s made to be free,
                    privacy-respecting, lightweight, and easy to use in any browser. The goal is simple: make the tool
                    as accessible and frictionless as possible so more people can learn to spot coded language.
                </p>
                <p>
                    Database: <strong><span id="dbTermCount">Loading...</span></strong>
                </p>
                <p>
                    Created by the GoodBoy Team | <a href=https://ko-fi.com/nautiluszaibatsu> Support this project ↗</a>
                    <br>
                    Contributions welcome via the <a href=https://github.com/NautilusZaibatsu/GoodBoy> GitHub
                        Repository ↗</a>
                </p>
                <p>
                    License: Source-Available. © GoodBoy 2026
                    <br>
                    Free to use. No redistribution, modification, or re-hosting permitted.
                    <br>
                </p>
            </div>
        </div>

        <div class="card-toggleable">
            <div class="expandable-div" onclick="toggleSection('attributionContent')">
                <h3>Sources</h3>
                <span class="expand-div-toggle">▼</span>
            </div>
            <div class="expandable-div-content" id="attributionContent">

                <div id="dataset-attributions"></div>

            </div>
        </div>
    </div>
    <img src="images/logo.png" class="overlay-logo" alt="Logo">
    <div id="ticker-container">
        <div id="ticker-wrapper">
            <div id="ticker-text"></div>
            <div id="ticker-text-duplicate"></div>
        </div>
    </div>


    <!-- Load scripts / data -->
    <script src="app_meta.js"></script>
    <script src="data/coded_term_data.js"></script>
    <script src="data/harmful_term_data.js"></script>
    <script src="data/source_data.js"></script>
    <script src="js/text_utils.js"></script>
    <script src="js/number_utils.js"></script>
    <script src="js/matchers.js"></script>
    <script src="js/theme_config.js"></script>
    <script src="js/ticker.js"></script>
    <script src="js/category_config.js"></script>
    <script src="js/progress_tracker.js"></script>
    <script src="js/signal_score.js"></script>
    <script src="js/tooltips.js"></script>
    <script src="data/religionym_lookup.js"></script>
    <script src="data/place_demonym_lookup.js"></script>

    <!-- Main application logic -->
    <script>
        // Developer toggle: Set to false to disable all progress tracking for performance testing
        const ENABLE_PROGRESS_TRACKING = true;

        // Initialize the ticker
        initTicker();

        // Initialize and render the attributions
        renderAttributions();

        // Initialize the pattern matchers
        let matcher = null;
        let harmfulTermMatcher = null;

        // Store original text for re-analysis
        let originalAnalyzedText = '';

        // Analysis abort flag
        let analysisAborted = false;

        // Initialize the legend for the how to section
        const legendDiv = document.getElementById('legend');
        let legendHtml = '';

        Object.entries(CATEGORY_HIERARCHY).forEach(([slug, cat]) => {
            legendHtml += `<span class="category-badge" style="background-color: ${cat.darkColor}">${cat.label}</span>`;
        });
        legendDiv.innerHTML = legendHtml;

        // Initialize matchers when data is loaded
        const codedTermData = typeof CODED_TERM_DATA !== 'undefined' ? CODED_TERM_DATA : null;
        const harmfulTermData = typeof HARMFUL_TERM_DATA !== 'undefined' ? HARMFUL_TERM_DATA : null;

        if (codedTermData) {
            matcher = new CodedTermMatcher(codedTermData);
        } else {
            console.error('Error: Failed to load coded term database.');
        }

        if (harmfulTermData) {
            harmfulTermMatcher = new HarmfulTermMatcher(harmfulTermData);
        } else {
            console.error('Error: Failed to load harmful term database.');
        }

        // Fade the logo out if it goes under cards
        const logo = document.querySelector('.overlay-logo');
        const targets = document.querySelectorAll('.card, .card-toggleable');
        window.addEventListener('scroll', checkLogoOverlap);
        window.addEventListener('resize', checkLogoOverlap);
        // Watch for added/removed cards
        const observer = new MutationObserver(checkLogoOverlap);
        observer.observe(document.body, { childList: true, subtree: true });
        checkLogoOverlap();

        // Load and prepare data on page load
        window.addEventListener('DOMContentLoaded', () => {
            // Initialize theme (inject CSS custom properties)
            initializeTheme();

            // Inject category-specific CSS styles
            injectCategoryStyles();

            // Set initial disabled state for buttons
            document.getElementById('analyzeBtn').disabled = true;
            document.getElementById('copyBtn').disabled = true;
            document.getElementById('clearBtn').disabled = true;

            // ===== DATABASE LOADING =====
            // Check all required databases
            const codedTermData = typeof CODED_TERM_DATA !== 'undefined' ? CODED_TERM_DATA : null;
            const harmfulTermData = typeof HARMFUL_TERM_DATA !== 'undefined' ? HARMFUL_TERM_DATA : null;
            const placeLookupLoaded = typeof PLACE_DEMONYM_LOOKUP !== 'undefined';

            // Log loading status
            if (codedTermData) {
                console.log(`✓ Loaded ${codedTermData.totalTerms} coded terms`);
            } else {
                console.error('✗ Failed to load coded term database');
            }

            if (harmfulTermData) {
                console.log(`✓ Loaded ${harmfulTermData.totalTerms} harmful terms`);
            } else {
                console.error('✗ Failed to load harmful term database');
            }

            // Check for critical failures
            if (!codedTermData || !harmfulTermData) {
                const missing = [];
                if (!codedTermData) missing.push('coded terms');
                if (!harmfulTermData) missing.push('harmful terms');
                alert(`Error: Failed to load ${missing.join(' and ')} database. Please refresh the page.`);
                return;
            }

            // ===== MATCHER INITIALIZATION =====
            // Initialize pattern matcher for populist language detection
            if (placeLookupLoaded) {
                PatternMatcher.initialize(codedTermData);
                console.log(`✓ Loaded ${PatternMatcher.patterns.length} dynamic populist patterns`);
            } else {
                console.warn('⚠ Place-demonym lookup not loaded, populist pattern matching disabled');
            }

            // Initialize term matchers
            matcher = new CodedTermMatcher(codedTermData);
            harmfulTermMatcher = new HarmfulTermMatcher(harmfulTermData);

            // Calculate progress weights based on actual database sizes
            const codedVariationCount = matcher.variationMap.size;
            const harmfulVariationCount = harmfulTermMatcher.variationMap.size;
            const patternCount = PatternMatcher.patterns.length;

            ProgressTracker.calculateWeights(
                codedVariationCount,
                harmfulVariationCount,
                patternCount
            );

            // ===== UI UPDATES =====
            // Update database term count display
            const dbTermCountEl = document.getElementById('dbTermCount');
            if (dbTermCountEl) {
                const codedTermCount = codedTermData.totalTerms;
                const harmfulTermCount = harmfulTermData.totalTerms;
                const harmfulTermText = harmfulTermCount === 1 ? 'harmful term' : 'harmful terms';
                dbTermCountEl.textContent = `${codedTermCount} coded terms and ${harmfulTermCount} ${harmfulTermText}`;
            }
        });

        /**
         * POPULIST PATTERN MATCHING SYSTEM
         *
         * Detects nationalist, regionalist and localist language patterns by recognizing place/group names
         * and checking if similar patterns exist in the coded term database with different places.
         *
         * Example: If database contains "America First", it will also flag "Britain First",
         * "Make Liverpool Great Again" (from "MAGA"), "hard-working Indians" (from "hard-working Americans")
         *
         * Hybrid Categorization:
         * - Dynamic patterns with nationalist/regionalist/localist category → auto-categorize by place type:
         *   - Countries → Nationalist
         *   - Regions  → Regionalist
         *   - Regions/cities → Localist
         * - Dynamic patterns with other categories (racist, antisemitic, etc.) → preserve original category
         */



        function renderAttributions() {
            const container = document.getElementById('dataset-attributions');
            container.innerHTML = ''; // Clear previous content if any

            SOURCE_DATA.sources.forEach(source => {
                // Dataset title
                const text = document.createTextNode(source.description || source.string || source.id);
                container.appendChild(text);
                // Prepare links
                const links = [];
                if (source.url) {
                    const a = document.createElement('a');
                    a.href = source.url;
                    a.target = '_blank';
                    a.rel = 'noopener';
                    a.textContent = ' ↗';
                    links.push(a);
                }
                if (source.paper) {
                    const a = document.createElement('a');
                    a.href = source.paper;
                    a.target = '_blank';
                    a.rel = 'noopener';
                    a.textContent = 'Read Paper ↗';
                    links.push(a);
                }

                if (links.length > 0) {
                    container.appendChild(document.createTextNode(' ')); // space after title
                    links.forEach((link, idx) => {
                        container.appendChild(link);
                        if (idx < links.length - 1) {
                            container.appendChild(document.createTextNode(' | '));
                        }
                    });
                }

                // Line break after each source
                container.appendChild(document.createElement('br'));
            });
        }

        function checkLogoOverlap() {
            const logoRect = logo.getBoundingClientRect();
            let maxOverlapRatio = 0;

            targets.forEach(target => {
                const rect = target.getBoundingClientRect();
                // horizontal and vertical overlap
                const xOverlap = Math.max(0, Math.min(logoRect.right, rect.right) - Math.max(logoRect.left, rect.left));
                const yOverlap = Math.max(0, Math.min(logoRect.bottom, rect.bottom) - Math.max(logoRect.top, rect.top));
                const overlapArea = xOverlap * yOverlap;
                const logoArea = logoRect.width * logoRect.height;
                const overlapRatio = overlapArea / logoArea;
                maxOverlapRatio = Math.max(maxOverlapRatio, overlapRatio);
            });

            const minOpacity = 0;
            const fadeAt = 0.25; // fade reaches minOpacity at 12.5% overlap

            // scale overlapRatio so 0–50% maps to 1–minOpacity
            let opacity;
            if (maxOverlapRatio >= fadeAt) {
                opacity = minOpacity;
            } else {
                opacity = 1 - (maxOverlapRatio / fadeAt) * (1 - minOpacity);
            }

            logo.style.opacity = opacity;
        }

        function editText() {
            // User clicked "Edit Text" button - restore editable state
            clearAnalysis();
        }

        // Helper function to toggle a section of the page
        function toggleSection(div_section) {
            const content = document.getElementById(div_section);
            const toggle = document.querySelector('.expand-div-toggle');
            content.classList.toggle('visible');
            toggle.classList.toggle('expanded');
            checkLogoOverlap();
        }

        function clearAnalysis() {
            const textInput = document.getElementById('text-input');
            const textDisplay = document.getElementById('text-display');
            const analyzeBtn = document.getElementById('analyzeBtn');
            const editBtn = document.getElementById('editBtn');
            const resultsDiv = document.getElementById('results');
            const inputLabel = document.getElementById('inputLabel');

            // Check if analysis is currently displayed
            if (textDisplay.classList.contains('visible') && originalAnalyzedText) {
                // Put original text back into the editable textarea
                textInput.value = originalAnalyzedText;

                // Switch from display div back to editable textarea
                textDisplay.classList.remove('visible');
                textDisplay.innerHTML = '';
                textInput.classList.remove('hidden');

                // Update label
                inputLabel.textContent = 'Text to analyze:';

                // Show Analyze button, hide Edit button (keep Clear button visible)
                analyzeBtn.classList.remove('hidden');
                analyzeBtn.disabled = false;
                editBtn.classList.add('hidden');

                // Hide results stats
                resultsDiv.classList.add('hidden');
            }
        }

        let analyzedYet = false;

        // Helper function to update progress bar and text
        function updateProgress(percent) {
            const clamped = Math.max(0, Math.min(100, percent));
            // convert percent to 0 to 1 value for bar
            document.documentElement.style.setProperty(
                '--progress',
                clamped / 100
            );
            const progressElement = document.getElementById('progress-text');
            if (progressElement) {
                progressElement.textContent = `Analyzing: ${Math.round(clamped)}%`;
            }
        }

        async function analyzeText() {

            const textInput = document.getElementById('text-input');

            // Always get text from textarea (it's editable)
            const text = textInput.value.trim();

            if (!text) {
                alert('Please enter some text to analyze.');
                return;
            }

            if (!matcher && !harmfulTermMatcher) {
                alert('Databases not loaded. Please refresh the page.');
                return;
            }

            // Store original text for potential editing
            originalAnalyzedText = text;

            // Reset abort flag
            analysisAborted = false;

            // Start progress tracking (only if enabled)
            if (ENABLE_PROGRESS_TRACKING) {
                ProgressTracker.start();
            }

            // Show progress state
            const progressElement = document.getElementById('progress-text');
            progressElement.classList.add('visible');
            document.getElementById('analyzeBtn').disabled = true;
            document.body.classList.add('analyzing');

            // Update progress text to show 0%
            updateProgress(0);

            // Create progress callback that respects toggle
            // When disabled, pass null to skip all progress overhead
            const progressCallback = ENABLE_PROGRESS_TRACKING ? (percent) => {
                // Check if analysis was aborted
                if (analysisAborted) {
                    throw new Error('Analysis aborted by user');
                }
                ProgressTracker.updateProgress(percent);
                updateProgress(percent);
            } : null;

            // Small delay to allow UI to paint progress state
            await new Promise(resolve => setTimeout(resolve, 50));

            try {
                // Get dynamic weight configs from ProgressTracker
                const codedConfig = ProgressTracker.getWeightConfig('coded');
                const harmfulConfig = ProgressTracker.getWeightConfig('harmful');
                const patternConfig = ProgressTracker.getWeightConfig('pattern');
                const deduplicationRange = ProgressTracker.weights.deduplication;
                const renderingRange = ProgressTracker.weights.rendering;

                // Analyze with coded term matcher (dynamic %)
                const codedTermResults = matcher ? await matcher.analyze(text, progressCallback, {
                    ...codedConfig,
                    updateInterval: PROGRESS_UPDATE_INTERVAL
                }) : { matches: [], categoryCount: 0, categories: [] };

                // Analyze with harmful term matcher (dynamic %)
                const harmfulTermResults = harmfulTermMatcher ? await harmfulTermMatcher.analyze(text, progressCallback, {
                    ...harmfulConfig,
                    updateInterval: PROGRESS_UPDATE_INTERVAL
                }) : { matches: [], categoryCount: 0, categories: [] };

                // Analyze for dynamic patterns (dynamic %)
                const patternResults = PatternMatcher.place_demonym_lookup_loaded ? await PatternMatcher.analyze(text, progressCallback, {
                    ...patternConfig,
                    updateInterval: PROGRESS_UPDATE_INTERVAL
                }) : { matches: [] };

                // Step: Combine results (deduplication range start)
                if (progressCallback) {
                    progressCallback(deduplicationRange.start);
                    await new Promise(resolve => setTimeout(resolve, 0));
                }

                // Combine results (pattern matches are also coded terms)
                const allMatches = [
                    ...codedTermResults.matches,
                    ...harmfulTermResults.matches,
                    ...patternResults.matches
                ];

                // Count all unique categories
                const allCategories = new Set([
                    ...codedTermResults.categories,
                    ...harmfulTermResults.categories,
                    ...patternResults.matches.map(m => m.category)
                ]);

                const combinedResults = await deduplicateMatches(
                    allMatches,
                    allCategories,
                    progressCallback,
                    deduplicationRange,
                );

                // Step: Display results (rendering range start)
                if (progressCallback) {
                    progressCallback(renderingRange.start);
                    await new Promise(resolve => setTimeout(resolve, 0));
                }

                displayResults(text, combinedResults);

                // Complete progress tracking (only if enabled)
                if (ENABLE_PROGRESS_TRACKING) {
                    ProgressTracker.complete();
                }
                if (progressCallback) {
                    progressCallback(100);
                }

                // Track analytics (TODO: implement)
                trackAnalysis(text, combinedResults);

            } catch (error) {
                // Check if this was an abort or a real error
                if (error.message === 'Analysis aborted by user') {
                    console.log('Analysis aborted by user');
                    // Don't show error alert for user-initiated abort
                } else {
                    console.error('Analysis error:', error);
                    alert('An error occurred during analysis. Please try again.');
                }
            } finally {
                // Hide progress state
                document.body.classList.remove('analyzing');
                document.getElementById('analyzeBtn').disabled = false;
            }
            checkLogoOverlap();
        }

        async function deduplicateMatches(allMatches, allCategories, progressCallback, dedupeRange) {

            // Report start immediately to prevent UI pause
            if (progressCallback) {
                progressCallback(dedupeRange.start);
                await new Promise(resolve => setTimeout(resolve, 0));
            }

            // Phase weighting
            const phase1Weight = 0.5;
            const phase2Weight = 0.3;
            const phase3Weight = 0.2;
            const phase1End = dedupeRange.start + (dedupeRange.allocation * phase1Weight);
            const phase2End = phase1End + dedupeRange.allocation * phase2Weight;
            const phase3End = phase2End + dedupeRange.allocation * phase3Weight;

            //
            // Phase 1 — Group by (start, end) with sub-upddates
            //
            const positionGroups = new Map();

            for (const match of allMatches) {
                const key = `${match.start}-${match.end}`;
                if (!positionGroups.has(key)) positionGroups.set(key, []);
                positionGroups.get(key).push(match);
            }

            // Update progress once at the end of Phase 1
            if (progressCallback) {
                progressCallback(phase1End);
                await new Promise(resolve => setTimeout(resolve, 0));
            }
            //
            // Phase 2 — Smart tiebreaker
            //
            const deduplicatedByPosition = [];
            const groupEntries = Array.from(positionGroups.entries());

            for (const [key, groupMatches] of groupEntries) {
                if (groupMatches.length === 1) {
                    deduplicatedByPosition.push(groupMatches[0]);
                } else {
                    const originalText = groupMatches[0].text;
                    const bestMatch = TextUtils.selectBestMatch(originalText, groupMatches);
                    deduplicatedByPosition.push(bestMatch);
                }
            }
            // Update progress once at the end of Phase 2
            if (progressCallback) {
                progressCallback(phase2End);
                await new Promise(resolve => setTimeout(resolve, 0));
            }

            //
            // Phase 3 — Overlap filtering
            //
            deduplicatedByPosition.sort((a, b) => {
                if (b.end - b.start !== a.end - a.start) return (b.end - b.start) - (a.end - a.start);
                return a.start - b.start;
            });

            const combinedMatches = [];
            const usedRanges = [];
            for (const match of deduplicatedByPosition) {
                let hasOverlap = false;

                for (const range of usedRanges) {
                    if (match.start < range.end && match.end > range.start) {
                        let isInGap = false;
                        if (range.displayRanges && range.displayRanges.length > 0) {
                            for (let i = 0; i < range.displayRanges.length - 1; i++) {
                                const gapStart = range.displayRanges[i].end;
                                const gapEnd = range.displayRanges[i + 1].start;
                                if (match.start >= gapStart && match.end <= gapEnd) {
                                    isInGap = true;
                                    break;
                                }
                            }
                        }

                        if (!isInGap) {
                            hasOverlap = true;
                            break;
                        }
                    }
                }

                if (!hasOverlap) {
                    combinedMatches.push(match);
                    usedRanges.push({
                        start: match.start,
                        end: match.end,
                        displayRanges: match.displayRanges
                    });
                }
            }

            // Update progress once at the end of Phase 3
            if (progressCallback) {
                progressCallback(phase3End);
                await new Promise(resolve => setTimeout(resolve, 0));
            }

            //
            // Final sorting + counting
            //
            combinedMatches.sort((a, b) => a.start - b.start);

            const matchesForCounting = [];
            const seenParentTerms = new Set();
            for (const match of combinedMatches) {
                if (match.isSegment && match.parentTerm) {
                    if (!seenParentTerms.has(match.parentTerm)) {
                        seenParentTerms.add(match.parentTerm);
                        matchesForCounting.push(match);
                    }
                } else {
                    matchesForCounting.push(match);
                }
            }

            const codedTermCount = matchesForCounting.filter(m => m.type === 'codedTerm').length;
            const harmfulTermCount = matchesForCounting.filter(m => m.type === 'harmfulTerm').length;

            return {
                matches: combinedMatches,
                deduplicatedMatches: matchesForCounting,
                codedTermCount,
                harmfulTermCount,
                categoryCount: allCategories.size,
                categories: Array.from(allCategories)
            };
        }

        function displayResults(originalText, results) {
            const textInput = document.getElementById('text-input');
            const textDisplay = document.getElementById('text-display');
            const analyzeBtn = document.getElementById('analyzeBtn');
            const clearBtn = document.getElementById('clearBtn');
            const resultsDiv = document.getElementById('results');
            const inputLabel = document.getElementById('inputLabel');

            // Update stats using shared DRY functions
            const matchesToCount = results.deduplicatedMatches || results.matches;
            SignalScore.updateAllStats(matchesToCount, originalText);

            // Build flagged text display
            let displayHtml = '';
            if (results.matches.length === 0) {
                displayHtml = '<div class="no-results">✓ No coded terms or harmful terms detected in this text.</div>' +
                    '<div style="margin-top: var(--spacing-lg);">' + escapeHtml(originalText) + '</div>';
            } else {
                let lastIndex = 0;

                results.matches.forEach(match => {
                    // Add text before match
                    displayHtml += escapeHtml(originalText.substring(lastIndex, match.start));

                    // Add flagged match with tooltip
                    displayHtml += createFlaggedTermSpan(match, originalText);

                    lastIndex = match.end;
                });

                // Add remaining text
                displayHtml += escapeHtml(originalText.substring(lastIndex));
            }

            textDisplay.innerHTML = displayHtml;

            // Switch UI: hide textarea, show display div
            textInput.classList.add('hidden');
            textDisplay.classList.add('visible');
            analyzeBtn.classList.add('hidden');
            document.getElementById('editBtn').classList.remove('hidden');
            clearBtn.classList.remove('hidden');
            document.getElementById('copyBtn').classList.remove('hidden');
            inputLabel.textContent = 'Analysis Results:';

            // Show stats
            resultsDiv.classList.remove('hidden');

            // Setup smart tooltip positioning
            setupTooltips();
        }

        /**
         * Generate matched term HTML if obfuscation is detected
         *
         * @param {string} matchedTerm - The canonical term that was matched
         * @param {string} displayedText - The actual text shown in the document
         * @param {string} label - Label to use ("Term" or "Derivation")
         * @returns {string} HTML string or empty string if no obfuscation
         */
        function getMatchedTermHtml(matchedTerm, displayedText, label = 'Term') {
            if (!matchedTerm) return '';

            // Check if obfuscation detected (case-insensitive comparison)
            const isObfuscated = matchedTerm.toLowerCase() !== displayedText.toLowerCase();

            if (!isObfuscated) return '';

            return `<div class="tooltip-item"><div class="tooltip-item-label">${label}:</div><div class="tooltip-item-value">${escapeHtml(matchedTerm)}</div></div>`;
        }

        /**
         * Format variations list, limiting to 6 random items if list is too long
         *
         * @param {Array<string>} variations - Array of variation strings
         * @returns {string} HTML string or empty string if no variations
         */
        function getVariationsHtml(variations) {
            if (!variations || variations.length === 0) return '';

            let displayVariations = variations;
            let label = 'Variations';

            // If more than 6 variations, select 6 random ones
            if (variations.length > 6) {
                // Shuffle and take first 6
                const shuffled = [...variations].sort(() => Math.random() - 0.5);
                displayVariations = shuffled.slice(0, 6);
                label = `Variations include`;
            }

            return `<div class="tooltip-item"><div class="tooltip-item-label">${label}:</div><div class="tooltip-item-value tooltip-variations">${escapeHtml(displayVariations.join(' / '))}</div></div>`;
        }

        function createFlaggedTermSpan(match, originalText) {
            const typeClass = match.type || "codedTerm";

            const categoryClass = getCategoryClass(match.category);
            const categoryColor = getCategoryColor(match.category);
            const categoryLabel = getCategoryLabel(match.category);
            const subcategoryLabel = getSubcategoryLabel(match.category);
            const capitalizedDefinition = match.definition;

            const sourceHtml = getTooltipSourceHtml(match.source);
            const displayText = originalText.substring(match.start, match.end);

            const flagBtnHtml = `<button class="tooltip-flag-btn" data-flagged="true">${FLAG_SYMBOLS.FLAGGED}</button>`;

            const categoryItemHtml =
                `<div class="tooltip-item"><div class="tooltip-item-label">Category:</div>` +
                `${escapeHtml(categoryLabel)}</div></div>`;

            const dataAttrs =
                `data-category="${escapeHtml(match.category)}" data-unflagged="false"` +
                (match.parentTerm ? ` data-parent-term="${escapeHtml(match.parentTerm)}"` : "");

            const headerHtml =
                `<div class="tooltip-category" style="background-color: ${categoryColor}">` +
                `${escapeHtml(subcategoryLabel)}${flagBtnHtml}</div>`;

            function typeHtml(isHarmful) {
                return isHarmful
                    ? `<div class="tooltip-item"><div class="tooltip-item-label">Type:</div>☣️ Harmful Term</div></div>`
                    : `<div class="tooltip-item"><div class="tooltip-item-label">Type:</div>🔣 Coded Term</div>`;
            }

            function simpleItem(label, value) {
                return `<div class="tooltip-item"><div class="tooltip-item-label">${label}:</div>` +
                    `<div class="tooltip-item-value">${escapeHtml(value)}</div></div>`;
            }

            function wrapTooltip(inner) {
                return `<span class="tooltip">${inner}</span>`;
            }

            function wrapFlagged(innerTooltip, isHarmful) {
                // Keep exactly the same outer span shape and class names as your original returns
                const termClass = isHarmful ? "harmfulTerm" : "codedTerm";
                return `<span class="flagged ${categoryClass} ${termClass}" ${dataAttrs}>` +
                    `${escapeHtml(displayText)}${wrapTooltip(innerTooltip)}</span>`;
            }

            // Build the tooltip body
            if (typeClass === "harmfulTerm") {
                const matchedTermHtml = getMatchedTermHtml(match.matchedTerm, match.text, "Term");

                const inner =
                    headerHtml +
                    typeHtml(true) +
                    matchedTermHtml +
                    simpleItem("Definition", capitalizedDefinition) +
                    categoryItemHtml +
                    sourceHtml;

                return wrapFlagged(inner, true);
            }

            // Coded term path
            let termHtmlBlock;
            // Display derviation if sub-category is localist/nationalist/regionalist
            if (match.isDerived && match.category !== "religious-populism") {
                termHtmlBlock = simpleItem("Derivation", match.term);
            } else {
                termHtmlBlock = getMatchedTermHtml(match.matchedTerm, match.text, "Term");
            }

            const variationsHtml = getVariationsHtml(match.variations);

            const inner =
                headerHtml +
                typeHtml(false) +
                termHtmlBlock +
                variationsHtml +
                simpleItem("Coded term", capitalizedDefinition) +
                categoryItemHtml +
                sourceHtml;

            return wrapFlagged(inner, false);
        }


        /**
        * Returns a tooltip-source string for a given source ID.
        */
        function getTooltipSourceHtml(sourceId, pinned) {
            const sourceEntry = SOURCE_DATA.sources.find(s => s.id === sourceId);
            const displayString = escapeHtml(sourceEntry.string || sourceId);
            return `<div class="tooltip-source">Source: <a href= "${sourceEntry.url}" target = "_blank" >${displayString} ↗</a></div>`;
        }


        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Flag button constants
        const FLAG_SYMBOLS = {
            FLAGGED: '⚑',
            UNFLAGGED: '⚐'
        };

        const FLAG_TOOLTIP_TEXT = {
            UNFLAG: 'Unflag this term',
            REFLAG: 'Reflag this term'
        };

        // Track currently pinned tooltip (click/touch)
        let pinnedTooltip = null;

        // Detect if device supports touch (mobile/tablet) - used by multiple functions
        const isTouchDevice = window.matchMedia('(hover: none)').matches
            || ('ontouchstart' in window);

        // Tooltip functions moved to js/tooltips.js

        /**
         * Recalculate all stats after unflag/reflag action
         */
        function recalculateAllStats() {
            // Rebuild matches array from current DOM state (excluding unflagged)
            const currentMatches = getCurrentFlaggedMatches();

            // Update all stats using shared function
            updateAllStats(currentMatches, originalAnalyzedText);
        }

        /**
         * Get current flagged matches from DOM (excluding unflagged)
         * @returns {Array} Array of match objects for signal score calculation
         */
        function getCurrentFlaggedMatches() {
            const allFlaggedSpans = document.querySelectorAll('.flagged');
            const matches = [];
            const seenParentTerms = new Set();

            Array.from(allFlaggedSpans).forEach(span => {
                // Skip unflagged terms
                if (span.dataset.unflagged === 'true') return;

                // Get text content WITHOUT the tooltip
                let textContent = '';
                span.childNodes.forEach(node => {
                    if (node.nodeType === Node.TEXT_NODE) {
                        textContent += node.textContent;
                    }
                });

                const match = {
                    type: span.classList.contains('harmfulTerm') ? 'harmfulTerm' : 'codedTerm',
                    category: span.dataset.category,
                    text: textContent.trim()
                };

                // Handle segment deduplication (emoji-split terms)
                const parentTerm = span.dataset.parentTerm;
                if (parentTerm) {
                    // Only count once per parent term
                    if (!seenParentTerms.has(parentTerm)) {
                        seenParentTerms.add(parentTerm);
                        matches.push(match);
                    }
                } else {
                    // Not a segment, count normally
                    matches.push(match);
                }
            });

            return matches;
        }

        function positionFlagTooltip(flagBtn, tooltip, flagTooltip) {
            const tooltipRect = tooltip.getBoundingClientRect();

            // Position: left edge at tooltip's right edge, top edge at tooltip's top edge
            flagTooltip.style.position = 'fixed';
            flagTooltip.style.left = `${tooltipRect.right - parseFloat(THEME_CONFIG.spacing.radius.lg)}px`;
            flagTooltip.style.top = `${tooltipRect.top}px`;
        }

        function positionTooltip(flaggedTerm, tooltip) {
            // Get flaggedTerm position
            const flaggedTermRect = flaggedTerm.getBoundingClientRect();
            const tooltipWidth = 320; // Match CSS width
            const tooltipHeight = tooltip.offsetHeight || 150; // Estimate if not rendered
            const margin = 10;
            const arrowHeight = 8;

            // Viewport dimensions
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            // Calculate initial centered position
            let left = flaggedTermRect.left + (flaggedTermRect.width / 2) - (tooltipWidth / 2);
            let top = flaggedTermRect.top - tooltipHeight - arrowHeight - margin;

            // Reset classes
            tooltip.classList.remove('top', 'bottom', 'align-left', 'align-right');

            // Check if tooltip fits above
            if (top < margin) {
                // Place below instead
                top = flaggedTermRect.bottom + arrowHeight + margin;
                tooltip.classList.add('bottom');
            } else {
                tooltip.classList.add('top');
            }

            // Check horizontal overflow
            if (left < margin) {
                // Align to left edge
                left = margin;
                tooltip.classList.add('align-left');
            } else if (left + tooltipWidth > viewportWidth - margin) {
                // Align to right edge
                left = viewportWidth - tooltipWidth - margin;
                tooltip.classList.add('align-right');
            }

            // Apply position
            tooltip.style.left = `${left}px`;
            tooltip.style.top = `${top}px`;
        }

        function clearAll() {
            const textInput = document.getElementById('text-input');
            const textDisplay = document.getElementById('text-display');
            const analyzeBtn = document.getElementById('analyzeBtn');
            const editBtn = document.getElementById('editBtn');
            const clearBtn = document.getElementById('clearBtn');
            const copyBtn = document.getElementById('copyBtn');
            const resultsDiv = document.getElementById('results');
            const inputLabel = document.getElementById('inputLabel');

            // Abort any ongoing analysis
            analysisAborted = true;

            // Clear text
            textInput.value = '';
            textDisplay.innerHTML = '';
            originalAnalyzedText = ''; // Reset stored text

            // Switch UI back: show textarea, hide display div
            textInput.classList.remove('hidden');
            textDisplay.classList.remove('visible');
            analyzeBtn.classList.remove('hidden');
            analyzeBtn.disabled = true;
            clearBtn.disabled = true;
            copyBtn.disabled = true;
            editBtn.classList.add('hidden');
            inputLabel.textContent = 'Paste text to analyze:';

            // Hide stats
            resultsDiv.classList.add('hidden');
        }

        function copyText() {
            // Always copy from the textarea (which contains current editable text)
            const textToCopy = document.getElementById('text-input').value;
            if (!textToCopy.trim()) {
                return; // Nothing to copy
            }
            // Use the Clipboard API
            navigator.clipboard.writeText(textToCopy).then(() => {
                // visual feedback
                const copyBtn = document.getElementById('copyBtn');
                // Temporarily override background with disabled color
                copyBtn.style.background = 'var(--btn-clicked-bg)';
                setTimeout(() => {
                    copyBtn.style.background = '';
                }, buttonClickTimeout);

            }).catch(err => {
                console.error('Failed to copy text:', err);
                alert('Failed to copy text to clipboard');
            });
        }

        function trackAnalysis(text, results) {
            // TODO: Implement analytics tracking
            // Track metrics:
            // 1. Total analyses performed
            // 2. Detection rate
            // 3. Average text length
            // 4. Terms detected distribution
            // 5. Return user rate (localStorage)
            // 6. Country-level data (IP geolocation)
            // 7. Time-based patterns

            // console.log('Analytics placeholder:', {
            //     textLength: text.length,
            //     matchCount: results.matches.length,
            //     categories: results.categories
            // });
        }

        // Prevent the user from flagging text outside the text area
        const selectable = document.getElementById('text-input');
        document.addEventListener('selectstart', (e) => {
            if (!selectable.contains(e.target)) {
                e.preventDefault(); // Prevent selection
            }
        });

        // Allow Enter key to submit (with Ctrl/Cmd)
        document.getElementById('text-input').addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                analyzeText();
            }
        });

        // Enable/disable buttons based on text content
        document.getElementById('text-input').addEventListener('input', (e) => {
            const analyzeBtn = document.getElementById('analyzeBtn');
            const copyBtn = document.getElementById('copyBtn');
            const clearBtn = document.getElementById('clearBtn');
            const textInput = document.getElementById('text-input');

            if (textInput.value.trim()) {
                analyzeBtn.disabled = false;
                copyBtn.disabled = false;
                clearBtn.disabled = false;
            } else {
                analyzeBtn.disabled = true;
                copyBtn.disabled = true;
                clearBtn.disabled = true;
            }
        });

        // Reposition tooltips on window resize or scroll
        let tooltipRepositionTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(tooltipRepositionTimeout);
            tooltipRepositionTimeout = setTimeout(() => {
                // Reposition any visible tooltips
                // Desktop: use hover selector, Mobile/pinned: use .tooltip-pinned selector
                const selector = isTouchDevice ? '.tooltip.tooltip-pinned' : '.flagged:hover .tooltip';
                const visibleTooltips = document.querySelectorAll(selector);

                visibleTooltips.forEach(tooltip => {
                    const flaggedTerm = tooltip.closest('.flagged');
                    if (flaggedTerm) {
                        positionTooltip(flaggedTerm, tooltip);
                    }
                });
            }, 100);
        });

        window.addEventListener('scroll', () => {
            // Reposition tooltips on scroll (since they use fixed positioning)
            // Desktop: use hover selector, Mobile/pinned: use .tooltip-pinned selector
            const selector = isTouchDevice ? '.tooltip.tooltip-pinned' : '.flagged:hover .tooltip';
            const visibleTooltips = document.querySelectorAll(selector);

            visibleTooltips.forEach(tooltip => {
                const flaggedTerm = tooltip.closest('.flagged');
                if (flaggedTerm) {
                    positionTooltip(flaggedTerm, tooltip);
                }
            });
        }, { passive: true });
    </script>
</body>

</html>