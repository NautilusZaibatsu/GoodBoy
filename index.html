<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üêï GoodBoy - Sniffing out coded language</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            overscroll-behavior: none;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--bg-page);
            background-image: url('images/page_background.png');
            background-repeat: repeat;
            min-height: 100vh;
            padding: var(--spacing-xl);
            color: var(--text-primary);
        }

        a:link {
            color: var(--link-unvisited);
        }

        a:visited {
            color: var(--link-visited);
        }

        a:hover {
            color: var(--link-hover);
        }

        a:active {
            color: var(--link-active);
        }

        p {
            margin-bottom: 1rem;
        }

        mark {
            color: var(--text-muted);
            background-color: var(--color-demo);
            border-radius: var(--radius-sm);
        }

        u {
            color: var(--text-muted);
            text-decoration-color: var(--color-demo);
            text-decoration-thickness: 3px;
            text-decoration-line: underline;
            text-decoration-skip-ink: none;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            color: var(--text-white);
            margin-bottom: var(--spacing-sm);
        }

        @font-face {
            font-family: 'Magic Red';
            src: url('fonts/Magic%20Red.ttf') format('truetype'),
                url('fonts/Magic%20Red.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
        }

        .title-container {
            position: relative;
            display: inline-block;
            /* important for absolute positioning of beta */
            text-align: center;
        }

        h1 {
            font-family: 'Magic Red', sans-serif;
            font-size: var(--font-size-xxl);
            margin-bottom: var(--spacing-sm);
            text-shadow: 2px 2px 4px var(--shadow-light);
            display: inline-block;
            margin: 0;
        }

        .betaText {
            font-family: 'Magic Red', sans-serif;
            font-size: var(--font-size-lg);
            margin-left: var(--spacing-sm);
            margin-top: var(--spacing-sm);
            font-weight: var(--weight-normal);
            vertical-align: top;
            position: absolute;
        }

        .tagline {
            font-size: var(--font-size-lg);
            opacity: 0.95;
            margin-top: var(--spacing-tagline);
            text-shadow: 2px 2px 4px var(--shadow-light);
        }

        #ticker-container {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: var(--bg-ticker);
            color: var(--text-ticker);
            font-size: var(--font-size-sm);
            white-space: nowrap;
            overflow: hidden;
            height: 30px;
            display: flex;
            align-items: center;
            z-index: 9999;
            cursor: default;
        }

        #ticker-wrapper {
            display: inline-flex;
        }

        #ticker-text,
        #ticker-text-duplicate {
            display: inline-block;
            white-space: nowrap;
            padding-right: 15px;
            padding-left: var(--spacing-md);
        }

        /* Keyframes for ticker */
        /* move by half, then loop */
        @keyframes scroll {
            0% {
                transform: translateX(0);
            }

            100% {
                transform: translateX(-50%);
            }
        }

        .card {
            background: var(--bg-card);
            border-radius: var(--radius-xl);
            padding: var(--spacing-xxl);
            box-shadow: 0 10px 40px var(--shadow-light);
        }

        .input-section {
            margin-bottom: var(--spacing-xl);
        }

        label {
            display: block;
            font-weight: var(--font-weight-semibold);
            margin-bottom: var(--spacing-sm);
            color: var(--text-secondary);
        }

        #textInput {
            width: 100%;
            min-height: 200px;
            padding: var(--spacing-lg);
            border: 2px solid var(--border-default);
            border-radius: var(--radius-lg);
            font-size: var(--font-size-md);
            font-family: inherit;
            resize: vertical;
            transition: border-color 0.3s;
            display: block;
        }

        #textInput:focus {
            outline: none;
            border-color: var(--border-focus);
        }

        #textInput.hidden {
            display: none;
        }

        #textDisplay {
            display: none;
            width: 100%;
            min-height: 200px;
            padding: var(--spacing-lg);
            border: 2px solid var(--color-primary);
            border-radius: var(--radius-lg);
            font-size: var(--font-size-md);
            font-family: inherit;
            background: var(--bg-input);
            line-height: 1.8;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        #textDisplay.visible {
            display: block;
        }

        .button-row {
            display: flex;
            gap: var(--spacing-sm);
            align-items: center;
        }

        button {
            background: var(--btn-primary-bg);
            color: var(--btn-primary-text);
            border: none;
            padding: var(--spacing-md) var(--spacing-xxl);
            border-radius: var(--radius-lg);
            font-size: var(--font-size-md);
            font-weight: var(--font-weight-semibold);
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px var(--shadow-medium);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled,
        .copy-btn:disabled,
        .clear-btn:disabled {
            background: var(--btn-disabled-bg) !important;
            color: var(--btn-disabled-text) !important;
            cursor: not-allowed;
            pointer-events: auto;
            opacity: 1;
            transform: none;
            box-shadow: none;
        }

        /* Special cursor for analyzing state */
        body.analyzing button:disabled,
        body.analyzing .copy-btn:disabled,
        body.analyzing .clear-btn:disabled {
            cursor: wait;
        }

        .clear-btn {
            background: var(--btn-primary-bg);
            color: var(--btn-primary-text);
        }

        .copy-btn {
            background: var(--btn-primary-bg);
            color: var(--btn-primary-text);
        }

        .hidden {
            display: none !important;
        }

        #results {
            margin-top: var(--spacing-xl);
        }

        .stats-row {
            display: flex;
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-xl);
            flex-wrap: wrap;
        }

        .stat-box {
            flex: 1;
            min-width: 150px;
            padding: var(--spacing-md);
            background: var(--bg-input);
            border-radius: var(--radius-lg);
            text-align: center;
        }

        .stat-value {
            font-size: var(--font-size-xl);
            font-weight: var(--font-weight-bold);
            color: var(--color-primary);
            margin-bottom: var(--spacing-xs);
        }

        .stat-label {
            font-size: var(--font-size-sm);
            color: var(--text-muted);
        }

        .signal-indicator {
            display: inline-block;
            margin-top: var(--spacing-xs);
            padding: var(--spacing-xs) var(--spacing-sm);
            border-radius: var(--radius-xl);
            font-size: var(--font-size-xxs);
            font-weight: var(--font-weight-semibold);
            text-transform: uppercase;
        }

        .signal-low {
            background-color: var(--state-success-bg);
            color: var(--state-success-text);
        }

        .signal-moderate {
            background-color: var(--state-warning-bg);
            color: var(--state-warning-text);
        }

        .signal-high {
            background-color: var(--state-danger-bg);
            color: var(--state-danger-text);
        }

        .signal-severe {
            background-color: var(--state-danger-border);
            color: var(--text-white);
        }

        .info-icon {
            display: inline-block;
            margin-left: var(--spacing-sm);
            cursor: help;
            opacity: 0.6;
            font-size: var(--font-size-sm);
        }

        .info-icon:hover,
        .info-icon:has(.tooltip.tooltip-pinned) {
            opacity: 1;
        }

        .signal-placeholder {
            background: var(--state-warning-bg);
            border-left: 4px solid var(--state-warning-border);
            padding: var(--spacing-lg);
            border-radius: var(--radius-md);
            margin-bottom: var(--spacing-xl);
        }

        .no-results {
            padding: var(--spacing-lg);
            background: var(--state-success-bg);
            border-left: 4px solid var(--state-success-border);
            border-radius: var(--radius-md);
            color: var(--state-success-text);
            font-weight: var(--font-weight-semibold);
            margin-top: var(--spacing-sm);
        }

        .flagged {
            padding: var(--spacing-xs) 0;
            border-radius: var(--radius-sm);
            cursor: help;
            position: relative;
            transition: background-color 0.2s;
        }

        /* coded terms: Background color, NO underline */
        .flagged.codedTerm {
            text-decoration: none;
        }

        /* Harmful terms: ONLY underline, NO background color */
        .flagged.harmfulTerm {
            background-color: transparent !important;
            text-decoration: none;
        }

        .tooltip {
            position: fixed;
            background: var(--bg-tooltip);
            color: var(--text-white);
            padding: var(--spacing-md);
            border-radius: var(--radius-lg);
            width: 320px;
            max-width: 90vw;
            box-shadow: 0 5px 20px var(--shadow-light);
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        /* Only enable hover when no tooltip is pinned */
        body:not(.tooltip-is-pinned) .flagged:hover .tooltip,
        body:not(.tooltip-is-pinned) .info-icon:hover .tooltip {
            opacity: 1;
            pointer-events: auto;
        }

        /* Mobile touch and click/touch pin visibility control */
        .tooltip.tooltip-pinned {
            opacity: 1 !important;
            pointer-events: auto !important;
        }

        /* Tooltip arrow - default (pointing down from top tooltip) */
        .tooltip::after {
            content: '';
            position: absolute;
            border: 8px solid transparent;
        }

        /* Default: tooltip above, arrow points down */
        .tooltip.top::after {
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border-top-color: var(--bg-tooltip);
        }

        /* Tooltip below, arrow points up */
        .tooltip.bottom::after {
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            border-bottom-color: var(--bg-tooltip);
        }

        /* Arrow on left when tooltip is aligned right */
        .tooltip.align-left::after {
            left: 20px;
        }

        /* Arrow on right when tooltip is aligned left */
        .tooltip.align-right::after {
            left: auto;
            right: 20px;
            transform: translateX(0);
        }

        .tooltip-category {
            display: block;
            padding: var(--spacing-sm) var(--spacing-md);
            margin: calc(-1 * var(--spacing-md)) calc(-1 * var(--spacing-md)) var(--spacing-sm) calc(-1 * var(--spacing-md));
            border-radius: var(--radius-lg) var(--radius-lg) 0 0;
            font-size: var(--font-size-xs);
            font-weight: var(--font-weight-semibold);
            text-transform: uppercase;
            text-align: center;
            color: var(--text-white);
            position: relative;
        }

        .tooltip-flag-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 0;
            margin: 0;
            font-size: var(--font-size-xl);
            line-height: 1;
            position: absolute;
            right: var(--spacing-md);
            top: 50%;
            transform: translateY(-50%);
            display: inline-block;
        }

        .tooltip-flag-btn:hover {
            transform: translateY(-50%) scale(1.1);
            filter: brightness(1.2);
        }

        /* Tooltip that appears when hovering over the flag button */
        .flag-button-tooltip {
            position: fixed;
            /* Positioned by JS, width set dynamically */
            display: none;
            transform: translateX(-100%);
            padding: var(--spacing-sm) var(--spacing-md) var(--spacing-sm) calc(var(--radius-lg) + var(--spacing-md));
            border-radius: 0 var(--radius-lg) var(--radius-lg) 0;
            box-shadow: 0 5px 20px var(--shadow-light);
            white-space: nowrap;
            background: var(--bg-tooltip);
            color: var(--text-white);
            font-size: var(--font-size-xs);
            font-weight: var(--font-weight-semibold);
            text-transform: none;
            z-index: 999;
            /* Below main tooltip (1000) */
            pointer-events: none;
            transition: transform 0.5s ease-out;
        }

        /* Show flag button tooltip on hover - slide out from left to right */
        .flag-button-tooltip.visible {
            display: block;
            transform: translateX(0%);
        }

        .category-badge {
            display: block;
            padding: var(--spacing-xs) var(--spacing-sm);
            border-radius: var(--radius-md);
            font-size: var(--font-size-xs);
            font-weight: var(--font-weight-semibold);
            margin: var(--spacing-xs) 0;
            color: var(--text-white);
        }

        .tooltip-item {
            margin-bottom: var(--spacing-sm);
            font-size: var(--font-size-xs);
            line-height: 1.3;
        }

        .tooltip-item:last-child {
            margin-bottom: 0;
        }

        .tooltip-item-label {
            font-weight: var(--font-weight-bold);
            color: var(--text-white);
            margin-bottom: var(--spacing-xs);
            font-size: var(--font-size-sm);
        }

        .tooltip-item-value {
            color: var(--tooltip-text);
            line-height: 1.4;
        }

        .tooltip-variations {
            color: var(--tooltip-text-muted);
            font-style: italic;
        }

        .tooltip-source {
            margin-top: var(--spacing-sm);
            padding-top: var(--spacing-sm);
            border-top: 1px solid var(--tooltip-border);
            font-size: var(--font-size-tiny);
            color: var(--tooltip-text-muted);
        }

        .tooltip-source a {
            color: var(--link-tooltip);
            text-decoration: none;
        }

        .tooltip-source a:hover {
            text-decoration: underline;
        }

        footer {
            margin-top: var(--spacing-sm);
            padding: var(--spacing-xl);
            background: var(--bg-footer-overlay);
            border-radius: var(--radius-xl);
            font-size: var(--font-size-sm);
            color: var(--text-muted);
        }

        .expandable-div {
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            user-select: none;
            padding: var(--spacing-xs) 0;
        }

        .expandable-div h3 {
            color: var(--text-primary);
            margin: 0;
            font-size: 1.1em;
        }

        .expand-div-toggle {
            font-size: 1.2em;
            transition: transform 0.3s;
            color: var(--btn-primary-bg);
        }

        .expand-div-toggle.expanded {
            transform: rotate(180deg);
        }

        .expandable-div-content {
            display: none;
            margin-top: var(--spacing-lg);
        }

        .expandable-div-content.visible {
            display: block;
        }

        footer a {
            color: var(--link-unvisited);
            text-decoration: none;
        }

        footer a:hover {
            text-decoration: underline;
        }

        .loading {
            display: none;
            color: var(--color-primary);
            font-weight: var(--font-weight-semibold);
        }

        .loading.visible {
            display: inline;
        }

        @media (max-width: 600px) {
            h1 {
                font-size: var(--font-size-xl);
            }

            .stats-row {
                flex-direction: column;
            }

            .tooltip {
                width: 280px;
            }

            /* Responsive button styling for mobile */
            .button-row {
                flex-wrap: wrap;
                gap: var(--spacing-xs);
                /* Reduce gap from 8px to 4px */
            }

            button {
                padding: var(--spacing-sm) var(--spacing-md);
                /* 8px 12px instead of 12px 30px */
                font-size: var(--font-size-sm);
                /* 0.9em instead of 1em */
                flex: 1 1 auto;
                /* Allow flexible sizing */
                min-width: 70px;
                /* Prevent buttons from becoming too small */
            }

            .loading {
                width: 100%;
                /* Force loading text to new line */
                text-align: center;
                margin-top: var(--spacing-xs);
            }
        }
    </style>
</head>

<body>
    <div id="ticker-container">
        <div id="ticker-wrapper">
            <div id="ticker-text"></div>
            <div id="ticker-text-duplicate"></div>
        </div>
    </div>
    <div class="container">
        <header>
            <div class="title-container">
                <h1>GoodBoy</h1>
                <span class="betaText">beta</span>
            </div>
            <p class="tagline">
                Sniffing out coded language
            </p>
        </header>

        <div class="card">
            <div class="input-section">
                <label for="textInput" id="inputLabel">Text to analyze:</label>
                <textarea id="textInput"
                    placeholder="Enter or paste text here to check for coded and harmful language..."></textarea>
                <div id="textDisplay"></div>
            </div>

            <div class="button-row">
                <button id="analyzeBtn" onclick="analyzeText()">Analyze</button>
                <button class="hidden" id="editBtn" onclick="editText()">Edit</button>
                <button class="copy-btn" id="copyBtn" onclick="copyText()">Copy</button>
                <button class="clear-btn" id="clearBtn" onclick="clearAll()">Clear</button>
                <span class="loading" id="loading">Analyzing...</span>
            </div>

            <div id="results" class="hidden">
                <div class="stats-row">
                    <div class="stat-box">
                        <div class="stat-value" id="termCount">0</div>
                        <div class="stat-label">Terms Flagged</div>
                        <div id="termBreakdown" style="margin-top: 8px; font-size: 0.75em; color: var(--color-muted);">
                        </div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="mainCategoryCount">0</div>
                        <div class="stat-label">Main Categories</div>
                        <div id="mainCategoryList" style="margin-top: 10px; font-size: 0.85em; text-align: left;"></div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="subCategoryCount">0</div>
                        <div class="stat-label">Subcategories</div>
                        <div id="subCategoryList" style="margin-top: 10px; font-size: 0.85em; text-align: left;"></div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="signalScore">0%</div>
                        <div class="stat-label">Signal Score</div>
                        <div id="signalIndicator"></div>
                    </div>
                </div>
            </div>
        </div>

        <footer>
            <div class="expandable-div" onclick="toggleSection('instructionContent')">
                <h3>Help</h3>
                <span class="expand-div-toggle">‚ñº</span>
            </div>
            <div class="expandable-div-content" id="instructionContent">
                <table style="width: 100%">
                    <tr>
                        <td style="width: 70%; vertical-align:top">
                            <h3>Instructions</h3>
                            <p>
                                <br>
                                <b>1.</b> Type or paste your text into the input area, then click 'Analyze'.<br>
                                <b>2.</b> Hover over highlighted / underlined terms to see their meanings.
                                <br>
                                Clicking pins a tooltip open. Click outside the tooltip / term to unpin it.
                                <br>
                                <mark>Highlighting</mark> indicates coded language and <u>underlining</u>
                                indicates harmful terms. The color signifies the category.
                                <br>
                                <b>3.</b> Click the flag icon on the term tooltip to unflag or reflag a term.
                                <br> Terms which have been unflagged will be highlighted / underlined in gray.
                                <br>
                                <b>4.</b> Check the signal score to see how much coded or harmful language appears.
                                <br>
                                <b>5.</b> Hover over or click the ‚ìò icon for signal score calculation details.
                            </p>
                            <p>
                                <b>Notes:</b>
                            <p>
                                A high signal score doesn't automatically indicate harmful intent. We recommend you 
                                appraise each term individually and use the unflagging tool to remove any false positives. 
                                Use context clues in the text to help you decipher the intent.
                            </p>
                            <p>
                                There is often considerable crossover between categories, we have done our best to
                                categorise broadly however due to the nature of coded language it is difficult to be
                                absolute.
                            </p>
                            </p>
                        </td>
                        <td
                            style="padding-left: var(--spacing-lg); padding-right: var(--spacing-lg); vertical-align:top">
                            <h3>Legend</h3>
                            <div id="legend"></div>
                        </td>
                    </tr>
                </table>
            </div>
        </footer>

        <footer>
            <div class="expandable-div" onclick="toggleSection('aboutContent')">
                <h3>About</h3>
                <span class="expand-div-toggle">‚ñº</span>
            </div>
            <div class="expandable-div-content" id="aboutContent">
                <p>
                    GoodBoy is a free, open-source tool for identifying coded terms and harmful language, designed to
                    promote understanding of coded rhetoric and help users recognise hateful or discriminatory content.
                </p>
                <p>
                    All analysis happens locally in your browser ‚Äî no data is sent anywhere.
                </p>
                <p>
                    We built GoodBoy to support social awareness and understanding, so it‚Äôs made to be free,
                    privacy-respecting, lightweight, and easy to use in any browser. The goal is simple: make the tool
                    as accessible and frictionless as possible so more people can learn to spot coded language.
                </p>
                <p>
                    Database: <strong><span id="dbTermCount">Loading...</span></strong>
                </p>
                <p>
                    Created by the GoodBoy Team | <a href=https://ko-fi.com/nautiluszaibatsu> Support this project ‚Üó</a>
                    <br>
                    Contributions welcome via the <a href=https://github.com/NautilusZaibatsu/GoodBoy> GitHub
                        Repository ‚Üó</a>
                </p>
                <p>
                    License: Source-Available. ¬© GoodBoy 2026
                    <br>
                    Free to use. No redistribution, modification, or re-hosting permitted.
                    <br>
                </p>
            </div>
        </footer>

        <footer>
            <div class="expandable-div" onclick="toggleSection('attributionContent')">
                <h3>Sources</h3>
                <span class="expand-div-toggle">‚ñº</span>
            </div>
            <div class="expandable-div-content" id="attributionContent">

                <div id="dataset-attributions"></div>

            </div>
        </footer>
    </div>

    <!-- Load scripts / data -->
    <script src="data/coded_term_data.js"></script>
    <script src="data/harmful_term_data.js"></script>
    <script src="data/source_data.js"></script>
    <script src="js/text_utils.js"></script>
    <script src="js/number_utils.js"></script>
    <script src="js/matchers.js"></script>
    <script src="js/theme_config.js"></script>
    <script src="js/ticker.js"></script>
    <script src="js/category_config.js"></script>
    <script src="js/signal_score.js"></script>
    <script src="js/tooltips.js"></script>
    <script src="data/religionym_lookup.js"></script>
    <script src="data/place_demonym_lookup.js"></script>

    <!-- Main application logic -->
    <script>
        // Initialize the ticker
        initTicker();

        // Initialize and render the attributions
        renderAttributions();
        // Initialize the pattern matchers
        let matcher = null;
        let harmfulTermMatcher = null;

        // Store original text for re-analysis
        let originalAnalyzedText = '';

        // Initialize the legend for the how to section
        const legendDiv = document.getElementById('legend');
        let legendHtml = '';

        Object.entries(CATEGORY_HIERARCHY).forEach(([slug, cat]) => {
            legendHtml += `<span class="category-badge" style="background-color: ${cat.darkColor}">${cat.label}</span>`;
        });
        legendDiv.innerHTML = legendHtml;

        // Initialize matchers when data is loaded
        const codedTermData = typeof CODED_TERM_DATA !== 'undefined' ? CODED_TERM_DATA : null;
        const harmfulTermData = typeof HARMFUL_TERM_DATA !== 'undefined' ? HARMFUL_TERM_DATA : null;

        if (codedTermData) {
            matcher = new CodedTermMatcher(codedTermData);
        } else {
            console.error('Error: Failed to load coded term database.');
        }

        if (harmfulTermData) {
            harmfulTermMatcher = new HarmfulTermMatcher(harmfulTermData);
        } else {
            console.error('Error: Failed to load harmful term database.');
        }

        // Initialize pattern matcher for populist detection
        if (codedTermData && typeof PLACE_DEMONYM_LOOKUP !== 'undefined') {
            PatternMatcher.initialize(codedTermData.terms);
            console.log('‚úì Pattern matcher initialized for populist detection');
        } else if (typeof PLACE_DEMONYM_LOOKUP === 'undefined') {
            console.warn('Place-demonym lookup not loaded, populist pattern matching disabled');
        }

        if (!codedTermData && !harmfulTermData) {
            alert('Error: Failed to load databases. Please refresh the page.');
        }

        // Theme configuration loaded from js/theme_config.js

        /**
         * POPULIST PATTERN MATCHING SYSTEM
         *
         * Detects nationalist, regionalist and localist language patterns by recognizing place/group names
         * and checking if similar patterns exist in the coded term database with different places.
         *
         * Example: If database contains "America First", it will also flag "Britain First",
         * "Make Liverpool Great Again" (from "MAGA"), "hard-working Indians" (from "hard-working Americans")
         *
         * Hybrid Categorization:
         * - Dynamic patterns with nationalist/regionalist/localist category ‚Üí auto-categorize by place type:
         *   - Countries ‚Üí Nationalist
         *   - Regions  ‚Üí Regionalist
         *   - Regions/cities ‚Üí Localist
         * - Dynamic patterns with other categories (racist, antisemitic, etc.) ‚Üí preserve original category
         */

        // Use getMainCategoryForSub(), getCategoryColor(), etc. from that module

        function renderAttributions() {
            const container = document.getElementById('dataset-attributions');
            container.innerHTML = ''; // Clear previous content if any

            SOURCE_DATA.sources.forEach(source => {
                // Dataset title
                const text = document.createTextNode(source.description || source.string || source.id);
                container.appendChild(text);
                // Prepare links
                const links = [];
                if (source.url) {
                    const a = document.createElement('a');
                    a.href = source.url;
                    a.target = '_blank';
                    a.rel = 'noopener';
                    a.textContent = ' ‚Üó';
                    links.push(a);
                }
                if (source.paper) {
                    const a = document.createElement('a');
                    a.href = source.paper;
                    a.target = '_blank';
                    a.rel = 'noopener';
                    a.textContent = 'Read Paper ‚Üó';
                    links.push(a);
                }

                if (links.length > 0) {
                    container.appendChild(document.createTextNode(' ')); // space after title
                    links.forEach((link, idx) => {
                        container.appendChild(link);
                        if (idx < links.length - 1) {
                            container.appendChild(document.createTextNode(' | '));
                        }
                    });
                }

                // Line break after each source
                container.appendChild(document.createElement('br'));
            });
        }


        // Load and prepare data on page load
        window.addEventListener('DOMContentLoaded', () => {
            // Initialize theme (inject CSS custom properties)
            initializeTheme();

            // Inject category-specific CSS styles
            injectCategoryStyles();

            // Set initial disabled state for buttons
            document.getElementById('analyzeBtn').disabled = true;
            document.getElementById('copyBtn').disabled = true;
            document.getElementById('clearBtn').disabled = true;

            let codedTermData = null;
            let harmfulTermData = null;

            // Check coded term database
            if (typeof CODED_TERM_DATA !== 'undefined') {
                codedTermData = CODED_TERM_DATA;
                console.log(`‚úì Loaded ${CODED_TERM_DATA.total} coded terms`);
            } else {
                console.error('Failed to load coded term database');
            }

            // Check harmful term database
            if (typeof HARMFUL_TERM_DATA !== 'undefined') {
                // Filter redundant variations using our pattern matching logic
                harmfulTermData = HARMFUL_TERM_DATA;
                console.log(`‚úì Loaded ${HARMFUL_TERM_DATA.uniqueTerms} harmful terms`);
            } else {
                console.error('Failed to load harmful term database');
            }

            // Update database term count in footer
            const dbTermCountEl = document.getElementById('dbTermCount');
            if (dbTermCountEl) {
                const codedTermCount = codedTermData ? codedTermData.totalTerms : 0;
                const harmfulTermCount = harmfulTermData ? harmfulTermData.totalTerms : 0;

                if (codedTermCount > 0 && harmfulTermCount > 0) {
                    const harmfulTermText = harmfulTermCount === 1 ? 'harmful term' : 'harmful terms';
                    dbTermCountEl.textContent = `${codedTermCount} coded terms and ${harmfulTermCount} ${harmfulTermText}`;
                } else if (codedTermCount > 0) {
                    dbTermCountEl.textContent = `${codedTermCount} coded terms`;
                } else if (harmfulTermCount > 0) {
                    const harmfulTermText = harmfulTermCount === 1 ? 'harmful term' : 'harmful terms';
                    dbTermCountEl.textContent = `${harmfulTermCount} ${harmfulTermText}`;
                } else {
                    dbTermCountEl.textContent = 'Error loading';
                }
            }

            // Initialize matchers with the databases
            if (codedTermData) {
                matcher = new CodedTermMatcher(codedTermData);
            } else {
                console.error('Error: Failed to load coded term database.');
            }

            if (harmfulTermData) {
                harmfulTermMatcher = new HarmfulTermMatcher(harmfulTermData);
            } else {
                console.error('Error: Failed to load harmful term database.');
            }

            // Initialize pattern matcher for populist detection
            if (codedTermData && typeof PLACE_DEMONYM_LOOKUP !== 'undefined') {
                PatternMatcher.initialize(codedTermData.terms);
                console.log('‚úì Pattern matcher initialized for populist detection');
            } else if (typeof PLACE_DEMONYM_LOOKUP === 'undefined') {
                console.warn('Place-demonym lookup not loaded, populist pattern matching disabled');
            }

            if (!codedTermData && !harmfulTermData) {
                alert('Error: Failed to load databases. Please refresh the page.');
            }
        });

        function editText() {
            // User clicked "Edit Text" button - restore editable state
            clearAnalysis();
        }

        // Helper function to toggle a section of the page
        function toggleSection(div_section) {
            const content = document.getElementById(div_section);
            const toggle = document.querySelector('.expand-div-toggle');
            content.classList.toggle('visible');
            toggle.classList.toggle('expanded');
        }

        function clearAnalysis() {
            const textInput = document.getElementById('textInput');
            const textDisplay = document.getElementById('textDisplay');
            const analyzeBtn = document.getElementById('analyzeBtn');
            const editBtn = document.getElementById('editBtn');
            const resultsDiv = document.getElementById('results');
            const inputLabel = document.getElementById('inputLabel');

            // Check if analysis is currently displayed
            if (textDisplay.classList.contains('visible') && originalAnalyzedText) {
                // Put original text back into the editable textarea
                textInput.value = originalAnalyzedText;

                // Switch from display div back to editable textarea
                textDisplay.classList.remove('visible');
                textDisplay.innerHTML = '';
                textInput.classList.remove('hidden');

                // Update label
                inputLabel.textContent = 'Text to analyze:';

                // Show Analyze button, hide Edit button (keep Clear button visible)
                analyzeBtn.classList.remove('hidden');
                analyzeBtn.disabled = false;
                editBtn.classList.add('hidden');

                // Hide results stats
                resultsDiv.classList.add('hidden');
            }
        }

        let analyzedYet = false;

        function analyzeText() {

            const textInput = document.getElementById('textInput');

            // Always get text from textarea (it's editable)
            const text = textInput.value.trim();

            if (!text) {
                alert('Please enter some text to analyze.');
                return;
            }

            if (!matcher && !harmfulTermMatcher) {
                alert('Databases not loaded. Please refresh the page.');
                return;
            }

            // Store original text for potential editing
            originalAnalyzedText = text;

            // Show loading state
            document.getElementById('loading').classList.add('visible');
            document.getElementById('analyzeBtn').disabled = true;
            document.body.classList.add('analyzing'); // Add analyzing state for cursor

            // Use setTimeout to allow UI to update
            setTimeout(() => {
                // Analyze with both matchers
                const codedTermResults = matcher ? matcher.analyze(text) : { matches: [], categoryCount: 0, categories: [] };
                const harmfulTermResults = harmfulTermMatcher ? harmfulTermMatcher.analyze(text) : { matches: [], categoryCount: 0, categories: [] };

                // Analyze for populist patterns
                const patternResults = PatternMatcher.place_demonym_lookup_loaded ? PatternMatcher.analyze(text) : { matches: [] };

                // Combine results (pattern matches are also coded terms)
                const allMatches = [
                    ...codedTermResults.matches,
                    ...harmfulTermResults.matches,
                    ...patternResults.matches
                ];

                // Group matches by (start, end) position to apply smart tiebreaker
                // When matches from different sources match the same text, select the best one
                // Examples: "Tim" vs "TIM", "Canaca" vs "Kanaca", "Turco" vs "Turko"
                const positionGroups = new Map();
                for (const match of allMatches) {
                    const key = `${match.start}-${match.end}`;
                    if (!positionGroups.has(key)) {
                        positionGroups.set(key, []);
                    }
                    positionGroups.get(key).push(match);
                }

                // For each position group, select the best match using smart tiebreaker
                const deduplicatedByPosition = [];
                for (const [key, groupMatches] of positionGroups) {
                    if (groupMatches.length === 1) {
                        deduplicatedByPosition.push(groupMatches[0]);
                    } else {
                        // Multiple matches at same position - use smart tiebreaker
                        const originalText = groupMatches[0].text;
                        const bestMatch = TextUtils.selectBestMatch(originalText, groupMatches);
                        deduplicatedByPosition.push(bestMatch);
                    }
                }

                deduplicatedByPosition.sort((a, b) => {
                    if (b.end - b.start !== a.end - a.start) {
                        return (b.end - b.start) - (a.end - a.start); // Sort by length (longest first)
                    }
                    return a.start - b.start; // If same length, sort by position
                });

                const combinedMatches = [];
                const usedRanges = [];

                // Check if we have deliberated split a match into segments, such as from emoji-split terms so we can deduplicate
                // e.g., "False" and "Flag" from "FalseüêëFlag"
                for (const match of deduplicatedByPosition) {
                    let hasOverlap = false;

                    for (const range of usedRanges) {
                        if (match.start < range.end && match.end > range.start) {
                            // Check if this match is in a gap of a displayRanges match
                            let isInGap = false;
                            if (range.displayRanges && range.displayRanges.length > 0) {
                                for (let i = 0; i < range.displayRanges.length - 1; i++) {
                                    const gapStart = range.displayRanges[i].end;
                                    const gapEnd = range.displayRanges[i + 1].start;
                                    if (match.start >= gapStart && match.end <= gapEnd) {
                                        isInGap = true;
                                        break;
                                    }
                                }
                            }

                            if (!isInGap) {
                                hasOverlap = true;
                                break;
                            }
                        }
                    }

                    if (!hasOverlap) {
                        combinedMatches.push(match);
                        usedRanges.push({
                            start: match.start,
                            end: match.end,
                            displayRanges: match.displayRanges
                        });
                    }
                }

                // Sort by position for display
                combinedMatches.sort((a, b) => a.start - b.start);

                // Deduplicate segments for counting purposes
                const matchesForCounting = [];
                const seenParentTerms = new Set();

                for (const match of combinedMatches) {
                    if (match.isSegment && match.parentTerm) {
                        // This is a segment of a multi-word term split by emojis
                        // Only count once per parentTerm
                        if (!seenParentTerms.has(match.parentTerm)) {
                            seenParentTerms.add(match.parentTerm);
                            matchesForCounting.push(match);
                        }
                    } else {
                        // Not a segment, count normally (includes emojis, regular matches)
                        matchesForCounting.push(match);
                    }
                }

                // Count all unique categories
                const allCategories = new Set([
                    ...codedTermResults.categories,
                    ...harmfulTermResults.categories,
                    ...patternResults.matches.map(m => m.category)
                ]);

                // Separate deduplicated counts by type
                const deduplicatedCodedTerms = matchesForCounting.filter(m => m.type === 'codedTerm');
                const deduplicatedHarmfulTerms = matchesForCounting.filter(m => m.type === 'harmfulTerm');

                const combinedResults = {
                    matches: combinedMatches,  // All matches for display (includes duplicate segments)
                    deduplicatedMatches: matchesForCounting,  // Deduplicated matches for counting/stats
                    codedTermCount: deduplicatedCodedTerms.length,
                    harmfulTermCount: deduplicatedHarmfulTerms.length,
                    categoryCount: allCategories.size,
                    categories: Array.from(allCategories)
                };

                displayResults(text, combinedResults);

                // Hide loading state
                document.getElementById('loading').classList.remove('visible');
                document.body.classList.remove('analyzing'); // Remove analyzing state

                // Track analytics (TODO: implement)
                trackAnalysis(text, combinedResults);
            }, 100);
        }

        function displayResults(originalText, results) {
            const textInput = document.getElementById('textInput');
            const textDisplay = document.getElementById('textDisplay');
            const analyzeBtn = document.getElementById('analyzeBtn');
            const clearBtn = document.getElementById('clearBtn');
            const resultsDiv = document.getElementById('results');
            const inputLabel = document.getElementById('inputLabel');

            // Update stats using shared DRY functions
            const matchesToCount = results.deduplicatedMatches || results.matches;
            SignalScore.updateAllStats(matchesToCount, originalText);

            // Build flagged text display
            let displayHtml = '';
            if (results.matches.length === 0) {
                displayHtml = '<div class="no-results">‚úì No coded terms or harmful terms detected in this text.</div>' +
                    '<div style="margin-top: 15px;">' + escapeHtml(originalText) + '</div>';
            } else {
                let lastIndex = 0;

                results.matches.forEach(match => {
                    // Add text before match
                    displayHtml += escapeHtml(originalText.substring(lastIndex, match.start));

                    // Add flagged match with tooltip
                    displayHtml += createFlaggedTermSpan(match, originalText);

                    lastIndex = match.end;
                });

                // Add remaining text
                displayHtml += escapeHtml(originalText.substring(lastIndex));
            }

            textDisplay.innerHTML = displayHtml;

            // Switch UI: hide textarea, show display div
            textInput.classList.add('hidden');
            textDisplay.classList.add('visible');
            analyzeBtn.classList.add('hidden');
            document.getElementById('editBtn').classList.remove('hidden');
            clearBtn.classList.remove('hidden');
            document.getElementById('copyBtn').classList.remove('hidden');
            inputLabel.textContent = 'Analysis Results:';

            // Show stats
            resultsDiv.classList.remove('hidden');

            // Setup smart tooltip positioning
            setupTooltips();
        }

        /**
         * Generate matched term HTML if obfuscation is detected
         *
         * @param {string} matchedTerm - The canonical term that was matched
         * @param {string} displayedText - The actual text shown in the document
         * @param {string} label - Label to use ("Term" or "Derivation")
         * @returns {string} HTML string or empty string if no obfuscation
         */
        function getMatchedTermHtml(matchedTerm, displayedText, label = 'Term') {
            if (!matchedTerm) return '';

            // Check if obfuscation detected (case-insensitive comparison)
            const isObfuscated = matchedTerm.toLowerCase() !== displayedText.toLowerCase();

            if (!isObfuscated) return '';

            return `<div class="tooltip-item"><div class="tooltip-item-label">${label}:</div><div class="tooltip-item-value">${escapeHtml(matchedTerm)}</div></div>`;
        }

        /**
         * Format variations list, limiting to 6 random items if list is too long
         *
         * @param {Array<string>} variations - Array of variation strings
         * @returns {string} HTML string or empty string if no variations
         */
        function getVariationsHtml(variations) {
            if (!variations || variations.length === 0) return '';

            let displayVariations = variations;
            let label = 'Variations';

            // If more than 6 variations, select 6 random ones
            if (variations.length > 6) {
                // Shuffle and take first 6
                const shuffled = [...variations].sort(() => Math.random() - 0.5);
                displayVariations = shuffled.slice(0, 6);
                label = `Variations include`;
            }

            return `<div class="tooltip-item"><div class="tooltip-item-label">${label}:</div><div class="tooltip-item-value tooltip-variations">${escapeHtml(displayVariations.join(' / '))}</div></div>`;
        }

        function createFlaggedTermSpan(match, originalText) {
            const typeClass = match.type || "codedTerm";

            const categoryClass = getCategoryClass(match.category);
            const categoryColor = getCategoryColor(match.category);
            const categoryLabel = getCategoryLabel(match.category);
            const subcategoryLabel = getSubcategoryLabel(match.category);
            const capitalizedDefinition = match.definition;

            const sourceHtml = getTooltipSourceHtml(match.source);
            const displayText = originalText.substring(match.start, match.end);

            const flagBtnHtml = `<button class="tooltip-flag-btn" data-flagged="true">${FLAG_SYMBOLS.FLAGGED}</button>`;

            const categoryItemHtml =
                `<div class="tooltip-item"><div class="tooltip-item-label">Category:</div>` +
                `${escapeHtml(categoryLabel)}</div></div>`;

            const dataAttrs =
                `data-category="${escapeHtml(match.category)}" data-unflagged="false"` +
                (match.parentTerm ? ` data-parent-term="${escapeHtml(match.parentTerm)}"` : "");

            const headerHtml =
                `<div class="tooltip-category" style="background-color: ${categoryColor}">` +
                `${escapeHtml(subcategoryLabel)}${flagBtnHtml}</div>`;

            function typeHtml(isHarmful) {
                return isHarmful
                    ? `<div class="tooltip-item"><div class="tooltip-item-label">Type:</div>‚ò£Ô∏è Harmful Term</div></div>`
                    : `<div class="tooltip-item"><div class="tooltip-item-label">Type:</div>üî£ Coded Term</div>`;
            }

            function simpleItem(label, value) {
                return `<div class="tooltip-item"><div class="tooltip-item-label">${label}:</div>` +
                    `<div class="tooltip-item-value">${escapeHtml(value)}</div></div>`;
            }

            function wrapTooltip(inner) {
                return `<span class="tooltip">${inner}</span>`;
            }

            function wrapFlagged(innerTooltip, isHarmful) {
                // Keep exactly the same outer span shape and class names as your original returns
                const termClass = isHarmful ? "harmfulTerm" : "codedTerm";
                return `<span class="flagged ${categoryClass} ${termClass}" ${dataAttrs}>` +
                    `${escapeHtml(displayText)}${wrapTooltip(innerTooltip)}</span>`;
            }

            // Build the tooltip body
            if (typeClass === "harmfulTerm") {
                const matchedTermHtml = getMatchedTermHtml(match.matchedTerm, match.text, "Term");

                const inner =
                    headerHtml +
                    typeHtml(true) +
                    matchedTermHtml +
                    simpleItem("Definition", capitalizedDefinition) +
                    categoryItemHtml +
                    sourceHtml;

                return wrapFlagged(inner, true);
            }

            // Coded term path
            let termHtmlBlock;
            // Display derviation if sub-category is localist/nationalist/regionalist
            if (match.isDerived && match.category !== "religious-populism") {
                termHtmlBlock = simpleItem("Derivation", match.term);
            } else {
                termHtmlBlock = getMatchedTermHtml(match.matchedTerm, match.text, "Term");
            }

            const variationsHtml = getVariationsHtml(match.variations);

            const inner =
                headerHtml +
                typeHtml(false) +
                termHtmlBlock +
                variationsHtml +
                simpleItem("Coded term", capitalizedDefinition) +
                categoryItemHtml +
                sourceHtml;

            return wrapFlagged(inner, false);
        }


        /**
        * Returns a tooltip-source string for a given source ID.
        */
        function getTooltipSourceHtml(sourceId, pinned) {
            const sourceEntry = SOURCE_DATA.sources.find(s => s.id === sourceId);
            const displayString = escapeHtml(sourceEntry.string || sourceId);
            return `<div class="tooltip-source">Source: <a href= "${sourceEntry.url}" target = "_blank" >${displayString} ‚Üó</a></div>`;
        }


        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Flag button constants
        const FLAG_SYMBOLS = {
            FLAGGED: '‚öë',
            UNFLAGGED: '‚öê'
        };

        const FLAG_TOOLTIP_TEXT = {
            UNFLAG: 'Unflag this term',
            REFLAG: 'Reflag this term'
        };

        // Track currently pinned tooltip (click/touch)
        let pinnedTooltip = null;

        // Detect if device supports touch (mobile/tablet) - used by multiple functions
        const isTouchDevice = window.matchMedia('(hover: none)').matches
            || ('ontouchstart' in window);

        // Tooltip functions moved to js/tooltips.js

        /**
         * Recalculate all stats after unflag/reflag action
         */
        function recalculateAllStats() {
            // Rebuild matches array from current DOM state (excluding unflagged)
            const currentMatches = getCurrentFlaggedMatches();

            // Update all stats using shared function
            updateAllStats(currentMatches, originalAnalyzedText);
        }

        /**
         * Get current flagged matches from DOM (excluding unflagged)
         * @returns {Array} Array of match objects for signal score calculation
         */
        function getCurrentFlaggedMatches() {
            const allFlaggedSpans = document.querySelectorAll('.flagged');
            const matches = [];
            const seenParentTerms = new Set();

            Array.from(allFlaggedSpans).forEach(span => {
                // Skip unflagged terms
                if (span.dataset.unflagged === 'true') return;

                // Get text content WITHOUT the tooltip
                let textContent = '';
                span.childNodes.forEach(node => {
                    if (node.nodeType === Node.TEXT_NODE) {
                        textContent += node.textContent;
                    }
                });

                const match = {
                    type: span.classList.contains('harmfulTerm') ? 'harmfulTerm' : 'codedTerm',
                    category: span.dataset.category,
                    text: textContent.trim()
                };

                // Handle segment deduplication (emoji-split terms)
                const parentTerm = span.dataset.parentTerm;
                if (parentTerm) {
                    // Only count once per parent term
                    if (!seenParentTerms.has(parentTerm)) {
                        seenParentTerms.add(parentTerm);
                        matches.push(match);
                    }
                } else {
                    // Not a segment, count normally
                    matches.push(match);
                }
            });

            return matches;
        }

        function positionFlagTooltip(flagBtn, tooltip, flagTooltip) {
            const tooltipRect = tooltip.getBoundingClientRect();

            // Position: left edge at tooltip's right edge, top edge at tooltip's top edge
            flagTooltip.style.position = 'fixed';
            flagTooltip.style.left = `${tooltipRect.right - parseFloat(THEME_CONFIG.spacing.radius.lg)}px`;
            flagTooltip.style.top = `${tooltipRect.top}px`;
        }

        function positionTooltip(flaggedTerm, tooltip) {
            // Get flaggedTerm position
            const flaggedTermRect = flaggedTerm.getBoundingClientRect();
            const tooltipWidth = 320; // Match CSS width
            const tooltipHeight = tooltip.offsetHeight || 150; // Estimate if not rendered
            const margin = 10;
            const arrowHeight = 8;

            // Viewport dimensions
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            // Calculate initial centered position
            let left = flaggedTermRect.left + (flaggedTermRect.width / 2) - (tooltipWidth / 2);
            let top = flaggedTermRect.top - tooltipHeight - arrowHeight - margin;

            // Reset classes
            tooltip.classList.remove('top', 'bottom', 'align-left', 'align-right');

            // Check if tooltip fits above
            if (top < margin) {
                // Place below instead
                top = flaggedTermRect.bottom + arrowHeight + margin;
                tooltip.classList.add('bottom');
            } else {
                tooltip.classList.add('top');
            }

            // Check horizontal overflow
            if (left < margin) {
                // Align to left edge
                left = margin;
                tooltip.classList.add('align-left');
            } else if (left + tooltipWidth > viewportWidth - margin) {
                // Align to right edge
                left = viewportWidth - tooltipWidth - margin;
                tooltip.classList.add('align-right');
            }

            // Apply position
            tooltip.style.left = `${left}px`;
            tooltip.style.top = `${top}px`;
        }

        function clearAll() {
            const textInput = document.getElementById('textInput');
            const textDisplay = document.getElementById('textDisplay');
            const analyzeBtn = document.getElementById('analyzeBtn');
            const editBtn = document.getElementById('editBtn');
            const clearBtn = document.getElementById('clearBtn');
            const copyBtn = document.getElementById('copyBtn');
            const resultsDiv = document.getElementById('results');
            const inputLabel = document.getElementById('inputLabel');

            // Clear text
            textInput.value = '';
            textDisplay.innerHTML = '';
            originalAnalyzedText = ''; // Reset stored text

            // Switch UI back: show textarea, hide display div
            textInput.classList.remove('hidden');
            textDisplay.classList.remove('visible');
            analyzeBtn.classList.remove('hidden');
            analyzeBtn.disabled = true;
            clearBtn.disabled = true;
            copyBtn.disabled = true;
            editBtn.classList.add('hidden');
            inputLabel.textContent = 'Paste text to analyze:';

            // Hide stats
            resultsDiv.classList.add('hidden');
        }

        function copyText() {
            // Always copy from the textarea (which contains current editable text)
            const textToCopy = document.getElementById('textInput').value;
            if (!textToCopy.trim()) {
                return; // Nothing to copy
            }
            // Use the Clipboard API
            navigator.clipboard.writeText(textToCopy).then(() => {
                // visual feedback
                const copyBtn = document.getElementById('copyBtn');
                // Temporarily override background with disabled color
                copyBtn.style.background = 'var(--btn-clicked-bg)';
                setTimeout(() => {
                    copyBtn.style.background = '';
                }, buttonClickTimeout);

            }).catch(err => {
                console.error('Failed to copy text:', err);
                alert('Failed to copy text to clipboard');
            });
        }

        function trackAnalysis(text, results) {
            // TODO: Implement analytics tracking
            // Track metrics:
            // 1. Total analyses performed
            // 2. Detection rate
            // 3. Average text length
            // 4. Terms detected distribution
            // 5. Return user rate (localStorage)
            // 6. Country-level data (IP geolocation)
            // 7. Time-based patterns

            // console.log('Analytics placeholder:', {
            //     textLength: text.length,
            //     matchCount: results.matches.length,
            //     categories: results.categories
            // });
        }

        // Prevent the user from flagging text outside the text area
        const selectable = document.getElementById('textInput');
        document.addEventListener('selectstart', (e) => {
            if (!selectable.contains(e.target)) {
                e.preventDefault(); // Prevent selection
            }
        });

        // Allow Enter key to submit (with Ctrl/Cmd)
        document.getElementById('textInput').addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                analyzeText();
            }
        });

        // Enable/disable buttons based on text content
        document.getElementById('textInput').addEventListener('input', (e) => {
            const analyzeBtn = document.getElementById('analyzeBtn');
            const copyBtn = document.getElementById('copyBtn');
            const clearBtn = document.getElementById('clearBtn');
            const textInput = document.getElementById('textInput');

            if (textInput.value.trim()) {
                analyzeBtn.disabled = false;
                copyBtn.disabled = false;
                clearBtn.disabled = false;
            } else {
                analyzeBtn.disabled = true;
                copyBtn.disabled = true;
                clearBtn.disabled = true;
            }
        });

        // Reposition tooltips on window resize or scroll
        let tooltipRepositionTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(tooltipRepositionTimeout);
            tooltipRepositionTimeout = setTimeout(() => {
                // Reposition any visible tooltips
                // Desktop: use hover selector, Mobile/pinned: use .tooltip-pinned selector
                const selector = isTouchDevice ? '.tooltip.tooltip-pinned' : '.flagged:hover .tooltip';
                const visibleTooltips = document.querySelectorAll(selector);

                visibleTooltips.forEach(tooltip => {
                    const flaggedTerm = tooltip.closest('.flagged');
                    if (flaggedTerm) {
                        positionTooltip(flaggedTerm, tooltip);
                    }
                });
            }, 100);
        });

        window.addEventListener('scroll', () => {
            // Reposition tooltips on scroll (since they use fixed positioning)
            // Desktop: use hover selector, Mobile/pinned: use .tooltip-pinned selector
            const selector = isTouchDevice ? '.tooltip.tooltip-pinned' : '.flagged:hover .tooltip';
            const visibleTooltips = document.querySelectorAll(selector);

            visibleTooltips.forEach(tooltip => {
                const flaggedTerm = tooltip.closest('.flagged');
                if (flaggedTerm) {
                    positionTooltip(flaggedTerm, tooltip);
                }
            });
        }, { passive: true });
    </script>
</body>

</html>