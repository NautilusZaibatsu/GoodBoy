<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üêï GoodBoy - Sniffing out coded language</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--bg-page);
            background-image: url('images/page_background.png');
            background-repeat: repeat;
            min-height: 100vh;
            padding: var(--spacing-xl);
            color: var(--text-primary);
        }

        a:link {
            color: var(--link-unvisited);
        }

        a:visited {
            color: var(--link-visited);
        }

        a:hover {
            color: var(--link-hover);
        }

        a:active {
            color: var(--link-active);
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            color: var(--text-white);
            margin-bottom: var(--spacing-xxl);
        }

        h1 {
            font-size: var(--font-size-xxl);
            margin-bottom: var(--spacing-sm);
            text-shadow: 2px 2px 4px var(--shadow-light);
        }

        .betaText {
            font-size: var(--font-size-sm);
            margin-left: var(--spacing-sm);
            margin-top: 0.5em;
            font-weight: var(--weight-normal);
            display: inline-block;
            vertical-align: top;
        }

        .tagline {
            font-size: var(--font-size-lg);
            opacity: 0.95;
        }

        .card {
            background: var(--bg-card);
            border-radius: var(--radius-xl);
            padding: var(--spacing-xxl);
            box-shadow: 0 10px 40px var(--shadow-light);
        }

        .input-section {
            margin-bottom: var(--spacing-xl);
        }

        label {
            display: block;
            font-weight: var(--font-weight-semibold);
            margin-bottom: var(--spacing-sm);
            color: var(--text-secondary);
        }

        #textInput {
            width: 100%;
            min-height: 200px;
            padding: var(--spacing-lg);
            border: 2px solid var(--border-default);
            border-radius: var(--radius-lg);
            font-size: var(--font-size-md);
            font-family: inherit;
            resize: vertical;
            transition: border-color 0.3s;
            display: block;
        }

        #textInput:focus {
            outline: none;
            border-color: var(--border-focus);
        }

        #textInput.hidden {
            display: none;
        }

        #textDisplay {
            display: none;
            width: 100%;
            min-height: 200px;
            padding: var(--spacing-lg);
            border: 2px solid var(--color-primary);
            border-radius: var(--radius-lg);
            font-size: var(--font-size-md);
            font-family: inherit;
            background: var(--bg-input);
            line-height: 1.8;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        #textDisplay.visible {
            display: block;
        }

        .button-row {
            display: flex;
            gap: var(--spacing-sm);
            align-items: center;
        }

        button {
            background: var(--btn-primary-bg);
            color: var(--btn-primary-text);
            border: none;
            padding: var(--spacing-md) var(--spacing-xxl);
            border-radius: var(--radius-lg);
            font-size: var(--font-size-md);
            font-weight: var(--font-weight-semibold);
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px var(--shadow-medium);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled,
        .copy-btn:disabled,
        .clear-btn:disabled {
            background: var(--btn-disabled-bg) !important;
            color: var(--btn-disabled-text) !important;
            cursor: not-allowed;
            pointer-events: auto;
            opacity: 1;
            transform: none;
            box-shadow: none;
        }

        .clear-btn {
            background: var(--btn-primary-bg);
            color: var(--btn-primary-text);
        }

        .copy-btn {
            background: var(--btn-primary-bg);
            color: var(--btn-primary-text);
        }

        .hidden {
            display: none !important;
        }

        #results {
            margin-top: var(--spacing-xl);
        }

        .stats-row {
            display: flex;
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-xl);
            flex-wrap: wrap;
        }

        .stat-box {
            flex: 1;
            min-width: 150px;
            padding: var(--spacing-md);
            background: var(--bg-input);
            border-radius: var(--radius-lg);
            text-align: center;
        }

        .stat-value {
            font-size: var(--font-size-xl);
            font-weight: var(--font-weight-bold);
            color: var(--color-primary);
            margin-bottom: var(--spacing-xs);
        }

        .stat-label {
            font-size: var(--font-size-sm);
            color: var(--text-muted);
        }

        .signal-indicator {
            display: inline-block;
            margin-top: var(--spacing-xs);
            padding: var(--spacing-xs) var(--spacing-sm);
            border-radius: var(--radius-xl);
            font-size: var(--font-size-xxs);
            font-weight: var(--font-weight-semibold);
            text-transform: uppercase;
        }

        .signal-low {
            background-color: var(--state-success-bg);
            color: var(--state-success-text);
        }

        .signal-moderate {
            background-color: var(--state-warning-bg);
            color: var(--state-warning-text);
        }

        .signal-high {
            background-color: var(--state-danger-bg);
            color: var(--state-danger-text);
        }

        .signal-severe {
            background-color: var(--state-danger-border);
            color: var(--text-white);
        }

        .info-icon {
            display: inline-block;
            margin-left: var(--spacing-sm);
            cursor: help;
            opacity: 0.6;
            font-size: var(--font-size-sm);
        }

        .info-icon:hover {
            opacity: 1;
        }

        .signal-placeholder {
            background: var(--state-warning-bg);
            border-left: 4px solid var(--state-warning-border);
            padding: var(--spacing-lg);
            border-radius: var(--radius-md);
            margin-bottom: var(--spacing-xl);
        }

        .no-results {
            padding: var(--spacing-lg);
            background: var(--state-success-bg);
            border-left: 4px solid var(--state-success-border);
            border-radius: var(--radius-md);
            color: var(--state-success-text);
            font-weight: var(--font-weight-semibold);
            margin-top: var(--spacing-sm);
        }

        .highlight {
            padding: var(--spacing-xs) 0;
            border-radius: var(--radius-sm);
            cursor: help;
            position: relative;
            transition: background-color 0.2s;
        }

        /* Category-specific highlight colors will be injected dynamically */

        /* Dog whistles: Background color, NO underline */
        .highlight.dogwhistle {
            text-decoration: none;
        }

        /* Offensive terms: ONLY underline, NO background color */
        .highlight.offensiveTerm {
            background-color: transparent !important;
            text-decoration: none;
        }

        .tooltip {
            position: fixed;
            background: var(--bg-tooltip);
            color: var(--text-white);
            padding: var(--spacing-md);
            border-radius: var(--radius-lg);
            width: 320px;
            max-width: 90vw;
            box-shadow: 0 5px 20px var(--shadow-light);
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .highlight:hover .tooltip {
            opacity: 1;
            pointer-events: auto;
        }

        /* Tooltip arrow - default (pointing down from top tooltip) */
        .tooltip::after {
            content: '';
            position: absolute;
            border: 8px solid transparent;
        }

        /* Default: tooltip above, arrow points down */
        .tooltip.top::after {
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border-top-color: var(--bg-tooltip);
        }

        /* Tooltip below, arrow points up */
        .tooltip.bottom::after {
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            border-bottom-color: var(--bg-tooltip);
        }

        /* Arrow on left when tooltip is aligned right */
        .tooltip.align-left::after {
            left: 20px;
        }

        /* Arrow on right when tooltip is aligned left */
        .tooltip.align-right::after {
            left: auto;
            right: 20px;
            transform: translateX(0);
        }

        .tooltip-category {
            display: block;
            padding: var(--spacing-sm) var(--spacing-md);
            margin: calc(-1 * var(--spacing-md)) calc(-1 * var(--spacing-md)) var(--spacing-sm) calc(-1 * var(--spacing-md));
            border-radius: var(--radius-lg) var(--radius-lg) 0 0;
            font-size: var(--font-size-xxs);
            font-weight: var(--font-weight-semibold);
            text-transform: uppercase;
            text-align: center;
            color: var(--text-white);
        }

        .category-badge {
            display: block;
            padding: var(--spacing-xs) var(--spacing-sm);
            border-radius: var(--radius-md);
            font-size: var(--font-size-xs);
            font-weight: var(--font-weight-semibold);
            margin: var(--spacing-xs) 0;
            color: var(--text-white);
        }

        .tooltip-item {
            margin-bottom: var(--spacing-sm);
            font-size: var(--font-size-xs);
            line-height: 1.3;
        }

        .tooltip-item:last-child {
            margin-bottom: 0;
        }

        .tooltip-item-label {
            font-weight: var(--font-weight-bold);
            color: var(--text-white);
            margin-bottom: var(--spacing-xs);
            font-size: var(--font-size-sm);
        }

        .tooltip-item-value {
            color: var(--tooltip-text);
            line-height: 1.4;
        }

        .tooltip-variations {
            color: var(--tooltip-text-muted);
            font-style: italic;
        }

        .tooltip-source {
            margin-top: var(--spacing-sm);
            padding-top: var(--spacing-sm);
            border-top: 1px solid var(--tooltip-border);
            font-size: var(--font-size-tiny);
            color: var(--tooltip-text-muted);
        }

        .tooltip-source a {
            color: var(--text-tooltip-link);
            text-decoration: none;
        }

        .tooltip-source a:hover {
            text-decoration: underline;
        }

        footer {
            margin-top: var(--spacing-sm);
            padding: var(--spacing-xl);
            background: var(--bg-footer-overlay);
            border-radius: var(--radius-xl);
            font-size: var(--font-size-sm);
            color: var(--text-muted);
        }

        .expandable-div {
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            user-select: none;
            padding: var(--spacing-xs) 0;
        }

        .expandable-div h3 {
            color: var(--text-primary);
            margin: 0;
            font-size: 1.1em;
        }

        .expand-div-toggle {
            font-size: 1.2em;
            transition: transform 0.3s;
        }

        .expand-div-toggle.expanded {
            transform: rotate(180deg);
        }

        .expandable-div-content {
            display: none;
            margin-top: var(--spacing-lg);
        }

        .expandable-div-content.visible {
            display: block;
        }

        footer a {
            color: var(--text-link);
            text-decoration: none;
        }

        footer a:hover {
            text-decoration: underline;
        }

        .loading {
            display: none;
            color: var(--color-primary);
            font-weight: var(--font-weight-semibold);
        }

        .loading.visible {
            display: inline;
        }

        @media (max-width: 600px) {
            h1 {
                font-size: var(--font-size-xl);
            }

            .stats-row {
                flex-direction: column;
            }

            .tooltip {
                width: 280px;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <header>
            <div style="display: inline-flex; align-items: flex-start; justify-content: center;">
                <h1>üêï GoodBoy<span class="betaText"></h1>beta</span>
            </div>
            <p class="tagline">
                Sniffing out coded language
            </p>
        </header>

        <div class="card">
            <div class="input-section">
                <label for="textInput" id="inputLabel">Text to analyze:</label>
                <textarea id="textInput"
                    placeholder="Enter or paste text here to check for coded and harmful language..."></textarea>
                <div id="textDisplay"></div>
            </div>

            <div class="button-row">
                <button id="analyzeBtn" onclick="analyzeText()">Analyze</button>
                <button class="hidden" id="editBtn" onclick="editText()">Edit</button>
                <button class="copy-btn" id="copyBtn" onclick="copyText()">Copy</button>
                <button class="clear-btn" id="clearBtn" onclick="clearAll()">Clear</button>
                <span class="loading" id="loading">Analyzing...</span>
            </div>

            <div id="results" class="hidden">
                <div class="stats-row">
                    <div class="stat-box">
                        <div class="stat-value" id="termCount">0</div>
                        <div class="stat-label">Terms Flagged</div>
                        <div id="termBreakdown" style="margin-top: 8px; font-size: 0.75em; color: var(--color-muted);">
                        </div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="mainCategoryCount">0</div>
                        <div class="stat-label">Main Categories</div>
                        <div id="mainCategoryList" style="margin-top: 10px; font-size: 0.85em; text-align: left;"></div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="subCategoryCount">0</div>
                        <div class="stat-label">Subcategories</div>
                        <div id="subCategoryList" style="margin-top: 10px; font-size: 0.85em; text-align: left;"></div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="signalScore">0%</div>
                        <div class="stat-label">Signal Score</div>
                        <div id="signalIndicator"></div>
                    </div>
                </div>
            </div>
        </div>

        <footer>
            <div class="expandable-div" onclick="toggleInstructions()">
                <h3>Help</h3>
                <span class="expand-div-toggle">‚ñº</span>
            </div>
            <div class="expandable-div-content" id="instructionContent">

                <table style="width: 100%">
                    <tr>
                        <td style="width: 70%; vertical-align:top">
                            <p>
                            <h3>Instructions</h3>
                            <br>
                            <b>1.</b> Type or paste your text into the input area.<br>
                            <b>2.</b> Click 'Analyze'.<br>
                            <b>3.</b> Hover over highlighted or underlined terms to see their meanings.
                            <br>
                            The color denotes the category (see legend).<br>
                            <b>4.</b> Check the signal score to see how much coded or harmful language appears.
                            <br>
                            <b>5.</b> Hover over the ‚ìò icon for signal score calculation details
                            </p>
                            <br>
                            <p>
                                <b>Note:</b> A high signal score doesn't automatically indicate harmful intent.<br>
                            </p>
                            <br>
                        </td>
                        <td style="padding-left: var(--spacing-lg); padding-right: var(--spacing-lg)">
                            <h3>Legend</h3>
                            <div id="legend"></div>
                        </td>
                    </tr>
                </table>
            </div>
        </footer>

        <footer>
            <div class="expandable-div" onclick="toggleAbout()">
                <h3>About</h3>
                <span class="expand-div-toggle">‚ñº</span>
            </div>
            <div class="expandable-div-content" id="aboutContent">
                <p>
                    GoodBoy is a free, open-source tool for identifying dog whistles and harmful language, designed to
                    promote understanding of coded rhetoric and help users recognise hateful or discriminatory content.
                </p>
                <br>
                <p>
                    All analysis happens locally in your browser. No data is sent to any server.
                </p>
                <br>
                <p>
                    Database: <strong><span id="dbTermCount">Loading...</span></strong>
                </p>
                <br>

                <p>
                    Created by the GoodBoy Team | <a href=https://ko-fi.com/nautiluszaibatsu> Support this project ‚Üó</a>
                    <br>
                    Contributions welcome via the official <a href=https://github.com/NautilusZaibatsu/GoodBoy> GitHub
                        Repository ‚Üó</a>
                </p>
                <br>
                <p>
                    License: Source-Available. ¬© GoodBoy 2026<br>
                    Free to use. No redistribution, modification, or re-hosting permitted.<br>
                </p>
            </div>
        </footer>

        <footer>
            <div class="expandable-div" onclick="toggleAttribution()">
                <h3>Data Sources</h3>
                <span class="expand-div-toggle">‚ñº</span>
            </div>
            <div class="expandable-div-content" id="attributionContent">

                <div id="dataset-attributions"></div>

            </div>
        </footer>
    </div>

    <!-- Load the dog whistle database -->
    <script src="data/dogwhistle_data.js"></script>

    <!-- Load the offensive term database -->
    <script src="data/offensive_term_data.js"></script>

    <!-- Load the source  database -->
    <script src="data/source_data.js"></script>

    <!-- Load shared obfuscation utilities (DRY - single source of truth) -->
    <script src="js/obfuscation-utils.js"></script>


    <!-- Load theme configuration (design system) -->
    <script src="js/theme-config.js"></script>

    <!-- Load category hierarchy (shared with dev-tools) -->
    <script src="js/category-config.js"></script>

    <!-- Load unified place-demonym lookup -->
    <script src="data/place_demonym_lookup.js"></script>

    <!-- Main application logic -->
    <script>
        // Initialize and render the attributions
        renderAttributions();
        // Initialize the pattern matchers
        let matcher = null;
        let offensiveTermMatcher = null;

        // Store original text for re-analysis
        let originalAnalyzedText = '';

        // Initialize the legend for the how to section
        const legendDiv = document.getElementById('legend');
        let legendHtml = '';

        Object.entries(CATEGORY_HIERARCHY).forEach(([slug, cat]) => {
            legendHtml += `<span class="category-badge" style="background-color: ${cat.darkColor}">${cat.label}</span>`;
        });
        legendDiv.innerHTML = legendHtml;

        // Theme configuration loaded from js/theme-config.js
        // THEME_CONFIG and initializeTheme() are now defined in that file

        /**
         * POPULIST PATTERN MATCHING SYSTEM
         *
         * Detects nationalist and localist language patterns by recognizing place/group names
         * and checking if similar patterns exist in the dog whistle database with different places.
         *
         * Example: If database contains "America First", it will also flag "Britain First",
         * "Make Liverpool Great Again" (from "MAGA"), "hard-working Indians" (from "hard-working Americans")
         *
         * Hybrid Categorization:
         * - Dynamic patterns with nationalist/localist category ‚Üí auto-categorize by place type:
         *   - Countries ‚Üí Nationalist
         *   - Regions/cities ‚Üí Localist
         * - Dynamic patterns with other categories (racist, antisemitic, etc.) ‚Üí preserve original category
         */

        // Morphological generator: converts places to group names (demonyms)
        // MorphologyUtils is now imported from /js/morphology-utils.js (shared with dev-tools)

        // Pattern extractor and matcher for populist language
        const PatternMatcher = {
            patterns: [],
            place_demonym_lookup_loaded: false,

            // Initialize by extracting patterns from dog whistles
            initialize(dogWhistles) {
                if (typeof PLACE_DEMONYM_LOOKUP === 'undefined') {
                    console.warn('Place-demonym lookup not loaded yet, pattern matching disabled');
                    return;
                }

                // Build indices for fast lookups
                PLACE_DEMONYM_LOOKUP.buildIndices();

                this.place_demonym_lookup_loaded = true;
                this.allPlaces = PLACE_DEMONYM_LOOKUP.getAllVariants();

                // Build place ‚Üí type mapping for backward compatibility
                this.placeTypes = {};
                ['country', 'region', 'city'].forEach(type => {
                    const places = PLACE_DEMONYM_LOOKUP.getPlacesByType(type);
                    places.forEach(place => {
                        place.variants.forEach(variant => {
                            this.placeTypes[variant.toLowerCase()] = type;
                        });
                    });
                });

                // Extract patterns from dog whistles
                this.extractPatterns(dogWhistles);
            },

            // Extract patterns from existing dog whistles
            extractPatterns(dogWhistles) {
                const seenPatterns = new Set(); // Deduplicate by pattern text

                dogWhistles.forEach(dw => {
                    // SKIP if not dynamic mode - location-specific patterns shouldn't generate variations
                    if (!dw.categoryMode || dw.categoryMode !== 'dynamic') {
                        return; // Don't extract pattern - location-specific (e.g., "Israel Lobby", "China Virus")
                    }

                    // Process root AND all variations
                    const termsToCheck = [dw.root, ...(dw.variations || [])];

                    termsToCheck.forEach(term => {
                        let placeFound = this.findPlaceInText(term);
                        let demonymFound = this.findDemonymInText(term);

                        // If both place and demonym found, check if they overlap
                        // If they overlap, choose the longer match (e.g., "Americans" over "America")
                        if (placeFound && demonymFound) {
                            const lowerTerm = term.toLowerCase();
                            const placeIndex = lowerTerm.indexOf(placeFound.place.toLowerCase());
                            const demonymIndex = lowerTerm.indexOf(demonymFound.demonym.toLowerCase());
                            const placeEnd = placeIndex + placeFound.place.length;
                            const demonymEnd = demonymIndex + demonymFound.demonym.length;

                            // Check for overlap: ranges overlap if start < otherEnd AND end > otherStart
                            if (placeIndex < demonymEnd && placeEnd > demonymIndex) {
                                // They overlap - choose the longer one
                                if (demonymFound.demonym.length > placeFound.place.length) {
                                    placeFound = null; // Keep demonym
                                } else {
                                    demonymFound = null; // Keep place
                                }
                            }
                            // If no overlap, keep both (e.g., "Keep England English")
                        }

                        // 3. Create pattern with placeholders
                        let patternText = term.toLowerCase();
                        let placeholders = [];
                        let demonymForm = null;
                        let basePlace = null;

                        if (placeFound && demonymFound) {
                            // Both place and demonym ‚Üí two placeholders
                            // Replace place first, then demonym to avoid conflicts
                            patternText = patternText
                                .replace(placeFound.matchedText.toLowerCase(), '[place]')
                                .replace(demonymFound.demonym.toLowerCase(), '[demonym]');

                            placeholders = ['place', 'demonym'];
                            demonymForm = demonymFound.form;

                        } else if (placeFound) {
                            // Only place ‚Üí single placeholder (like "America First")
                            patternText = patternText.replace(placeFound.matchedText.toLowerCase(), '[place]');
                            placeholders = ['place'];

                        } else if (demonymFound) {
                            // Only demonym ‚Üí reverse-lookup place, single placeholder
                            patternText = patternText.replace(demonymFound.demonym.toLowerCase(), '[demonym]');
                            placeholders = ['demonym'];
                            demonymForm = demonymFound.form;
                            basePlace = demonymFound.place;
                        }

                        // Only add pattern if we found at least one placeholder and there's context
                        if (placeholders.length > 0) {
                            // Check that there's context around the placeholder(s)
                            const hasContext = patternText.replace(/\[place\]/g, '').replace(/\[demonym\]/g, '').trim().length > 0;

                            if (hasContext) {
                                // Deduplicate: only add if we haven't seen this pattern text before
                                if (!seenPatterns.has(patternText)) {
                                    seenPatterns.add(patternText);
                                    const pattern = {
                                        original: term,
                                        pattern: patternText,
                                        placeholders: placeholders,
                                        demonymForm: demonymForm,
                                        basePlace: basePlace, // For demonym-only patterns
                                        dogWhistle: dw
                                    };
                                    this.patterns.push(pattern);
                                }
                            }
                        }
                    });
                });

                console.log(`Extracted ${this.patterns.length} dynamic patterns`);
            },

            // Find place names in text
            findPlaceInText(text) {
                const lowerText = text.toLowerCase();

                // Iterate through all place variants and check if they appear in text
                for (const placeVariant of this.allPlaces) {
                    const lowerPlace = placeVariant.toLowerCase();
                    const regex = new RegExp(`\\b${lowerPlace}\\b`, 'i');

                    if (regex.test(text)) {
                        const placeData = PLACE_DEMONYM_LOOKUP.findPlaceByVariant(placeVariant);
                        if (placeData) {
                            return {
                                place: placeData.canonical,
                                type: placeData.type,
                                isGroup: false,
                                matchedText: placeVariant  // Add the actual matched variant
                            };
                        }
                    }
                }

                return null;
            },

            // Find demonym in text and return place info
            findDemonymInText(text) {
                const lowerText = text.toLowerCase();

                // Iterate through all places and check if any of their demonyms appear in text
                for (const placeVariant of this.allPlaces) {
                    const placeData = PLACE_DEMONYM_LOOKUP.findPlaceByVariant(placeVariant);
                    if (!placeData) continue;

                    // Check each demonym for this place
                    for (const demonym of placeData.demonyms) {
                        const regex = new RegExp(`\\b${demonym}\\b`, 'i');
                        if (regex.test(text)) {
                            return {
                                demonym: demonym,
                                place: placeData.canonical,
                                type: placeData.type
                            };
                        }
                    }
                }

                return null;
            },

            // Analyze text for pattern matches
            analyze(text) {
                if (!this.place_demonym_lookup_loaded || this.patterns.length === 0) {
                    console.log(
                        'Pattern matching skipped:',
                        !this.place_demonym_lookup_loaded ? 'place_demonym_lookup not loaded' : 'no patterns'
                    );
                    return { matches: [] };
                }

                const potentialMatches = [];
                const lowerText = text.toLowerCase();

                this.patterns.forEach(pattern => {
                    this.allPlaces.forEach(placeVariant => {
                        const placeData = PLACE_DEMONYM_LOOKUP.findPlaceByVariant(placeVariant);
                        if (!placeData) return;

                        const allDemonyms = placeData.demonyms;
                        let expectedTexts = [];

                        if (pattern.placeholders.includes('place') && pattern.placeholders.includes('demonym')) {
                            allDemonyms.forEach(demonym => {
                                const expected = pattern.pattern
                                    .replace('[place]', placeVariant)    // preserve dataset variant capitalization
                                    .replace('[demonym]', demonym);     // preserve demonym capitalization
                                expectedTexts.push({ text: expected, demonym: demonym, isGroup: true });
                            });

                        } else if (pattern.placeholders.includes('place')) {
                            const expected = pattern.pattern.replace('[place]', placeVariant);
                            expectedTexts.push({ text: expected, demonym: null, isGroup: false });

                        } else if (pattern.placeholders.includes('demonym')) {
                            allDemonyms.forEach(demonym => {
                                const expected = pattern.pattern.replace('[demonym]', demonym);
                                expectedTexts.push({ text: expected, demonym: demonym, isGroup: true });
                            });
                        }

                        expectedTexts.forEach(({ text: expectedText, demonym, isGroup }) => {
                            // Case-insensitive flexible matching
                            const patternString = ObfuscationUtils.createFlexiblePattern(expectedText);
                            const flexiblePattern = new RegExp(`${patternString}s?`, 'gi'); // catch plurals

                            let match;
                            while ((match = flexiblePattern.exec(text)) !== null) {
                                const start = match.index;
                                const end = start + match[0].length;
                                const actualMatchedText = text.substring(start, end); // preserves input capitalization

                                const placeInfo = {
                                    place: placeData.canonical,
                                    type: this.placeTypes[placeVariant.toLowerCase()],
                                    isGroup: isGroup
                                };

                                const category = this.determineCategoryForMatch(pattern, placeInfo);

                                potentialMatches.push({
                                    type: 'dogwhistle',
                                    text: actualMatchedText,                       // use matched text for UI
                                    term: `${pattern.dogWhistle.root} ‚Üí ${expectedText}`, // derivation
                                    category: category,
                                    definition: pattern.dogWhistle.definition,
                                    variations: pattern.dogWhistle.variations,
                                    isPatternMatch: true,
                                    originalPattern: pattern.original,
                                    detectedPlace: placeVariant,                  // preserve dataset variant for reference
                                    isDerived: true,
                                    derivedFrom: pattern.dogWhistle.root,
                                    start: start,
                                    end: end,
                                    source: pattern.dogWhistle.source
                                });
                            }
                        });
                    });
                });

                // Filter overlapping matches - keep longest ones
                const matches = [];
                potentialMatches.sort((a, b) => (b.end - b.start) - (a.end - a.start)); // Sort by length (longest first)

                potentialMatches.forEach(match => {
                    // Check if this match overlaps with any already-kept match
                    const hasOverlap = matches.some(existing => {
                        return match.start < existing.end && match.end > existing.start;
                    });

                    if (!hasOverlap) {
                        console.log(`‚úì Pattern match: "${match.text}" (pattern: ${match.originalPattern})`);
                        matches.push(match);
                    }
                });

                console.log(`Pattern matching complete: ${matches.length} matches found`);
                return { matches };
            },

            // Determine category based on place type
            determineCategory(placeInfo) {
                // Check place type (countries = nationalist, regions/cities = localist)
                if (placeInfo.type === 'country') {
                    return 'nationalist';
                } else if (placeInfo.type === 'region' || placeInfo.type === 'city') {
                    return 'localist';
                }
                return 'nationalist'; // Default
            },

            // Determine category for a match using hybrid logic
            determineCategoryForMatch(pattern, placeInfo) {
                const originalCategory = pattern.dogWhistle.category;

                // For dynamic patterns, use hybrid approach:
                // - If original is nationalist/localist ‚Üí auto-categorize by place type
                // - Otherwise (racist, antisemitic, etc.) ‚Üí preserve original category
                if (originalCategory === 'nationalist' || originalCategory === 'localist') {
                    // Auto-categorize based on place type
                    return this.determineCategory(placeInfo);
                }

                // For all other categories, preserve the original
                // This ensures racist patterns stay racist, antisemitic stay antisemitic, etc.
                return originalCategory;
            }
        };

        // ObfuscationUtils is loaded from js/obfuscation-utils.js (DRY principle)
        // Single source of truth for all pattern matching logic

        // Hierarchical category system - Main categories used for highlighting colors
        // Subcategories shown in tooltips and detailed breakdowns
        // CATEGORY_HIERARCHY is now imported from /js/category-config.js

        // Build reverse mapping: subcategory -> main category
        const SUBCATEGORY_TO_MAIN = {};
        Object.keys(CATEGORY_HIERARCHY).forEach(mainKey => {
            const mainCat = CATEGORY_HIERARCHY[mainKey];
            Object.keys(mainCat.sub).forEach(subKey => {
                SUBCATEGORY_TO_MAIN[subKey] = mainKey;
            });
        });

        function renderAttributions() {
            const container = document.getElementById('dataset-attributions');
            container.innerHTML = ''; // Clear previous content if any

            SOURCE_DATA.sources.forEach(source => {
                const p = document.createElement('p');
                p.style.marginTop = '10px';

                // Dataset title
                const strong = document.createElement('strong');
                strong.textContent = source.description || source.string || source.id;
                p.appendChild(strong);

                // Prepare links
                const links = [];
                if (source.url) {
                    const a = document.createElement('a');
                    a.href = source.url;
                    a.target = '_blank';
                    a.rel = 'noopener';
                    a.textContent = 'View Dataset ‚Üó';
                    links.push(a);
                }
                if (source.paper) {
                    const a = document.createElement('a');
                    a.href = source.paper;
                    a.target = '_blank';
                    a.rel = 'noopener';
                    a.textContent = 'Read Paper ‚Üó';
                    links.push(a);
                }
                // Only add links and page break if they exist
                if (links.length > 0) {
                    p.appendChild(document.createElement('br')); // line break after title
                    links.forEach((link, idx) => {
                        p.appendChild(link);
                        if (idx < links.length - 1) {
                            p.appendChild(document.createTextNode(' | '));
                        }
                    });
                }
                container.appendChild(p);
            });
        }

        // Helper to get main category for a subcategory
        function getMainCategory(subcategory) {
            return SUBCATEGORY_TO_MAIN[subcategory?.toLowerCase()] || null;
        }


        // Default colors for unknown categories
        const DEFAULT_COLORS = {
            lightColor: "var(--color-primary)",
            hoverColor: "var(--color-primary)",
            darkColor: "var(--color-primary)"
        };

        // Inject dynamic CSS for MAIN category colors (used for highlighting)
        function injectCategoryStyles() {
            const styleEl = document.createElement('style');
            let css = '';

            // Generate CSS for each MAIN category
            Object.keys(CATEGORY_HIERARCHY).forEach(mainKey => {
                const mainCat = CATEGORY_HIERARCHY[mainKey];
                const className = mainKey.toLowerCase().replace(/\s+/g, '-');

                css += `
                    .highlight.${className} {
                        background-color: ${mainCat.lightColor};
                    }
                    .highlight.${className}:hover {
                        background-color: ${mainCat.hoverColor};
                    }
                `;
            });

            // Add default "other" category
            css += `
                .highlight.other {
                    background-color: ${DEFAULT_COLORS.lightColor};
                }
                .highlight.other:hover {
                    background-color: ${DEFAULT_COLORS.hoverColor};
                }
            `;

            styleEl.textContent = css;
            document.head.appendChild(styleEl);
        }

        // Get the subcategory label and color
        function getSubcategoryInfo(subcategory) {
            const mainKey = getMainCategory(subcategory);
            if (!mainKey) return null;

            const mainCat = CATEGORY_HIERARCHY[mainKey];
            const subInfo = mainCat.sub[subcategory.toLowerCase()];

            return subInfo ? {
                label: subInfo.label,
                darkColor: subInfo.darkColor,
                mainLabel: mainCat.label,
                mainKey: mainKey
            } : null;
        }

        // Get the color for a category (returns subcategory color for tooltips)
        function getCategoryColor(subcategory) {
            const info = getSubcategoryInfo(subcategory);
            return info ? info.darkColor : DEFAULT_COLORS.darkColor;
        }

        // Get the CSS class for highlighting (uses MAIN category)
        function getCategoryClass(subcategory) {
            const mainKey = getMainCategory(subcategory);
            if (!mainKey) return 'other';
            return mainKey.toLowerCase().replace(/\s+/g, '-');
        }

        // Get formatted label for tooltip: "Main : Sub"
        function getFormattedCategoryLabel(subcategory) {
            const info = getSubcategoryInfo(subcategory);
            if (!info) return subcategory;
            return `${info.mainLabel} : ${info.label}`;
        }

        /**
         * Filter redundant variations from database terms
         * Uses ObfuscationUtils to detect and remove variations that our pattern matcher
         * will catch anyway (punctuation, case, hyphenation, plurals, etc.)
         *
         * This maintains DRY by using the SAME logic that our pattern matcher uses,
         * rather than duplicating it in Python.
         */
        function filterRedundantVariations(terms) {
            let totalRemoved = 0;

            const filtered = terms.map(term => {
                const root = term.root;
                const variations = term.variations || [];
                const originalCount = variations.length;

                // Track unique normalized forms to detect duplicates
                const seenNormalized = new Set();

                // Normalize and track root
                const rootNorm = ObfuscationUtils.normalizeText(root);
                const rootClean = rootNorm.replace(/[\s\-_]/g, '');
                seenNormalized.add(rootClean);

                // Filter variations
                const kept = variations.filter(variation => {
                    // Skip exact duplicates of root (case-insensitive)
                    if (variation.toLowerCase() === root.toLowerCase()) {
                        return false;
                    }

                    // Skip if it's a punctuation/case/hyphenation variant of root
                    if (ObfuscationUtils.isPunctuationVariant(variation, root)) {
                        return false;
                    }

                    // Check for duplicate normalized forms
                    const varNorm = ObfuscationUtils.normalizeText(variation);
                    const varClean = varNorm.replace(/[\s\-_]/g, '');

                    if (seenNormalized.has(varClean)) {
                        return false;
                    }

                    // Check if this is a plural of root or another kept variation
                    if (variation.endsWith('s') && variation.length > 1) {
                        const singular = variation.slice(0, -1);
                        const singularClean = ObfuscationUtils.normalizeText(singular).replace(/[\s\-_]/g, '');

                        // Skip if plural of root
                        if (singularClean === rootClean) {
                            return false;
                        }

                        // Skip if plural of a variation we're keeping
                        if (seenNormalized.has(singularClean)) {
                            return false;
                        }
                    }

                    // Keep this variation and track its normalized form
                    seenNormalized.add(varClean);
                    return true;
                });

                totalRemoved += originalCount - kept.length;

                return { ...term, variations: kept };
            });

            if (totalRemoved > 0) {
                console.log(`‚úì Filtered out ${totalRemoved} redundant variations (punctuation, case, plurals, etc.)`);
            }

            return filtered;
        }

        // Load and prepare data on page load
        window.addEventListener('DOMContentLoaded', () => {
            // Initialize theme (inject CSS custom properties)
            initializeTheme();

            // Inject category-specific CSS styles
            injectCategoryStyles();

            // Set initial disabled state for buttons
            document.getElementById('analyzeBtn').disabled = true;
            document.getElementById('copyBtn').disabled = true;
            document.getElementById('clearBtn').disabled = true;

            let dogWhistleData = null;
            let offensiveTermData = null;

            // Check dog whistle database
            if (typeof GOODBOY_DATA !== 'undefined') {
                // Filter redundant variations using our pattern matching logic
                const filteredTerms = filterRedundantVariations(GOODBOY_DATA.terms);
                dogWhistleData = {
                    ...GOODBOY_DATA,
                    terms: filteredTerms
                };
                console.log(`‚úì Loaded ${GOODBOY_DATA.uniqueTerms} dog whistles`);
            } else {
                console.error('Failed to load dog whistle database');
            }

            // Check offensive term database
            if (typeof GOODBOY_OFFENSIVE_TERM_DATA !== 'undefined') {
                // Filter redundant variations using our pattern matching logic
                const filteredOffensiveTerms = filterRedundantVariations(GOODBOY_OFFENSIVE_TERM_DATA.terms);
                offensiveTermData = {
                    ...GOODBOY_OFFENSIVE_TERM_DATA,
                    terms: filteredOffensiveTerms
                };
                console.log(`‚úì Loaded ${GOODBOY_OFFENSIVE_TERM_DATA.uniqueTerms} offensive terms`);
            } else {
                console.error('Failed to load offensive term database');
            }

            // Update database term count in footer
            const dbTermCountEl = document.getElementById('dbTermCount');
            if (dbTermCountEl) {
                const dogWhistleCount = dogWhistleData ? dogWhistleData.uniqueTerms : 0;
                const offensiveTermCount = offensiveTermData ? offensiveTermData.uniqueTerms : 0;

                if (dogWhistleCount > 0 && offensiveTermCount > 0) {
                    const offensiveTermText = offensiveTermCount === 1 ? 'harmful term' : 'harmful terms';
                    dbTermCountEl.textContent = `${dogWhistleCount} dog whistles and ${offensiveTermCount} ${offensiveTermText}`;
                } else if (dogWhistleCount > 0) {
                    dbTermCountEl.textContent = `${dogWhistleCount} dog whistles`;
                } else if (offensiveTermCount > 0) {
                    const offensiveTermText = offensiveTermCount === 1 ? 'harmful term' : 'harmful terms';
                    dbTermCountEl.textContent = `${offensiveTermCount} ${offensiveTermText}`;
                } else {
                    dbTermCountEl.textContent = 'Error loading';
                }
            }

            // Initialize matchers with the databases
            if (dogWhistleData) {
                matcher = new DogWhistleMatcher(dogWhistleData);
            } else {
                console.error('Error: Failed to load dog whistle database.');
            }

            if (offensiveTermData) {
                offensiveTermMatcher = new OffensiveTermMatcher(offensiveTermData);
            } else {
                console.error('Error: Failed to load offensive term database.');
            }

            // Initialize pattern matcher for populist detection
            if (dogWhistleData && typeof PLACE_DEMONYM_LOOKUP !== 'undefined') {
                PatternMatcher.initialize(dogWhistleData.terms);
                console.log('‚úì Pattern matcher initialized for populist detection');
            } else if (typeof PLACE_DEMONYM_LOOKUP === 'undefined') {
                console.warn('Place-demonym lookup not loaded, populist pattern matching disabled');
            }

            if (!dogWhistleData && !offensiveTermData) {
                alert('Error: Failed to load databases. Please refresh the page.');
            }
        });

        function editText() {
            // User clicked "Edit Text" button - restore editable state
            clearAnalysisHighlights();
        }

        function toggleInstructions() {
            const content = document.getElementById('instructionContent');
            const toggle = document.querySelector('.expand-div-toggle');

            content.classList.toggle('visible');
            toggle.classList.toggle('expanded');
        }

        function toggleAbout() {
            const content = document.getElementById('aboutContent');
            const toggle = document.querySelector('.expand-div-toggle');

            content.classList.toggle('visible');
            toggle.classList.toggle('expanded');
        }

        function toggleAttribution() {
            const content = document.getElementById('attributionContent');
            const toggle = document.querySelector('.expand-div-toggle');

            content.classList.toggle('visible');
            toggle.classList.toggle('expanded');
        }

        function clearAnalysisHighlights() {
            const textInput = document.getElementById('textInput');
            const textDisplay = document.getElementById('textDisplay');
            const analyzeBtn = document.getElementById('analyzeBtn');
            const editBtn = document.getElementById('editBtn');
            const resultsDiv = document.getElementById('results');
            const inputLabel = document.getElementById('inputLabel');

            // Check if analysis is currently displayed
            if (textDisplay.classList.contains('visible') && originalAnalyzedText) {
                // Put original text back into the editable textarea
                textInput.value = originalAnalyzedText;

                // Switch from display div back to editable textarea
                textDisplay.classList.remove('visible');
                textDisplay.innerHTML = '';
                textInput.classList.remove('hidden');

                // Update label
                inputLabel.textContent = 'Text to analyze:';

                // Show Analyze button, hide Edit button (keep Clear button visible)
                analyzeBtn.classList.remove('hidden');
                analyzeBtn.disabled = false;
                editBtn.classList.add('hidden');

                // Hide results stats
                resultsDiv.classList.add('hidden');
            }
        }

        class DogWhistleMatcher {
            constructor(dogWhistleData) {
                // Store dog whistle data
                this.dogWhistleData = dogWhistleData;
                this.dogWhistleTerms = dogWhistleData.terms;

                // Build lookup map for dog whistles using DRY helper
                this.variationMap = ObfuscationUtils.buildVariationMap(this.dogWhistleTerms);
            }

            analyze(text) {
                // Normalize Unicode characters to ensure consistent matching
                text = text.normalize('NFC');

                const allMatches = [];

                // Find all dog whistle matches
                this.variationMap.forEach((termData, variation) => {
                    // Create flexible regex pattern that catches obfuscation
                    const flexiblePattern = ObfuscationUtils.createFlexiblePattern(variation);
                    // Add optional 's' at the end to catch plurals
                    const pluralPattern = `${flexiblePattern}s?`;
                    // Use lookahead/lookbehind instead of \b to handle non-word chars like $ and @
                    // This ensures pattern works even when word chars are replaced with symbols
                    const regex = new RegExp(`(?<![a-z0-9])${pluralPattern}(?![a-z0-9])`, 'gi');

                    let match;
                    let lastIndex = -1;
                    while ((match = regex.exec(text)) !== null) {
                        if (match.index === lastIndex && match[0].length === 0) {
                            regex.lastIndex++;
                            continue;
                        }
                        lastIndex = match.index;

                        allMatches.push({
                            start: match.index,
                            end: match.index + match[0].length,
                            length: match[0].length,
                            text: match[0],
                            type: 'dogwhistle',
                            term: termData.root,
                            category: termData.category,
                            definition: termData.definition,
                            variations: termData.variations,
                            source: termData.source // Pass through source field
                        });
                    }
                });

                // Remove overlapping matches, keeping the longest/most specific ones
                // Sort by: 1) length (descending), 2) position (ascending)
                allMatches.sort((a, b) => {
                    if (b.length !== a.length) return b.length - a.length;
                    return a.start - b.start;
                });

                const matches = [];
                const usedRanges = [];

                // Keep matches that don't overlap with already-selected matches
                for (const match of allMatches) {
                    const hasOverlap = usedRanges.some(range => ObfuscationUtils.overlaps(match, range));
                    if (!hasOverlap) {
                        matches.push(match);
                        usedRanges.push({ start: match.start, end: match.end });
                    }
                }

                // Sort final matches by position for display
                matches.sort((a, b) => a.start - b.start);

                // Count unique categories
                const foundCategories = new Set(matches.map(m => m.category));

                return {
                    matches,
                    categoryCount: foundCategories.size,
                    categories: Array.from(foundCategories)
                };
            }
        }

        class OffensiveTermMatcher {
            constructor(offensiveTermData) {
                // Store offensive term data
                this.offensiveTermData = offensiveTermData;
                this.offensiveTermTerms = offensiveTermData.terms;

                // Build lookup map for offensive terms using DRY helper
                this.variationMap = ObfuscationUtils.buildVariationMap(this.offensiveTermTerms);
            }

            analyze(text) {
                // Normalize Unicode characters to ensure consistent matching
                text = text.normalize('NFC');

                const allMatches = [];

                // Find all offensive term matches
                this.variationMap.forEach((termData, variation) => {
                    // Create flexible regex pattern that catches obfuscation
                    const flexiblePattern = ObfuscationUtils.createFlexiblePattern(variation);
                    // Add optional 's' at the end to catch plurals
                    const pluralPattern = `${flexiblePattern}s?`;
                    const regex = new RegExp(`(?<![a-z0-9])${pluralPattern}(?![a-z0-9])`, 'gi');

                    let match;
                    let lastIndex = -1;
                    while ((match = regex.exec(text)) !== null) {
                        if (match.index === lastIndex && match[0].length === 0) {
                            regex.lastIndex++;
                            continue;
                        }
                        lastIndex = match.index;

                        allMatches.push({
                            start: match.index,
                            end: match.index + match[0].length,
                            length: match[0].length,
                            text: match[0],
                            type: 'offensiveTerm',
                            term: termData.root,
                            category: termData.category,
                            definition: termData.definition,
                            variations: termData.variations,
                            source: termData.source
                        });
                    }
                });

                // Remove overlapping matches, keeping the longest/most specific ones
                allMatches.sort((a, b) => {
                    if (b.length !== a.length) return b.length - a.length;
                    return a.start - b.start;
                });

                const matches = [];
                const usedRanges = [];

                for (const match of allMatches) {
                    const hasOverlap = usedRanges.some(range => ObfuscationUtils.overlaps(match, range));
                    if (!hasOverlap) {
                        matches.push(match);
                        usedRanges.push({ start: match.start, end: match.end });
                    }
                }

                // Sort final matches by position for display
                matches.sort((a, b) => a.start - b.start);

                // Count unique categories
                const foundCategories = new Set(matches.map(m => m.category));

                return {
                    matches,
                    categoryCount: foundCategories.size,
                    categories: Array.from(foundCategories)
                };
            }
        }

        function calculateSignalScore(text, matches) {
            // Count words in text
            const wordCount = text.trim().split(/\s+/).length;
            if (matches.length === 0 || wordCount === 0) return {
                total: 0,
                breakdown: {
                    densityScore: 0,
                    typeWeight: 0,
                    categoryScore: 0,
                    densityPercent: 20,
                    typePercent: 50,
                    categoryPercent: 30,
                    matchCount: 0,
                    wordCount: 0,
                    offensiveCount: 0,
                    dogWhistleCount: 0,
                    uniqueCategories: 0
                }
            };

            // 1. Match Density (20%) - Percentage of words that are problematic
            const matchDensity = matches.length / wordCount;
            const densityScore = Math.min(matchDensity * 100, 20);

            // 2. Match Type Weight (50%) - Offensive terms weighted higher than dog whistles
            // Offensive terms are explicit, dog whistles are coded
            const offensiveCount = matches.filter(m => m.type === 'offensiveTerm').length;
            const dogWhistleCount = matches.filter(m => m.type === 'dogwhistle').length;

            // Weight: offensive terms = 2x, dog whistles = 1x
            const weightedMatches = (offensiveCount * 2) + dogWhistleCount;
            console.log(weightedMatches + " weighted matches of " + matches.length);
            const avgWeight = weightedMatches / matches.length;
            console.log("avgWeight is " + avgWeight);

            // Map avg weight (1.0 to 1.5) to score (0 to 30)
            const typeWeight = ((avgWeight - 1.0) / 0.5) * 30;

            // 3. Category Diversity (10%) - Multiple categories = more problematic
            const uniqueCategories = new Set(matches.map(m => m.category.toLowerCase())).size;
            let categoryScore = 0;
            if (uniqueCategories >= 5) {
                categoryScore = 30;
            } else if (uniqueCategories >= 3) {
                categoryScore = 22.5;
            } else if (uniqueCategories >= 2) {
                categoryScore = 15;
            } else {
                categoryScore = 7.5; // Even 1 category gets some points
            }

            // Calculate final score
            const totalScore = Math.round(densityScore + typeWeight + categoryScore);

            return {
                total: Math.min(totalScore, 100), // Cap at 100%
                breakdown: {
                    densityScore: Math.round(densityScore),
                    typeWeight: Math.round(typeWeight),
                    categoryScore: Math.round(categoryScore),
                    densityPercent: 20,
                    typePercent: 50,
                    categoryPercent: 30,
                    matchCount: matches.length,
                    wordCount: wordCount,
                    offensiveCount: offensiveCount,
                    dogWhistleCount: dogWhistleCount,
                    uniqueCategories: uniqueCategories
                }
            };
        }

        function updateScoreBreakdownTooltip(breakdown) {
            const tooltip = document.querySelector('.info-icon .tooltip');
            if (!tooltip) return;

            const total = breakdown.densityScore + breakdown.typeWeight + breakdown.categoryScore;

            tooltip.innerHTML = `
                <div class="tooltip-item">
                    <div class="tooltip-item-label">Signal Score Breakdown</div>
                </div>
                <div class="tooltip-item">
                    <div class="tooltip-item-label">Match Density (${breakdown.densityPercent}%)</div>
                    <div class="tooltip-item-value">${breakdown.densityScore} points</div>
                    <div class="tooltip-item-value" style="font-size: 0.9em; opacity: 0.8;">${breakdown.matchCount} matches / ${breakdown.wordCount} words</div>
                </div>
                <div class="tooltip-item">
                    <div class="tooltip-item-label">Match Type Weight (${breakdown.typePercent}%)</div>
                    <div class="tooltip-item-value">${breakdown.typeWeight} points</div>
                    <div class="tooltip-item-value" style="font-size: 0.9em; opacity: 0.8;">${breakdown.offensiveCount} offensive, ${breakdown.dogWhistleCount} dog whistles</div>
                </div>
                <div class="tooltip-item">
                    <div class="tooltip-item-label">Category Diversity (${breakdown.categoryPercent}%)</div>
                    <div class="tooltip-item-value">${breakdown.categoryScore} points</div>
                    <div class="tooltip-item-value" style="font-size: 0.9em; opacity: 0.8;">${breakdown.uniqueCategories} unique categories</div>
                </div>
                <div class="tooltip-source" style="text-align: center;">
                    <strong>Total: ${total} points</strong>
                </div>
            `;
        }

        function analyzeText() {
            const textInput = document.getElementById('textInput');

            // Always get text from textarea (it's editable)
            const text = textInput.value.trim();

            if (!text) {
                alert('Please enter some text to analyze.');
                return;
            }

            if (!matcher && !offensiveTermMatcher) {
                alert('Databases not loaded. Please refresh the page.');
                return;
            }

            // Store original text for potential editing
            originalAnalyzedText = text;

            // Show loading state
            document.getElementById('loading').classList.add('visible');
            document.getElementById('analyzeBtn').disabled = true;

            // Use setTimeout to allow UI to update
            setTimeout(() => {
                // Analyze with both matchers
                const dogWhistleResults = matcher ? matcher.analyze(text) : { matches: [], categoryCount: 0, categories: [] };
                const offensiveTermResults = offensiveTermMatcher ? offensiveTermMatcher.analyze(text) : { matches: [], categoryCount: 0, categories: [] };

                // Analyze for populist patterns
                const patternResults = PatternMatcher.place_demonym_lookup_loaded ? PatternMatcher.analyze(text) : { matches: [] };

                // Combine results (pattern matches are also dog whistles)
                const allMatches = [
                    ...dogWhistleResults.matches,
                    ...offensiveTermResults.matches,
                    ...patternResults.matches
                ];

                // Deduplicate overlapping matches from different matchers (keep longest)
                allMatches.sort((a, b) => {
                    if (b.end - b.start !== a.end - a.start) {
                        return (b.end - b.start) - (a.end - a.start); // Sort by length (longest first)
                    }
                    return a.start - b.start; // If same length, sort by position
                });

                const combinedMatches = [];
                const usedRanges = [];

                for (const match of allMatches) {
                    const hasOverlap = usedRanges.some(range =>
                        match.start < range.end && match.end > range.start
                    );
                    if (!hasOverlap) {
                        combinedMatches.push(match);
                        usedRanges.push({ start: match.start, end: match.end });
                    }
                }

                // Sort by position for display
                combinedMatches.sort((a, b) => a.start - b.start);

                // Count all unique categories
                const allCategories = new Set([
                    ...dogWhistleResults.categories,
                    ...offensiveTermResults.categories,
                    ...patternResults.matches.map(m => m.category)
                ]);

                const combinedResults = {
                    matches: combinedMatches,
                    dogWhistleCount: dogWhistleResults.matches.length + patternResults.matches.length,
                    offensiveTermCount: offensiveTermResults.matches.length,
                    categoryCount: allCategories.size,
                    categories: Array.from(allCategories)
                };

                displayResults(text, combinedResults);

                // Hide loading state
                document.getElementById('loading').classList.remove('visible');

                // Track analytics (TODO: implement)
                trackAnalysis(text, combinedResults);
            }, 100);
        }

        function displayResults(originalText, results) {
            const textInput = document.getElementById('textInput');
            const textDisplay = document.getElementById('textDisplay');
            const analyzeBtn = document.getElementById('analyzeBtn');
            const clearBtn = document.getElementById('clearBtn');
            const resultsDiv = document.getElementById('results');
            const termCount = document.getElementById('termCount');
            const categoryCount = document.getElementById('categoryCount');
            const inputLabel = document.getElementById('inputLabel');

            // Count for dog whistles and offensive terms
            const dogWhistleMatches = results.matches.filter(m => m.type === 'dogwhistle');
            const offensiveTermMatches = results.matches.filter(m => m.type === 'offensiveTerm');

            // Update total count
            const totalCount = results.matches.length;
            const dogWhistleCount = dogWhistleMatches.length;
            const offensiveTermCount = offensiveTermMatches.length;

            // Update Terms Flagged count
            termCount.textContent = totalCount;

            // Update breakdown - display on separate lines, ordered by count
            const termBreakdown = document.getElementById('termBreakdown');
            if (termBreakdown) {
                const lines = [];

                if (dogWhistleCount > 0) {
                    const dogWhistleText = dogWhistleCount === 1 ? 'dog whistle' : 'dog whistles';
                    lines.push({ count: dogWhistleCount, text: `${dogWhistleCount} ${dogWhistleText}` });
                }

                if (offensiveTermCount > 0) {
                    const offensiveTermText = offensiveTermCount === 1 ? 'offensive term' : 'offensive terms';
                    lines.push({ count: offensiveTermCount, text: `${offensiveTermCount} ${offensiveTermText}` });
                }

                // Sort by count (descending)
                lines.sort((a, b) => b.count - a.count);

                // Join with line breaks
                termBreakdown.innerHTML = lines.map(line => line.text).join('<br>');
            }

            // Count subcategories and group by main category
            const subCategoryCounts = {};
            const mainCategoryCounts = {};

            results.matches.forEach(match => {
                const subcat = match.category.toLowerCase();
                const mainKey = getMainCategory(subcat);

                // Count subcategories
                subCategoryCounts[subcat] = (subCategoryCounts[subcat] || 0) + 1;

                // Count main categories
                if (mainKey) {
                    mainCategoryCounts[mainKey] = (mainCategoryCounts[mainKey] || 0) + 1;
                }
            });

            // Sort main categories by count (descending)
            const sortedMainCategories = Object.entries(mainCategoryCounts)
                .sort((a, b) => b[1] - a[1]);

            // Sort subcategories by count (descending)
            const sortedSubCategories = Object.entries(subCategoryCounts)
                .sort((a, b) => b[1] - a[1]);

            // Update main category count and display
            document.getElementById('mainCategoryCount').textContent = sortedMainCategories.length;
            const mainCategoryList = document.getElementById('mainCategoryList');
            let mainCategoryHtml = '';
            sortedMainCategories.forEach(([mainKey, count]) => {
                const mainCat = CATEGORY_HIERARCHY[mainKey];
                if (mainCat) {
                    mainCategoryHtml += `<span class="category-badge" style="background-color: ${mainCat.darkColor}">${mainCat.label} (${count})</span>`;
                }
            });
            mainCategoryList.innerHTML = mainCategoryHtml;

            // Update subcategory count and display
            document.getElementById('subCategoryCount').textContent = sortedSubCategories.length;
            const subCategoryList = document.getElementById('subCategoryList');
            let subCategoryHtml = '';
            sortedSubCategories.forEach(([subcat, count]) => {
                const color = getCategoryColor(subcat);
                const info = getSubcategoryInfo(subcat);
                const label = info ? info.label : subcat;
                subCategoryHtml += `<span class="category-badge" style="background-color: ${color}">${label} (${count})</span>`;
            });
            subCategoryList.innerHTML = subCategoryHtml;

            // Calculate Signal Score
            const scoreResult = calculateSignalScore(originalText, results.matches);
            const signalScore = scoreResult.total;
            document.getElementById('signalScore').textContent = `${signalScore}%`;

            // Update signal indicator
            const signalIndicator = document.getElementById('signalIndicator');
            let indicatorClass = '';
            let indicatorText = '';

            if (signalScore === 0) {
                indicatorClass = 'signal-low';
                indicatorText = 'Clean';
            } else if (signalScore <= 25) {
                indicatorClass = 'signal-low';
                indicatorText = 'Low';
            } else if (signalScore <= 50) {
                indicatorClass = 'signal-moderate';
                indicatorText = 'Moderate';
            } else if (signalScore <= 75) {
                indicatorClass = 'signal-high';
                indicatorText = 'High';
            } else {
                indicatorClass = 'signal-severe';
                indicatorText = 'Severe';
            }

            signalIndicator.innerHTML = `<span class="signal-indicator ${indicatorClass}">${indicatorText}</span><span class="highlight info-icon">‚ìò<span class="tooltip"></span></span>`;

            // Update score breakdown tooltip
            updateScoreBreakdownTooltip(scoreResult.breakdown);

            // Build highlighted text
            let displayHtml = '';
            if (results.matches.length === 0) {
                displayHtml = '<div class="no-results">‚úì No dog whistles or offensive terms detected in this text.</div>' +
                    '<div style="margin-top: 15px;">' + escapeHtml(originalText) + '</div>';
            } else {
                let lastIndex = 0;

                results.matches.forEach(match => {
                    // Add text before match
                    displayHtml += escapeHtml(originalText.substring(lastIndex, match.start));

                    // Add highlighted match with tooltip
                    displayHtml += createHighlightedSpan(match);

                    lastIndex = match.end;
                });

                // Add remaining text
                displayHtml += escapeHtml(originalText.substring(lastIndex));
            }

            textDisplay.innerHTML = displayHtml;

            // Switch UI: hide textarea, show display div
            textInput.classList.add('hidden');
            textDisplay.classList.add('visible');
            analyzeBtn.classList.add('hidden');
            document.getElementById('editBtn').classList.remove('hidden');
            clearBtn.classList.remove('hidden');
            document.getElementById('copyBtn').classList.remove('hidden');
            inputLabel.textContent = 'Analysis Results:';

            // Show stats
            resultsDiv.classList.remove('hidden');

            // Setup smart tooltip positioning
            setupTooltips();
        }

        function createHighlightedSpan(match) {
            const typeClass = match.type || 'dogwhistle';
            const categoryClass = getCategoryClass(match.category);
            const categoryColor = getCategoryColor(match.category);
            const formattedCategoryLabel = getFormattedCategoryLabel(match.category);
            const capitalizedDefinition = capitalizeFirst(match.definition);

            // Check if there are actual variations (not empty and not just the root)
            const hasVariations = match.variations && match.variations.length > 0;
            const variationsHtml = hasVariations
                ? `<div class="tooltip-item"><div class="tooltip-item-label">Variations:</div><div class="tooltip-item-value tooltip-variations">${escapeHtml(match.variations.join(', '))}</div></div>`
                : '';

            // Show "Derived from:" for pattern matches, "Term:" for direct matches
            const termLabel = match.isDerived ? 'Derivation' : 'Term';

            if (match.type === 'offensiveTerm') {
                // Harmful term
                const underlineStyle = `border-bottom: 3px solid ${categoryColor}; text-decoration: none;`;
                const sourceHtml = getTooltipSourceHtml(match.source);
                return `<span class="highlight offensiveTerm" style="${underlineStyle}">${escapeHtml(match.text)}<span class="tooltip"><div class="tooltip-category" style="background-color: ${categoryColor}">${escapeHtml(formattedCategoryLabel)}</div><div class="tooltip-item"><div class="tooltip-item-label">Definition:</div><div class="tooltip-item-value">${escapeHtml(capitalizedDefinition)}</div></div>${sourceHtml}</span></span>`;
            } else {
                // Dog whistle
                const sourceHtml = getTooltipSourceHtml(match.source);
                return `<span class="highlight ${categoryClass} dogwhistle">${escapeHtml(match.text)}<span class="tooltip"><div class="tooltip-category" style="background-color: ${categoryColor}">${escapeHtml(formattedCategoryLabel)}</div><div class="tooltip-item"><div class="tooltip-item-label">${termLabel}:</div><div class="tooltip-item-value">${escapeHtml(match.term)}</div></div>${variationsHtml}<div class="tooltip-item"><div class="tooltip-item-label">Dog Whistle:</div><div class="tooltip-item-value">${escapeHtml(capitalizedDefinition)}</div></div>${sourceHtml}</span></span>`;
            }
        }

        /**
        * Returns a tooltip-source string for a given source ID.
        *  Preserves the exact HTML structure you already have.
        */
        function getTooltipSourceHtml(sourceId) {
            if (!sourceId) {
                console.warn("Source id not present in data: " + sourceId);
                return `<div class="tooltip-source">Source: ERROR</div>`;
            }

            const sourceEntry = SOURCE_DATA.sources.find(s => s.id === sourceId);
            if (!sourceEntry) {
                console.warn(`Source id "${sourceId}" not found in SOURCE_DATA: ` + sourceId);
                return `<div class="tooltip-source">Source: ERROR</div>`;
            }

            const displayString = escapeHtml(sourceEntry.string || sourceId);

            if (sourceEntry.url) {
                return `<div class="tooltip-source">Source: <a href="${sourceEntry.url}" target="_blank" rel="noopener">${displayString} ‚Üó</a></div>`;
            } else {
                return `<div class="tooltip-source">Source: ${displayString}</div>`;
            }
        }


        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function capitalizeFirst(text) {
            if (!text || text.length === 0) return text;
            return text.charAt(0).toUpperCase() + text.slice(1);
        }

        function setupTooltips() {
            const highlights = document.querySelectorAll('.highlight');

            highlights.forEach(highlight => {
                const tooltip = highlight.querySelector('.tooltip');
                if (!tooltip) return;

                // Position tooltip on mouseenter
                highlight.addEventListener('mouseenter', function (e) {
                    positionTooltip(highlight, tooltip);
                });
            });
        }

        function positionTooltip(highlight, tooltip) {
            // Get highlight position
            const highlightRect = highlight.getBoundingClientRect();
            const tooltipWidth = 320; // Match CSS width
            const tooltipHeight = tooltip.offsetHeight || 150; // Estimate if not rendered
            const margin = 10;
            const arrowHeight = 8;

            // Viewport dimensions
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            // Calculate initial centered position
            let left = highlightRect.left + (highlightRect.width / 2) - (tooltipWidth / 2);
            let top = highlightRect.top - tooltipHeight - arrowHeight - margin;

            // Reset classes
            tooltip.classList.remove('top', 'bottom', 'align-left', 'align-right');

            // Check if tooltip fits above
            if (top < margin) {
                // Place below instead
                top = highlightRect.bottom + arrowHeight + margin;
                tooltip.classList.add('bottom');
            } else {
                tooltip.classList.add('top');
            }

            // Check horizontal overflow
            if (left < margin) {
                // Align to left edge
                left = margin;
                tooltip.classList.add('align-left');
            } else if (left + tooltipWidth > viewportWidth - margin) {
                // Align to right edge
                left = viewportWidth - tooltipWidth - margin;
                tooltip.classList.add('align-right');
            }

            // Apply position
            tooltip.style.left = `${left}px`;
            tooltip.style.top = `${top}px`;
        }

        function clearAll() {
            const textInput = document.getElementById('textInput');
            const textDisplay = document.getElementById('textDisplay');
            const analyzeBtn = document.getElementById('analyzeBtn');
            const editBtn = document.getElementById('editBtn');
            const clearBtn = document.getElementById('clearBtn');
            const copyBtn = document.getElementById('copyBtn');
            const resultsDiv = document.getElementById('results');
            const inputLabel = document.getElementById('inputLabel');

            // Clear text
            textInput.value = '';
            textDisplay.innerHTML = '';
            originalAnalyzedText = ''; // Reset stored text

            // Switch UI back: show textarea, hide display div
            textInput.classList.remove('hidden');
            textDisplay.classList.remove('visible');
            analyzeBtn.classList.remove('hidden');
            analyzeBtn.disabled = true;
            clearBtn.disabled = true;
            copyBtn.disabled = true;
            editBtn.classList.add('hidden');
            inputLabel.textContent = 'Paste text to analyze:';

            // Hide stats
            resultsDiv.classList.add('hidden');
        }

        function copyText() {
            // Always copy from the textarea (which contains current editable text)
            const textToCopy = document.getElementById('textInput').value;
            if (!textToCopy.trim()) {
                return; // Nothing to copy
            }
            // Use the Clipboard API
            navigator.clipboard.writeText(textToCopy).then(() => {
                // visual feedback
                const copyBtn = document.getElementById('copyBtn');
                // Temporarily override background with disabled color
                copyBtn.style.background = 'var(--btn-clicked-bg)';
                setTimeout(() => {
                    copyBtn.style.background = '';
                }, buttonClickTimeout);

            }).catch(err => {
                console.error('Failed to copy text:', err);
                alert('Failed to copy text to clipboard');
            });
        }

        function trackAnalysis(text, results) {
            // TODO: Implement analytics tracking
            // Track metrics:
            // 1. Total analyses performed
            // 2. Detection rate
            // 3. Average text length
            // 4. Terms detected distribution
            // 5. Return user rate (localStorage)
            // 6. Country-level data (IP geolocation)
            // 7. Time-based patterns

            // console.log('Analytics placeholder:', {
            //     textLength: text.length,
            //     matchCount: results.matches.length,
            //     categories: results.categories
            // });
        }

        // Allow Enter key to submit (with Ctrl/Cmd)
        document.getElementById('textInput').addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                analyzeText();
            }
        });

        // Enable/disable buttons based on text content
        document.getElementById('textInput').addEventListener('input', (e) => {
            const analyzeBtn = document.getElementById('analyzeBtn');
            const copyBtn = document.getElementById('copyBtn');
            const clearBtn = document.getElementById('clearBtn');
            const textInput = document.getElementById('textInput');

            if (textInput.value.trim()) {
                analyzeBtn.disabled = false;
                copyBtn.disabled = false;
                clearBtn.disabled = false;
            } else {
                analyzeBtn.disabled = true;
                copyBtn.disabled = true;
                clearBtn.disabled = true;
            }
        });

        // Reposition tooltips on window resize or scroll
        let tooltipRepositionTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(tooltipRepositionTimeout);
            tooltipRepositionTimeout = setTimeout(() => {
                // Reposition any visible tooltips
                document.querySelectorAll('.highlight:hover').forEach(highlight => {
                    const tooltip = highlight.querySelector('.tooltip');
                    if (tooltip) {
                        positionTooltip(highlight, tooltip);
                    }
                });
            }, 100);
        });

        window.addEventListener('scroll', () => {
            // Reposition tooltips on scroll (since they use fixed positioning)
            document.querySelectorAll('.highlight:hover').forEach(highlight => {
                const tooltip = highlight.querySelector('.tooltip');
                if (tooltip) {
                    positionTooltip(highlight, tooltip);
                }
            });
        }, { passive: true });
    </script>
</body>

</html>