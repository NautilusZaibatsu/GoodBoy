<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GoodBoy - Coded & Offensive Language Detection</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background-image: url('images/page_background.png');
            background-repeat: repeat;
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        h1 {
            font-size: 3em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
        }

        .tagline {
            font-size: 1.2em;
            opacity: 0.95;
        }

        .card {
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            margin-bottom: 20px;
        }

        .input-section {
            margin-bottom: 20px;
        }

        label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            color: #555;
        }

        #textInput {
            width: 100%;
            min-height: 200px;
            padding: 15px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 16px;
            font-family: inherit;
            resize: vertical;
            transition: border-color 0.3s;
            display: block;
        }

        #textInput:focus {
            outline: none;
            border-color: #667eea;
        }

        #textInput.hidden {
            display: none;
        }

        #textDisplay {
            display: none;
            width: 100%;
            min-height: 200px;
            padding: 15px;
            border: 2px solid #667eea;
            border-radius: 8px;
            font-size: 16px;
            font-family: inherit;
            background: #f8f9fa;
            line-height: 1.8;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        #textDisplay.visible {
            display: block;
        }

        .button-row {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        button {
            background: linear-gradient(135deg, #f59369ff 0%, #dd7d34ff 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .clear-btn {
            background: #6c757d;
        }

        .hidden {
            display: none !important;
        }

        #results {
            margin-top: 20px;
        }

        .stats-row {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .stat-box {
            flex: 1;
            min-width: 150px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            text-align: center;
        }

        .stat-value {
            font-size: 2em;
            font-weight: 700;
            color: #667eea;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 0.9em;
            color: #666;
        }

        .signal-indicator {
            display: inline-block;
            margin-top: 5px;
            padding: 3px 10px;
            border-radius: 12px;
            font-size: 0.75em;
            font-weight: 600;
            text-transform: uppercase;
        }

        .signal-low {
            background-color: #d4edda;
            color: #155724;
        }

        .signal-moderate {
            background-color: #fff3cd;
            color: #856404;
        }

        .signal-high {
            background-color: #f8d7da;
            color: #721c24;
        }

        .signal-severe {
            background-color: #d6293e;
            color: white;
        }

        .signal-placeholder {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
        }

        .no-results {
            padding: 15px;
            background: #d4edda;
            border-left: 4px solid #28a745;
            border-radius: 4px;
            color: #155724;
            font-weight: 600;
            margin-top: 10px;
        }

        .highlight {
            padding: 2px 0;
            border-radius: 2px;
            cursor: help;
            position: relative;
            transition: background-color 0.2s;
        }

        /* Category-specific highlight colors will be injected dynamically */

        /* Dog whistles: Background color, NO underline */
        .highlight.dogwhistle {
            text-decoration: none;
        }

        /* Offensive terms: ONLY underline, NO background color */
        .highlight.offensiveTerm {
            background-color: transparent !important;
            text-decoration: none;
        }

        .tooltip {
            position: fixed;
            background: #2c3e50;
            color: white;
            padding: 12px;
            border-radius: 8px;
            width: 320px;
            max-width: 90vw;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .highlight:hover .tooltip {
            opacity: 1;
            pointer-events: auto;
        }

        /* Tooltip arrow - default (pointing down from top tooltip) */
        .tooltip::after {
            content: '';
            position: absolute;
            border: 8px solid transparent;
        }

        /* Default: tooltip above, arrow points down */
        .tooltip.top::after {
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border-top-color: #2c3e50;
        }

        /* Tooltip below, arrow points up */
        .tooltip.bottom::after {
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            border-bottom-color: #2c3e50;
        }

        /* Arrow on left when tooltip is aligned right */
        .tooltip.align-left::after {
            left: 20px;
        }

        /* Arrow on right when tooltip is aligned left */
        .tooltip.align-right::after {
            left: auto;
            right: 20px;
            transform: translateX(0);
        }

        .tooltip-category {
            display: block;
            padding: 8px 12px;
            margin: -12px -12px 10px -12px;
            border-radius: 8px 8px 0 0;
            font-size: 0.75em;
            font-weight: 600;
            text-transform: uppercase;
            text-align: center;
            color: white;
        }

        .category-badge {
            display: block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.85em;
            font-weight: 600;
            margin: 3px 0;
            color: white;
        }

        .tooltip-item {
            margin-bottom: 8px;
            font-size: 0.85em;
            line-height: 1.3;
        }

        .tooltip-item:last-child {
            margin-bottom: 0;
        }

        .tooltip-item-label {
            font-weight: 700;
            color: #fff;
            margin-bottom: 2px;
            font-size: 0.9em;
        }

        .tooltip-item-value {
            color: rgba(255, 255, 255, 0.9);
            line-height: 1.4;
        }

        .tooltip-variations {
            color: rgba(255, 255, 255, 0.8);
            font-style: italic;
        }

        .tooltip-source {
            margin-top: 10px;
            padding-top: 8px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 0.8em;
            color: rgba(255, 255, 255, 0.7);
        }

        .tooltip-source a {
            color: #81d4fa;
            text-decoration: none;
        }

        .tooltip-source a:hover {
            text-decoration: underline;
        }

        footer {
            margin-top: 40px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 12px;
            font-size: 0.9em;
            color: #666;
        }

        .footer-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            user-select: none;
            padding: 5px 0;
        }

        .footer-header h3 {
            color: #333;
            margin: 0;
            font-size: 1.1em;
        }

        .footer-toggle {
            font-size: 1.2em;
            transition: transform 0.3s;
        }

        .footer-toggle.expanded {
            transform: rotate(180deg);
        }

        .footer-content {
            display: none;
            margin-top: 15px;
        }

        .footer-content.visible {
            display: block;
        }

        footer a {
            color: #667eea;
            text-decoration: none;
        }

        footer a:hover {
            text-decoration: underline;
        }

        .page-footer {
            margin-top: 30px;
            padding: 20px;
            text-align: center;
            font-size: 0.85em;
            color: #666;
        }

        .page-footer p {
            margin: 10px 0;
        }

        .loading {
            display: none;
            color: #667eea;
            font-weight: 600;
        }

        .loading.visible {
            display: inline;
        }

        @media (max-width: 600px) {
            h1 {
                font-size: 2em;
            }

            .stats-row {
                flex-direction: column;
            }

            .tooltip {
                width: 280px;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <header>
            <h1>üêï GoodBoy</h1>
            <p class="tagline">Coded & Offensive Language Detection Tool</p>
        </header>

        <div class="card">
            <div class="input-section">
                <label for="textInput" id="inputLabel">Text to analyze:</label>
                <textarea id="textInput"
                    placeholder="Enter or paste text here to check for coded and offensive language..."></textarea>
                <div id="textDisplay"></div>
            </div>

            <div class="button-row">
                <button id="analyzeBtn" onclick="analyzeText()">Analyze Text</button>
                <button class="hidden" id="editBtn" onclick="editText()">Edit Text</button>
                <button class="clear-btn hidden" id="clearBtn" onclick="clearAll()">Clear</button>
                <span class="loading" id="loading">Analyzing...</span>
            </div>

            <div id="results" class="hidden">
                <div class="stats-row">
                    <div class="stat-box">
                        <div class="stat-value" id="termCount">0</div>
                        <div class="stat-label">Terms Flagged</div>
                        <div id="termBreakdown" style="margin-top: 8px; font-size: 0.75em; color: #999;"></div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="mainCategoryCount">0</div>
                        <div class="stat-label">Main Categories</div>
                        <div id="mainCategoryList" style="margin-top: 10px; font-size: 0.85em; text-align: left;"></div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="subCategoryCount">0</div>
                        <div class="stat-label">Subcategories</div>
                        <div id="subCategoryList" style="margin-top: 10px; font-size: 0.85em; text-align: left;"></div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="signalScore">0%</div>
                        <div class="stat-label">Signal Score</div>
                        <div id="signalIndicator"></div>
                    </div>
                </div>
            </div>
        </div>

        <footer>
            <div class="footer-header" onclick="toggleAttribution()">
                <h3>Attribution</h3>
                <span class="footer-toggle">‚ñº</span>
            </div>
            <div class="footer-content" id="attributionContent">
                <p>
                    GoodBoy is a free, open-source tool that detects political dog whistles.
                    It uses the <strong>Silent Signals</strong> database.
                </p>

                <h4 style="margin-top: 20px; margin-bottom: 10px; font-size: 1em;">Data Sources</h4>

                <p style="margin-top: 10px;">
                    <strong>Dog Whistle Dataset:</strong> SALT-NLP, "Silent Signals: Disambiguated Dog Whistle Usage
                    Dataset"
                    <br>
                    <a href="https://huggingface.co/datasets/SALT-NLP/silent_signals" target="_blank" rel="noopener">
                        View Dataset ‚Üó
                    </a>
                    |
                    <a href="https://aclanthology.org/2024.acl-long.675/" target="_blank" rel="noopener">
                        Read Paper (ACL 2024) ‚Üó
                    </a>
                </p>

                <p style="margin-top: 15px;">
                    <strong>Offensive Term Dataset:</strong> GoodBoy Offensive Term Dataset (curated)
                    <br>
                    <span style="font-size: 0.9em; color: #666;">A carefully curated collection of offensive terms for educational purposes.</span>
                </p>

                <p style="margin-top: 20px; padding-top: 15px; border-top: 1px solid #e0e0e0; font-size: 0.9em;">
                    All analysis happens locally in your browser. No data is sent to any server.<br>
                    This tool is educational and should be used to promote understanding, not to label individuals.
                </p>

                <p style="margin-top: 15px; font-size: 0.9em; color: #666;">
                    License: CC BY-NC-SA 4.0 (Non-Commercial, Share-Alike)
                </p>

                <p style="margin-top: 15px; font-size: 0.95em; color: #333;">
                    Database: <strong><span id="dbTermCount">Loading...</span></strong>
                </p>
            </div>
        </footer>

        <!-- Page footer - always visible -->
        <div class="page-footer">
            <p style="color: #ffffff;">
                Created by the GoodBoy Team
            </p>
        </div>
    </div>

    <!-- Load the dog whistle database -->
    <script src="data/dogwhistle_data.js"></script>

    <!-- Load the offensive term database -->
    <script src="data/offensive_term_data.js"></script>

    <!-- Load the gazetteer for populist pattern matching -->
    <script src="data/gazetteer.js"></script>

    <!-- Load shared obfuscation utilities (DRY - single source of truth) -->
    <script src="js/obfuscation-utils.js"></script>

    <!-- Main application logic -->
    <script>
        // Initialize the pattern matchers
        let matcher = null;
        let offensiveTermMatcher = null;

        // Store original text for re-analysis
        let originalAnalyzedText = '';

        // Theme configuration for UI colors (not category colors)
        const THEME_CONFIG = {
            primary: '#667eea',
            primaryDark: '#764ba2',
            secondary: '#6c757d',
            background: '#f8f9fa',
            border: '#e0e0e0',
            text: '#333',
            textLight: '#555',
            textMuted: '#666',
            textWhite: '#ffffff',
            success: '#d4edda',
            successText: '#155724',
            successBorder: '#28a745',
            warning: '#fff3cd',
            warningText: '#856404',
            warningBorder: '#ffc107',
            danger: '#f8d7da',
            dangerText: '#721c24',
            dangerSevere: '#d6293e',
            tooltipBg: '#2c3e50',
            tooltipLink: '#81d4fa'
        };

        /**
         * POPULIST PATTERN MATCHING SYSTEM
         *
         * Detects nationalist and localist language patterns by recognizing place/group names
         * and checking if similar patterns exist in the dog whistle database with different places.
         *
         * Example: If database contains "America First", it will also flag "Britain First",
         * "Make Liverpool Great Again" (from "MAGA"), "hard-working Indians" (from "hard-working Americans")
         *
         * Categorization:
         * - Countries/substateNations ‚Üí Nationalist
         * - Regions/cities ‚Üí Localist
         * - Groups (demonyms) without places ‚Üí Racist
         * - Both place and group ‚Üí Racist
         */

        // Morphological generator: converts places to group names (demonyms)
        const MorphologyUtils = {
            // Common suffix transformations
            suffixRules: [
                { pattern: /a$/, demonym: 'an', plural: 'ans' },           // America ‚Üí American(s)
                { pattern: /ia$/, demonym: 'ian', plural: 'ians' },        // India ‚Üí Indian(s)
                { pattern: /land$/, demonym: 'lander', plural: 'landers' }, // England ‚Üí Englander(s)
                { pattern: /y$/, demonym: 'ian', plural: 'ians' },         // Germany ‚Üí German(s) (needs 'y' removal)
                { pattern: /$/, demonym: 'ese', plural: 'ese' },           // China ‚Üí Chinese (default fallback)
                { pattern: /$/, demonym: 'i', plural: 'is' },              // Iraq ‚Üí Iraqi(s)
                { pattern: /$/, demonym: 'ish', plural: 'ish' },           // Britain ‚Üí British
            ],

            // Generate demonym variants for a place name
            generateDemonyms(placeName) {
                const variants = new Set();
                const lower = placeName.toLowerCase();

                // Add the place name itself
                variants.add(placeName);
                variants.add(lower);

                // Try suffix rules
                // Simple American pattern
                if (lower.endsWith('a')) {
                    const base = lower.slice(0, -1);
                    variants.add(base + 'an');
                    variants.add(base + 'ans');
                }

                // Simple -ian pattern
                variants.add(lower + 'ian');
                variants.add(lower + 'ians');

                // Simple -ish pattern
                variants.add(lower + 'ish');

                // Simple -ese pattern
                variants.add(lower + 'ese');

                // Simple -i pattern
                variants.add(lower + 'i');
                variants.add(lower + 'is');

                return Array.from(variants);
            }
        };

        // Pattern extractor and matcher for populist language
        const PatternMatcher = {
            patterns: [],
            gazetteerLoaded: false,

            // Initialize by extracting patterns from dog whistles
            initialize(dogWhistles, gazetteer) {
                if (!gazetteer) {
                    console.warn('Gazetteer not loaded yet, pattern matching disabled');
                    return;
                }

                this.gazetteerLoaded = true;
                this.allPlaces = [
                    ...gazetteer.countries,
                    ...gazetteer.substateNations,
                    ...gazetteer.regions,
                    ...gazetteer.cities
                ];

                // Build place ‚Üí type mapping
                this.placeTypes = {};
                gazetteer.countries.forEach(p => this.placeTypes[p.toLowerCase()] = 'country');
                gazetteer.substateNations.forEach(p => this.placeTypes[p.toLowerCase()] = 'substateNation');
                gazetteer.regions.forEach(p => this.placeTypes[p.toLowerCase()] = 'region');
                gazetteer.cities.forEach(p => this.placeTypes[p.toLowerCase()] = 'city');

                // Extract patterns from dog whistles
                this.extractPatterns(dogWhistles);
            },

            // Extract patterns from existing dog whistles
            extractPatterns(dogWhistles) {
                dogWhistles.forEach(dw => {
                    // Check root and all variations
                    const termsToCheck = [dw.root, ...(dw.variations || [])];

                    termsToCheck.forEach(term => {
                        // Find if this term contains a place
                        const placeFound = this.findPlaceInText(term);
                        if (placeFound) {
                            // Create a pattern (use lowercase [place] as placeholder)
                            const patternText = term.toLowerCase().replace(placeFound.place.toLowerCase(), '[place]');

                            // Skip patterns that are JUST a place name with no context
                            // We need words before or after the place for valid pattern matching
                            const parts = patternText.split('[place]');
                            const beforeText = parts[0].trim();
                            const afterText = parts[1] ? parts[1].trim() : '';

                            // Only add pattern if there's actual context (words) around the place
                            if (beforeText.length > 0 || afterText.length > 0) {
                                // Only create patterns for categoryMode='dynamic'
                                // Non-dynamic modes (antisemitic, racist, original, custom) are location-specific
                                if (dw.categoryMode && dw.categoryMode !== 'dynamic') {
                                    return; // Skip this dog whistle - it's specific to one location
                                }

                                const pattern = {
                                    original: term,
                                    place: placeFound.place,
                                    placeType: placeFound.type,
                                    pattern: patternText,
                                    dogWhistle: dw,
                                    // Store manual categorization metadata if present
                                    manualCategory: dw.categoryMode ? dw.category : null,
                                    categoryMode: dw.categoryMode || null,
                                    placesFound: dw.placesFound || null
                                };
                                this.patterns.push(pattern);
                            }
                        }
                    });
                });

                console.log(`Extracted ${this.patterns.length} populist patterns`);
            },

            // Find place names in text
            findPlaceInText(text) {
                const lowerText = text.toLowerCase();

                for (const place of this.allPlaces) {
                    const lowerPlace = place.toLowerCase();
                    // Check for word boundary matches
                    const regex = new RegExp(`\\b${lowerPlace}\\b`, 'i');
                    if (regex.test(text)) {
                        return {
                            place: place,
                            type: this.placeTypes[lowerPlace]
                        };
                    }

                    // Also check demonyms
                    const demonyms = MorphologyUtils.generateDemonyms(place);
                    for (const demonym of demonyms) {
                        const demonymRegex = new RegExp(`\\b${demonym}\\b`, 'i');
                        if (demonymRegex.test(lowerText)) {
                            return {
                                place: place,
                                type: this.placeTypes[lowerPlace],
                                isGroup: true
                            };
                        }
                    }
                }

                return null;
            },

            // Analyze text for pattern matches
            analyze(text) {
                if (!this.gazetteerLoaded || this.patterns.length === 0) {
                    console.log('Pattern matching skipped:', !this.gazetteerLoaded ? 'gazetteer not loaded' : 'no patterns');
                    return { matches: [] };
                }

                const matches = [];
                const matchedPositions = new Set(); // Track positions to avoid duplicates
                const lowerText = text.toLowerCase();

                // For each pattern, try to find matches in the text
                this.patterns.forEach(pattern => {
                    // Split pattern by [place] to get before and after parts
                    const parts = pattern.pattern.split('[place]');
                    if (parts.length !== 2) return; // Skip if pattern doesn't have exactly one [place]

                    const beforePart = parts[0].trim();
                    const afterPart = parts[1].trim();

                    // For each place in the gazetteer, check if the pattern matches with that place
                    this.allPlaces.forEach(place => {
                        const lowerPlace = place.toLowerCase();

                        // Skip if it's the same place as the original pattern
                        if (lowerPlace === pattern.place.toLowerCase()) {
                            return;
                        }

                        // Build the expected text with this place
                        const expectedText = beforePart + (beforePart ? ' ' : '') + lowerPlace + (afterPart ? ' ' : '') + afterPart;

                        // Search for this exact phrase in the text
                        const index = lowerText.indexOf(expectedText);
                        if (index !== -1) {
                            const posKey = `${index}-${index + expectedText.length}`;

                            // Skip if we've already matched this position
                            if (matchedPositions.has(posKey)) return;
                            matchedPositions.add(posKey);

                            console.log(`‚úì Pattern match found: "${expectedText}" (pattern: ${pattern.pattern})`);

                            const placeInfo = {
                                place: place,
                                type: this.placeTypes[lowerPlace],
                                isGroup: false
                            };

                            const category = this.determineCategoryForMatch(pattern, placeInfo);

                            matches.push({
                                type: 'dogwhistle',
                                text: expectedText,
                                term: pattern.dogWhistle.root,
                                category: category,
                                definition: `${pattern.dogWhistle.definition} (Derivation: "${pattern.original}" ‚Üí "${expectedText}")`,
                                variations: pattern.dogWhistle.variations,
                                isPatternMatch: true,
                                originalPattern: pattern.original,
                                detectedPlace: place,
                                isDerived: true,
                                derivedFrom: pattern.dogWhistle.root,
                                start: index,
                                end: index + expectedText.length
                            });
                        }

                        // Also check demonyms (e.g., "americans" instead of "america")
                        const demonyms = MorphologyUtils.generateDemonyms(place);
                        demonyms.forEach(demonym => {
                            const expectedTextDemonym = beforePart + (beforePart ? ' ' : '') + demonym + (afterPart ? ' ' : '') + afterPart;
                            const indexDemonym = lowerText.indexOf(expectedTextDemonym);

                            if (indexDemonym !== -1) {
                                const posKeyDemonym = `${indexDemonym}-${indexDemonym + expectedTextDemonym.length}`;

                                // Skip if we've already matched this position
                                if (matchedPositions.has(posKeyDemonym)) return;
                                matchedPositions.add(posKeyDemonym);

                                const placeInfoDemonym = {
                                    place: place,
                                    type: this.placeTypes[lowerPlace],
                                    isGroup: true
                                };

                                const categoryDemonym = this.determineCategoryForMatch(pattern, placeInfoDemonym);

                                matches.push({
                                    type: 'dogwhistle',
                                    text: expectedTextDemonym,
                                    term: pattern.dogWhistle.root,
                                    category: categoryDemonym,
                                    definition: `${pattern.dogWhistle.definition} (pattern: "${pattern.original}" ‚Üí "${expectedTextDemonym}")`,
                                    variations: pattern.dogWhistle.variations,
                                    isPatternMatch: true,
                                    originalPattern: pattern.original,
                                    detectedPlace: place,
                                    isDerived: true,
                                    derivedFrom: pattern.dogWhistle.root,
                                    start: indexDemonym,
                                    end: indexDemonym + expectedTextDemonym.length
                                });
                            }
                        });
                    });
                });

                console.log(`Pattern matching complete: ${matches.length} matches found`);
                return { matches };
            },

            // Determine category based on place type and whether it's a group
            determineCategory(placeInfo) {
                if (placeInfo.isGroup) {
                    return 'racist'; // Using group name
                }

                if (placeInfo.type === 'country' || placeInfo.type === 'substateNation') {
                    return 'nationalist';
                } else if (placeInfo.type === 'region' || placeInfo.type === 'city') {
                    return 'localist';
                }

                return 'nationalist'; // Default
            },

            // Determine category for a match, using manual categorization if present
            determineCategoryForMatch(pattern, placeInfo) {
                // If manual categorization exists, use it
                if (pattern.categoryMode) {
                    // For these modes, always use the stored manual category
                    if (pattern.categoryMode === 'original' ||
                        pattern.categoryMode === 'antisemitic' ||
                        pattern.categoryMode === 'racist' ||
                        pattern.categoryMode === 'custom') {
                        return pattern.manualCategory;
                    }

                    // For dynamic mode, use gazetteer-based logic
                    if (pattern.categoryMode === 'dynamic') {
                        return this.determineCategory(placeInfo);
                    }
                }

                // Fall back to original auto-categorization
                return this.determineCategory(placeInfo);
            }
        };

        // ObfuscationUtils is loaded from js/obfuscation-utils.js (DRY principle)
        // Single source of truth for all pattern matching logic

        // Hierarchical category system - Main categories used for highlighting colors
        // Subcategories shown in tooltips and detailed breakdowns
        const CATEGORY_HIERARCHY = {
            race: {
                label: "Race & Ethnicity",
                lightColor: "#ffcdd2",      // Red - for racist content
                hoverColor: "#ef9a9a",
                darkColor: "#e57373",
                sub: {
                    "racist": { label: "Racist", darkColor: "#e57373" },
                    "white supremacist": { label: "White Supremacist", darkColor: "#ef5350" },
                    "anti-latino": { label: "Anti-Latino", darkColor: "#f44336" },
                    "antisemitic": { label: "Antisemitic", darkColor: "#d32f2f" },
                    "anti-asian": { label: "Anti-Asian", darkColor: "#ba1e1e" },
                    "xenophobic": { label: "Xenophobic", darkColor: "#a71e1e" }
                }
            },

            religion: {
                label: "Religion",
                lightColor: "#e1bee7",      // Purple - for religious intolerance
                hoverColor: "#ce93d8",
                darkColor: "#ba68c8",
                sub: {
                    "islamophobic": { label: "Islamophobic", darkColor: "#ab47bc" }
                }
            },

            gender: {
                label: "Gender & Sexuality",
                lightColor: "#f8bbd0",      // Pink - for gender/sexuality based
                hoverColor: "#f48fb1",
                darkColor: "#f06292",
                sub: {
                    "transphobic": { label: "Transphobic", darkColor: "#ec407a" },
                    "homophobic": { label: "Homophobic", darkColor: "#e91e63" },
                    "anti-lgbtq": { label: "Anti-LGBTQ", darkColor: "#d81b60" },
                    "misogynistic": { label: "Misogynistic", darkColor: "#c2185b" },
                    "misandristic": { label: "Misandrinistic", darkColor: "#861643" },
                    "prostitution": { label: "Prostitution", darkColor: "#880e4f" }
                }
            },

            disability: {
                label: "Ableist",
                lightColor: "#b0bec5",      // Blue-grey - for ableist
                hoverColor: "#90a4ae",
                darkColor: "#78909c",
                sub: {
                    "disability-cognitive": { label: "Cognitive Disability", darkColor: "#607d8b" },
                    "disability-physical": { label: "Physical Disability", darkColor: "#507689" }
                }
            },

            ideology: {
                label: "Ideological",
                lightColor: "#bbdefb",      // Blue - for ideological
                hoverColor: "#90caf9",
                darkColor: "#64b5f6",
                sub: {
                    "conservative": { label: "Conservative", darkColor: "#5c6bc0" },
                    "liberal": { label: "Liberal", darkColor: "#3f51b5" },
                    "anti-liberal": { label: "Anti-Liberal", darkColor: "#3949ab" }
                }
            },

            geography: {
                label: "Populist",
                lightColor: "#c5e1a5",      // Green - for populist
                hoverColor: "#aed581",
                darkColor: "#9ccc65",
                sub: {
                    "nationalist": { label: "Nationalist", darkColor: "#8bc34a" },
                    "localist": { label: "Localist", darkColor: "#7cb342" }
                }
            },

            antiIntellectualist: {
                label: "Anti-Intellectualist",
                lightColor: "#ffe0b2",      // Orange - for anti-intellectualist
                hoverColor: "#ffcc80",
                darkColor: "#ffb74d",
                sub: {
                    "anti-gmo": { label: "Anti-GMO", darkColor: "#ffb74d" },
                    "anti-vax": { label: "Anti-Vax", darkColor: "#ffa726" },
                    "climate change denier": { label: "Climate Change Denier", darkColor: "#ff9800" }
                }
            },

            fundamentalist: {
                label: "Fundamentalist",
                lightColor: "#d7ccc8",      // Brown - for fundamentalist
                hoverColor: "#bcaaa4",
                darkColor: "#a1887f",
                sub: {
                    "religious": { label: "Religious", darkColor: "#a1887f" }
                }
            }
        };

        // Build reverse mapping: subcategory -> main category
        const SUBCATEGORY_TO_MAIN = {};
        Object.keys(CATEGORY_HIERARCHY).forEach(mainKey => {
            const mainCat = CATEGORY_HIERARCHY[mainKey];
            Object.keys(mainCat.sub).forEach(subKey => {
                SUBCATEGORY_TO_MAIN[subKey] = mainKey;
            });
        });

        // Helper to get main category for a subcategory
        function getMainCategory(subcategory) {
            return SUBCATEGORY_TO_MAIN[subcategory?.toLowerCase()] || null;
        }


        // Default colors for unknown categories
        const DEFAULT_COLORS = {
            lightColor: '#ffeb3b',
            hoverColor: '#fdd835',
            darkColor: '#fbc02d'
        };

        // Inject dynamic CSS for MAIN category colors (used for highlighting)
        function injectCategoryStyles() {
            const styleEl = document.createElement('style');
            let css = '';

            // Generate CSS for each MAIN category
            Object.keys(CATEGORY_HIERARCHY).forEach(mainKey => {
                const mainCat = CATEGORY_HIERARCHY[mainKey];
                const className = mainKey.toLowerCase().replace(/\s+/g, '-');

                css += `
                    .highlight.${className} {
                        background-color: ${mainCat.lightColor};
                    }
                    .highlight.${className}:hover {
                        background-color: ${mainCat.hoverColor};
                    }
                `;
            });

            // Add default "other" category
            css += `
                .highlight.other {
                    background-color: ${DEFAULT_COLORS.lightColor};
                }
                .highlight.other:hover {
                    background-color: ${DEFAULT_COLORS.hoverColor};
                }
            `;

            styleEl.textContent = css;
            document.head.appendChild(styleEl);
        }

        // Get the subcategory label and color
        function getSubcategoryInfo(subcategory) {
            const mainKey = getMainCategory(subcategory);
            if (!mainKey) return null;

            const mainCat = CATEGORY_HIERARCHY[mainKey];
            const subInfo = mainCat.sub[subcategory.toLowerCase()];

            return subInfo ? {
                label: subInfo.label,
                darkColor: subInfo.darkColor,
                mainLabel: mainCat.label,
                mainKey: mainKey
            } : null;
        }

        // Get the color for a category (returns subcategory color for tooltips)
        function getCategoryColor(subcategory) {
            const info = getSubcategoryInfo(subcategory);
            return info ? info.darkColor : DEFAULT_COLORS.darkColor;
        }

        // Get the CSS class for highlighting (uses MAIN category)
        function getCategoryClass(subcategory) {
            const mainKey = getMainCategory(subcategory);
            if (!mainKey) return 'other';
            return mainKey.toLowerCase().replace(/\s+/g, '-');
        }

        // Get formatted label for tooltip: "Main : Sub"
        function getFormattedCategoryLabel(subcategory) {
            const info = getSubcategoryInfo(subcategory);
            if (!info) return subcategory;
            return `${info.mainLabel} : ${info.label}`;
        }

        /**
         * Filter redundant variations from database terms
         * Uses ObfuscationUtils to detect and remove variations that our pattern matcher
         * will catch anyway (punctuation, case, hyphenation, plurals, etc.)
         *
         * This maintains DRY by using the SAME logic that our pattern matcher uses,
         * rather than duplicating it in Python.
         */
        function filterRedundantVariations(terms) {
            let totalRemoved = 0;

            const filtered = terms.map(term => {
                const root = term.root;
                const variations = term.variations || [];
                const originalCount = variations.length;

                // Track unique normalized forms to detect duplicates
                const seenNormalized = new Set();

                // Normalize and track root
                const rootNorm = ObfuscationUtils.normalizeText(root);
                const rootClean = rootNorm.replace(/[\s\-_]/g, '');
                seenNormalized.add(rootClean);

                // Filter variations
                const kept = variations.filter(variation => {
                    // Skip exact duplicates of root (case-insensitive)
                    if (variation.toLowerCase() === root.toLowerCase()) {
                        return false;
                    }

                    // Skip if it's a punctuation/case/hyphenation variant of root
                    if (ObfuscationUtils.isPunctuationVariant(variation, root)) {
                        return false;
                    }

                    // Check for duplicate normalized forms
                    const varNorm = ObfuscationUtils.normalizeText(variation);
                    const varClean = varNorm.replace(/[\s\-_]/g, '');

                    if (seenNormalized.has(varClean)) {
                        return false;
                    }

                    // Check if this is a plural of root or another kept variation
                    if (variation.endsWith('s') && variation.length > 1) {
                        const singular = variation.slice(0, -1);
                        const singularClean = ObfuscationUtils.normalizeText(singular).replace(/[\s\-_]/g, '');

                        // Skip if plural of root
                        if (singularClean === rootClean) {
                            return false;
                        }

                        // Skip if plural of a variation we're keeping
                        if (seenNormalized.has(singularClean)) {
                            return false;
                        }
                    }

                    // Keep this variation and track its normalized form
                    seenNormalized.add(varClean);
                    return true;
                });

                totalRemoved += originalCount - kept.length;

                return { ...term, variations: kept };
            });

            if (totalRemoved > 0) {
                console.log(`‚úì Filtered out ${totalRemoved} redundant variations (punctuation, case, plurals, etc.)`);
            }

            return filtered;
        }

        // Load and prepare data on page load
        window.addEventListener('DOMContentLoaded', () => {
            // Inject category-specific CSS styles
            injectCategoryStyles();

            let dogWhistleData = null;
            let offensiveTermData = null;

            // Check dog whistle database
            if (typeof GOODBOY_DATA !== 'undefined') {
                // Filter redundant variations using our pattern matching logic
                const filteredTerms = filterRedundantVariations(GOODBOY_DATA.terms);
                dogWhistleData = {
                    ...GOODBOY_DATA,
                    terms: filteredTerms
                };
                console.log(`‚úì Loaded ${GOODBOY_DATA.uniqueTerms} dog whistles`);
            } else {
                console.error('Failed to load dog whistle database');
            }

            // Check offensive term database
            if (typeof GOODBOY_OFFENSIVE_TERM_DATA !== 'undefined') {
                // Filter redundant variations using our pattern matching logic
                const filteredOffensiveTerms = filterRedundantVariations(GOODBOY_OFFENSIVE_TERM_DATA.terms);
                offensiveTermData = {
                    ...GOODBOY_OFFENSIVE_TERM_DATA,
                    terms: filteredOffensiveTerms
                };
                console.log(`‚úì Loaded ${GOODBOY_OFFENSIVE_TERM_DATA.uniqueTerms} offensive terms`);
            } else {
                console.error('Failed to load offensive term database');
            }

            // Update database term count in footer
            const dbTermCountEl = document.getElementById('dbTermCount');
            if (dbTermCountEl) {
                const dogWhistleCount = dogWhistleData ? dogWhistleData.uniqueTerms : 0;
                const offensiveTermCount = offensiveTermData ? offensiveTermData.uniqueTerms : 0;

                if (dogWhistleCount > 0 && offensiveTermCount > 0) {
                    const offensiveTermText = offensiveTermCount === 1 ? 'offensive term' : 'offensive terms';
                    dbTermCountEl.textContent = `${dogWhistleCount} dog whistles and ${offensiveTermCount} ${offensiveTermText}`;
                } else if (dogWhistleCount > 0) {
                    dbTermCountEl.textContent = `${dogWhistleCount} dog whistles`;
                } else if (offensiveTermCount > 0) {
                    const offensiveTermText = offensiveTermCount === 1 ? 'offensive term' : 'offensive terms';
                    dbTermCountEl.textContent = `${offensiveTermCount} ${offensiveTermText}`;
                } else {
                    dbTermCountEl.textContent = 'Error loading';
                }
            }

            // Initialize matchers with the databases
            if (dogWhistleData) {
                matcher = new DogWhistleMatcher(dogWhistleData);
            } else {
                console.error('Error: Failed to load dog whistle database.');
            }

            if (offensiveTermData) {
                offensiveTermMatcher = new OffensiveTermMatcher(offensiveTermData);
            } else {
                console.error('Error: Failed to load offensive term database.');
            }

            // Initialize pattern matcher for populist detection
            if (dogWhistleData && typeof window.GAZETTEER !== 'undefined') {
                PatternMatcher.initialize(dogWhistleData.terms, window.GAZETTEER);
                console.log('‚úì Pattern matcher initialized for populist detection');
            } else if (!window.GAZETTEER) {
                console.warn('Gazetteer not loaded, populist pattern matching disabled');
            }

            if (!dogWhistleData && !offensiveTermData) {
                alert('Error: Failed to load databases. Please refresh the page.');
            }
        });

        function editText() {
            // User clicked "Edit Text" button - restore editable state
            clearAnalysisHighlights();
        }

        function toggleAttribution() {
            const content = document.getElementById('attributionContent');
            const toggle = document.querySelector('.footer-toggle');

            content.classList.toggle('visible');
            toggle.classList.toggle('expanded');
        }

        function clearAnalysisHighlights() {
            const textInput = document.getElementById('textInput');
            const textDisplay = document.getElementById('textDisplay');
            const analyzeBtn = document.getElementById('analyzeBtn');
            const editBtn = document.getElementById('editBtn');
            const resultsDiv = document.getElementById('results');
            const inputLabel = document.getElementById('inputLabel');

            // Check if analysis is currently displayed
            if (textDisplay.classList.contains('visible') && originalAnalyzedText) {
                // Put original text back into the editable textarea
                textInput.value = originalAnalyzedText;

                // Switch from display div back to editable textarea
                textDisplay.classList.remove('visible');
                textDisplay.innerHTML = '';
                textInput.classList.remove('hidden');

                // Update label
                inputLabel.textContent = 'Paste text to analyze:';

                // Show Analyze button, hide Edit button (keep Clear button visible)
                analyzeBtn.classList.remove('hidden');
                analyzeBtn.disabled = false;
                editBtn.classList.add('hidden');

                // Hide results stats
                resultsDiv.classList.add('hidden');
            }
        }

        class DogWhistleMatcher {
            constructor(dogWhistleData) {
                // Store dog whistle data
                this.dogWhistleData = dogWhistleData;
                this.dogWhistleTerms = dogWhistleData.terms;

                // Build lookup map for dog whistles using DRY helper
                this.variationMap = ObfuscationUtils.buildVariationMap(this.dogWhistleTerms);
            }

            analyze(text) {
                // Normalize Unicode characters to ensure consistent matching
                text = text.normalize('NFC');

                const allMatches = [];

                // Find all dog whistle matches
                this.variationMap.forEach((termData, variation) => {
                    // Create flexible regex pattern that catches obfuscation
                    const flexiblePattern = ObfuscationUtils.createFlexiblePattern(variation);
                    // Add optional 's' at the end to catch plurals
                    const pluralPattern = `${flexiblePattern}s?`;
                    // Use lookahead/lookbehind instead of \b to handle non-word chars like $ and @
                    // This ensures pattern works even when word chars are replaced with symbols
                    const regex = new RegExp(`(?<![a-z0-9])${pluralPattern}(?![a-z0-9])`, 'gi');

                    let match;
                    let lastIndex = -1;
                    while ((match = regex.exec(text)) !== null) {
                        if (match.index === lastIndex && match[0].length === 0) {
                            regex.lastIndex++;
                            continue;
                        }
                        lastIndex = match.index;

                        allMatches.push({
                            start: match.index,
                            end: match.index + match[0].length,
                            length: match[0].length,
                            text: match[0],
                            type: 'dogwhistle',
                            term: termData.root,
                            category: termData.category,
                            definition: termData.definition,
                            variations: termData.variations
                        });
                    }
                });

                // Remove overlapping matches, keeping the longest/most specific ones
                // Sort by: 1) length (descending), 2) position (ascending)
                allMatches.sort((a, b) => {
                    if (b.length !== a.length) return b.length - a.length;
                    return a.start - b.start;
                });

                const matches = [];
                const usedRanges = [];

                // Keep matches that don't overlap with already-selected matches
                for (const match of allMatches) {
                    const hasOverlap = usedRanges.some(range => ObfuscationUtils.overlaps(match, range));
                    if (!hasOverlap) {
                        matches.push(match);
                        usedRanges.push({ start: match.start, end: match.end });
                    }
                }

                // Sort final matches by position for display
                matches.sort((a, b) => a.start - b.start);

                // Count unique categories
                const foundCategories = new Set(matches.map(m => m.category));

                return {
                    matches,
                    categoryCount: foundCategories.size,
                    categories: Array.from(foundCategories)
                };
            }
        }

        class OffensiveTermMatcher {
            constructor(offensiveTermData) {
                // Store offensive term data
                this.offensiveTermData = offensiveTermData;
                this.offensiveTermTerms = offensiveTermData.terms;

                // Build lookup map for offensive terms using DRY helper
                this.variationMap = ObfuscationUtils.buildVariationMap(this.offensiveTermTerms);
            }

            analyze(text) {
                // Normalize Unicode characters to ensure consistent matching
                text = text.normalize('NFC');

                const allMatches = [];

                // Find all offensive term matches
                this.variationMap.forEach((termData, variation) => {
                    // Create flexible regex pattern that catches obfuscation
                    const flexiblePattern = ObfuscationUtils.createFlexiblePattern(variation);
                    // Add optional 's' at the end to catch plurals
                    const pluralPattern = `${flexiblePattern}s?`;
                    const regex = new RegExp(`(?<![a-z0-9])${pluralPattern}(?![a-z0-9])`, 'gi');

                    let match;
                    let lastIndex = -1;
                    while ((match = regex.exec(text)) !== null) {
                        if (match.index === lastIndex && match[0].length === 0) {
                            regex.lastIndex++;
                            continue;
                        }
                        lastIndex = match.index;

                        allMatches.push({
                            start: match.index,
                            end: match.index + match[0].length,
                            length: match[0].length,
                            text: match[0],
                            type: 'offensiveTerm',
                            term: termData.root,
                            category: termData.category,
                            definition: termData.definition,
                            variations: termData.variations
                        });
                    }
                });

                // Remove overlapping matches, keeping the longest/most specific ones
                allMatches.sort((a, b) => {
                    if (b.length !== a.length) return b.length - a.length;
                    return a.start - b.start;
                });

                const matches = [];
                const usedRanges = [];

                for (const match of allMatches) {
                    const hasOverlap = usedRanges.some(range => ObfuscationUtils.overlaps(match, range));
                    if (!hasOverlap) {
                        matches.push(match);
                        usedRanges.push({ start: match.start, end: match.end });
                    }
                }

                // Sort final matches by position for display
                matches.sort((a, b) => a.start - b.start);

                // Count unique categories
                const foundCategories = new Set(matches.map(m => m.category));

                return {
                    matches,
                    categoryCount: foundCategories.size,
                    categories: Array.from(foundCategories)
                };
            }
        }

        function calculateSignalScore(text, matches) {
            if (matches.length === 0) return 0;

            // Count words in text
            const wordCount = text.trim().split(/\s+/).length;
            if (wordCount === 0) return 0;

            // 1. Match Density (70%) - Percentage of words that are problematic
            // Higher weight because this is the primary indicator
            const matchDensity = matches.length / wordCount;
            const densityScore = Math.min(matchDensity * 100, 70);

            // 2. Match Type Weight (20%) - Offensive terms weighted higher than dog whistles
            // Offensive terms are explicit, dog whistles are coded
            const offensiveCount = matches.filter(m => m.type === 'offensiveTerm').length;
            const dogWhistleCount = matches.filter(m => m.type === 'dogwhistle').length;

            // Weight: offensive terms = 1.5x, dog whistles = 1.0x
            const weightedMatches = (offensiveCount * 1.5) + dogWhistleCount;
            const avgWeight = weightedMatches / matches.length;

            // Map avg weight (1.0 to 1.5) to score (0 to 20)
            const typeWeight = ((avgWeight - 1.0) / 0.5) * 20;

            // 3. Category Diversity (10%) - Multiple categories = more problematic
            const uniqueCategories = new Set(matches.map(m => m.category.toLowerCase())).size;
            let categoryScore = 0;
            if (uniqueCategories >= 5) {
                categoryScore = 10;
            } else if (uniqueCategories >= 3) {
                categoryScore = 7;
            } else if (uniqueCategories >= 2) {
                categoryScore = 4;
            } else {
                categoryScore = 2; // Even 1 category gets some points
            }

            // Calculate final score
            const totalScore = Math.round(densityScore + typeWeight + categoryScore);
            return Math.min(totalScore, 100); // Cap at 100%
        }

        function analyzeText() {
            const textInput = document.getElementById('textInput');

            // Always get text from textarea (it's editable)
            const text = textInput.value.trim();

            if (!text) {
                alert('Please enter some text to analyze.');
                return;
            }

            if (!matcher && !offensiveTermMatcher) {
                alert('Databases not loaded. Please refresh the page.');
                return;
            }

            // Store original text for potential editing
            originalAnalyzedText = text;

            // Show loading state
            document.getElementById('loading').classList.add('visible');
            document.getElementById('analyzeBtn').disabled = true;

            // Use setTimeout to allow UI to update
            setTimeout(() => {
                // Analyze with both matchers
                const dogWhistleResults = matcher ? matcher.analyze(text) : { matches: [], categoryCount: 0, categories: [] };
                const offensiveTermResults = offensiveTermMatcher ? offensiveTermMatcher.analyze(text) : { matches: [], categoryCount: 0, categories: [] };

                // Analyze for populist patterns
                const patternResults = PatternMatcher.gazetteerLoaded ? PatternMatcher.analyze(text) : { matches: [] };

                // Combine results (pattern matches are also dog whistles)
                const combinedMatches = [
                    ...dogWhistleResults.matches,
                    ...offensiveTermResults.matches,
                    ...patternResults.matches
                ];

                // Sort by position
                combinedMatches.sort((a, b) => a.start - b.start);

                // Count all unique categories
                const allCategories = new Set([
                    ...dogWhistleResults.categories,
                    ...offensiveTermResults.categories,
                    ...patternResults.matches.map(m => m.category)
                ]);

                const combinedResults = {
                    matches: combinedMatches,
                    dogWhistleCount: dogWhistleResults.matches.length + patternResults.matches.length,
                    offensiveTermCount: offensiveTermResults.matches.length,
                    categoryCount: allCategories.size,
                    categories: Array.from(allCategories)
                };

                displayResults(text, combinedResults);

                // Hide loading state
                document.getElementById('loading').classList.remove('visible');

                // Track analytics (TODO: implement)
                trackAnalysis(text, combinedResults);
            }, 100);
        }

        function displayResults(originalText, results) {
            const textInput = document.getElementById('textInput');
            const textDisplay = document.getElementById('textDisplay');
            const analyzeBtn = document.getElementById('analyzeBtn');
            const clearBtn = document.getElementById('clearBtn');
            const resultsDiv = document.getElementById('results');
            const termCount = document.getElementById('termCount');
            const categoryCount = document.getElementById('categoryCount');
            const inputLabel = document.getElementById('inputLabel');

            // Count for dog whistles and offensive terms
            const dogWhistleMatches = results.matches.filter(m => m.type === 'dogwhistle');
            const offensiveTermMatches = results.matches.filter(m => m.type === 'offensiveTerm');

            // Update total count
            const totalCount = results.matches.length;
            const dogWhistleCount = dogWhistleMatches.length;
            const offensiveTermCount = offensiveTermMatches.length;

            // Update Terms Flagged count
            termCount.textContent = totalCount;

            // Update breakdown - display on separate lines, ordered by count
            const termBreakdown = document.getElementById('termBreakdown');
            if (termBreakdown) {
                const lines = [];

                if (dogWhistleCount > 0) {
                    const dogWhistleText = dogWhistleCount === 1 ? 'dog whistle' : 'dog whistles';
                    lines.push({ count: dogWhistleCount, text: `${dogWhistleCount} ${dogWhistleText}` });
                }

                if (offensiveTermCount > 0) {
                    const offensiveTermText = offensiveTermCount === 1 ? 'offensive term' : 'offensive terms';
                    lines.push({ count: offensiveTermCount, text: `${offensiveTermCount} ${offensiveTermText}` });
                }

                // Sort by count (descending)
                lines.sort((a, b) => b.count - a.count);

                // Join with line breaks
                termBreakdown.innerHTML = lines.map(line => line.text).join('<br>');
            }

            // Count subcategories and group by main category
            const subCategoryCounts = {};
            const mainCategoryCounts = {};

            results.matches.forEach(match => {
                const subcat = match.category.toLowerCase();
                const mainKey = getMainCategory(subcat);

                // Count subcategories
                subCategoryCounts[subcat] = (subCategoryCounts[subcat] || 0) + 1;

                // Count main categories
                if (mainKey) {
                    mainCategoryCounts[mainKey] = (mainCategoryCounts[mainKey] || 0) + 1;
                }
            });

            // Sort main categories by count (descending)
            const sortedMainCategories = Object.entries(mainCategoryCounts)
                .sort((a, b) => b[1] - a[1]);

            // Sort subcategories by count (descending)
            const sortedSubCategories = Object.entries(subCategoryCounts)
                .sort((a, b) => b[1] - a[1]);

            // Update main category count and display
            document.getElementById('mainCategoryCount').textContent = sortedMainCategories.length;
            const mainCategoryList = document.getElementById('mainCategoryList');
            let mainCategoryHtml = '';
            sortedMainCategories.forEach(([mainKey, count]) => {
                const mainCat = CATEGORY_HIERARCHY[mainKey];
                if (mainCat) {
                    mainCategoryHtml += `<span class="category-badge" style="background-color: ${mainCat.darkColor}">${mainCat.label} (${count})</span>`;
                }
            });
            mainCategoryList.innerHTML = mainCategoryHtml;

            // Update subcategory count and display
            document.getElementById('subCategoryCount').textContent = sortedSubCategories.length;
            const subCategoryList = document.getElementById('subCategoryList');
            let subCategoryHtml = '';
            sortedSubCategories.forEach(([subcat, count]) => {
                const color = getCategoryColor(subcat);
                const info = getSubcategoryInfo(subcat);
                const label = info ? info.label : subcat;
                subCategoryHtml += `<span class="category-badge" style="background-color: ${color}">${label} (${count})</span>`;
            });
            subCategoryList.innerHTML = subCategoryHtml;

            // Calculate Signal Score
            const signalScore = calculateSignalScore(originalText, results.matches);
            document.getElementById('signalScore').textContent = `${signalScore}%`;

            // Update signal indicator
            const signalIndicator = document.getElementById('signalIndicator');
            let indicatorClass = '';
            let indicatorText = '';

            if (signalScore === 0) {
                indicatorClass = 'signal-low';
                indicatorText = 'Clean';
            } else if (signalScore <= 25) {
                indicatorClass = 'signal-low';
                indicatorText = 'Low';
            } else if (signalScore <= 50) {
                indicatorClass = 'signal-moderate';
                indicatorText = 'Moderate';
            } else if (signalScore <= 75) {
                indicatorClass = 'signal-high';
                indicatorText = 'High';
            } else {
                indicatorClass = 'signal-severe';
                indicatorText = 'Severe';
            }

            signalIndicator.innerHTML = `<span class="signal-indicator ${indicatorClass}">${indicatorText}</span>`;

            // Build highlighted text
            let displayHtml = '';
            if (results.matches.length === 0) {
                displayHtml = '<div class="no-results">‚úì No dog whistles or offensive terms detected in this text.</div>' +
                    '<div style="margin-top: 15px;">' + escapeHtml(originalText) + '</div>';
            } else {
                let lastIndex = 0;

                results.matches.forEach(match => {
                    // Add text before match
                    displayHtml += escapeHtml(originalText.substring(lastIndex, match.start));

                    // Add highlighted match with tooltip
                    displayHtml += createHighlightedSpan(match);

                    lastIndex = match.end;
                });

                // Add remaining text
                displayHtml += escapeHtml(originalText.substring(lastIndex));
            }

            textDisplay.innerHTML = displayHtml;

            // Switch UI: hide textarea, show display div
            textInput.classList.add('hidden');
            textDisplay.classList.add('visible');
            analyzeBtn.classList.add('hidden');
            document.getElementById('editBtn').classList.remove('hidden');
            clearBtn.classList.remove('hidden');
            inputLabel.textContent = 'Analysis Results:';

            // Show stats
            resultsDiv.classList.remove('hidden');

            // Setup smart tooltip positioning
            setupTooltips();
        }

        function createHighlightedSpan(match) {
            const typeClass = match.type || 'dogwhistle';
            const categoryClass = getCategoryClass(match.category);
            const categoryColor = getCategoryColor(match.category);
            const formattedCategoryLabel = getFormattedCategoryLabel(match.category);
            const capitalizedDefinition = capitalizeFirst(match.definition);

            // Check if there are actual variations (not empty and not just the root)
            const hasVariations = match.variations && match.variations.length > 0;
            const variationsHtml = hasVariations
                ? `<div class="tooltip-item"><div class="tooltip-item-label">Variations:</div><div class="tooltip-item-value tooltip-variations">${escapeHtml(match.variations.join(', '))}</div></div>`
                : '';

            // Show "Derived from:" for pattern matches, "Term:" for direct matches
            const termLabel = match.isDerived ? 'Derived from' : 'Term';

            if (match.type === 'offensiveTerm') {
                // Offensive term - use underline with color (NO background color via categoryClass)
                // Underline styling with category color (subcategory color for distinction)
                const underlineStyle = `border-bottom: 3px solid ${categoryColor}; text-decoration: none;`;

                // Note: We only use "highlight" and "offensiveTerm" classes, NOT categoryClass
                // This prevents the background color from being applied
                return `<span class="highlight offensiveTerm" style="${underlineStyle}">${escapeHtml(match.text)}<span class="tooltip"><div class="tooltip-category" style="background-color: ${categoryColor}">${escapeHtml(formattedCategoryLabel)}</div><div class="tooltip-item"><div class="tooltip-item-label">${termLabel}:</div><div class="tooltip-item-value">${escapeHtml(match.term)}</div></div>${variationsHtml}<div class="tooltip-item"><div class="tooltip-item-label">Definition:</div><div class="tooltip-item-value">${escapeHtml(capitalizedDefinition)}</div></div><div class="tooltip-source">Source: <a href="#" onclick="return false;">GoodBoy</a></div></span></span>`;
            } else {
                // Dog whistle - use highlight (background color from main category)
                return `<span class="highlight ${categoryClass} dogwhistle">${escapeHtml(match.text)}<span class="tooltip"><div class="tooltip-category" style="background-color: ${categoryColor}">${escapeHtml(formattedCategoryLabel)}</div><div class="tooltip-item"><div class="tooltip-item-label">${termLabel}:</div><div class="tooltip-item-value">${escapeHtml(match.term)}</div></div>${variationsHtml}<div class="tooltip-item"><div class="tooltip-item-label">Dog Whistle:</div><div class="tooltip-item-value">${escapeHtml(capitalizedDefinition)}</div></div><div class="tooltip-source">Source: <a href="https://huggingface.co/datasets/SALT-NLP/silent_signals" target="_blank" rel="noopener">Silent Signals ‚Üó</a></div></span></span>`;
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function capitalizeFirst(text) {
            if (!text || text.length === 0) return text;
            return text.charAt(0).toUpperCase() + text.slice(1);
        }

        function setupTooltips() {
            const highlights = document.querySelectorAll('.highlight');

            highlights.forEach(highlight => {
                const tooltip = highlight.querySelector('.tooltip');
                if (!tooltip) return;

                // Position tooltip on mouseenter
                highlight.addEventListener('mouseenter', function (e) {
                    positionTooltip(highlight, tooltip);
                });
            });
        }

        function positionTooltip(highlight, tooltip) {
            // Get highlight position
            const highlightRect = highlight.getBoundingClientRect();
            const tooltipWidth = 320; // Match CSS width
            const tooltipHeight = tooltip.offsetHeight || 150; // Estimate if not rendered
            const margin = 10;
            const arrowHeight = 8;

            // Viewport dimensions
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            // Calculate initial centered position
            let left = highlightRect.left + (highlightRect.width / 2) - (tooltipWidth / 2);
            let top = highlightRect.top - tooltipHeight - arrowHeight - margin;

            // Reset classes
            tooltip.classList.remove('top', 'bottom', 'align-left', 'align-right');

            // Check if tooltip fits above
            if (top < margin) {
                // Place below instead
                top = highlightRect.bottom + arrowHeight + margin;
                tooltip.classList.add('bottom');
            } else {
                tooltip.classList.add('top');
            }

            // Check horizontal overflow
            if (left < margin) {
                // Align to left edge
                left = margin;
                tooltip.classList.add('align-left');
            } else if (left + tooltipWidth > viewportWidth - margin) {
                // Align to right edge
                left = viewportWidth - tooltipWidth - margin;
                tooltip.classList.add('align-right');
            }

            // Apply position
            tooltip.style.left = `${left}px`;
            tooltip.style.top = `${top}px`;
        }

        function clearAll() {
            const textInput = document.getElementById('textInput');
            const textDisplay = document.getElementById('textDisplay');
            const analyzeBtn = document.getElementById('analyzeBtn');
            const editBtn = document.getElementById('editBtn');
            const clearBtn = document.getElementById('clearBtn');
            const resultsDiv = document.getElementById('results');
            const inputLabel = document.getElementById('inputLabel');

            // Clear text
            textInput.value = '';
            textDisplay.innerHTML = '';
            originalAnalyzedText = ''; // Reset stored text

            // Switch UI back: show textarea, hide display div
            textInput.classList.remove('hidden');
            textDisplay.classList.remove('visible');
            analyzeBtn.classList.remove('hidden');
            analyzeBtn.disabled = false;
            editBtn.classList.add('hidden');
            clearBtn.classList.add('hidden');
            inputLabel.textContent = 'Paste text to analyze:';

            // Hide stats
            resultsDiv.classList.add('hidden');
        }

        function trackAnalysis(text, results) {
            // TODO: Implement analytics tracking
            // Track metrics:
            // 1. Total analyses performed
            // 2. Detection rate
            // 3. Average text length
            // 4. Terms detected distribution
            // 5. Return user rate (localStorage)
            // 6. Country-level data (IP geolocation)
            // 7. Time-based patterns

            // console.log('Analytics placeholder:', {
            //     textLength: text.length,
            //     matchCount: results.matches.length,
            //     categories: results.categories
            // });
        }

        // Allow Enter key to submit (with Ctrl/Cmd)
        document.getElementById('textInput').addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                analyzeText();
            }
        });

        // Reposition tooltips on window resize or scroll
        let tooltipRepositionTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(tooltipRepositionTimeout);
            tooltipRepositionTimeout = setTimeout(() => {
                // Reposition any visible tooltips
                document.querySelectorAll('.highlight:hover').forEach(highlight => {
                    const tooltip = highlight.querySelector('.tooltip');
                    if (tooltip) {
                        positionTooltip(highlight, tooltip);
                    }
                });
            }, 100);
        });

        window.addEventListener('scroll', () => {
            // Reposition tooltips on scroll (since they use fixed positioning)
            document.querySelectorAll('.highlight:hover').forEach(highlight => {
                const tooltip = highlight.querySelector('.tooltip');
                if (tooltip) {
                    positionTooltip(highlight, tooltip);
                }
            });
        }, { passive: true });
    </script>
</body>

</html>