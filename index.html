<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üêï GoodBoy - Sniffing out coded language</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--bg-page);
            background-image: url('images/page_background.png');
            background-repeat: repeat;
            min-height: 100vh;
            padding: var(--spacing-xl);
            color: var(--text-primary);
        }

        a:link {
            color: var(--link-unvisited);
        }

        a:visited {
            color: var(--link-visited);
        }

        a:hover {
            color: var(--link-hover);
        }

        a:active {
            color: var(--link-active);
        }

        p {
            margin-bottom: 1rem;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            color: var(--text-white);
            margin-bottom: var(--spacing-xxl);
        }

        h1 {
            font-size: var(--font-size-xxl);
            margin-bottom: var(--spacing-sm);
            text-shadow: 2px 2px 4px var(--shadow-light);
        }

        .betaText {
            font-size: var(--font-size-sm);
            margin-left: var(--spacing-sm);
            margin-top: 0.5em;
            font-weight: var(--weight-normal);
            display: inline-block;
            vertical-align: top;
        }

        .tagline {
            font-size: var(--font-size-lg);
            opacity: 0.95;
        }

        .card {
            background: var(--bg-card);
            border-radius: var(--radius-xl);
            padding: var(--spacing-xxl);
            box-shadow: 0 10px 40px var(--shadow-light);
        }

        .input-section {
            margin-bottom: var(--spacing-xl);
        }

        label {
            display: block;
            font-weight: var(--font-weight-semibold);
            margin-bottom: var(--spacing-sm);
            color: var(--text-secondary);
        }

        #textInput {
            width: 100%;
            min-height: 200px;
            padding: var(--spacing-lg);
            border: 2px solid var(--border-default);
            border-radius: var(--radius-lg);
            font-size: var(--font-size-md);
            font-family: inherit;
            resize: vertical;
            transition: border-color 0.3s;
            display: block;
        }

        #textInput:focus {
            outline: none;
            border-color: var(--border-focus);
        }

        #textInput.hidden {
            display: none;
        }

        #textDisplay {
            display: none;
            width: 100%;
            min-height: 200px;
            padding: var(--spacing-lg);
            border: 2px solid var(--color-primary);
            border-radius: var(--radius-lg);
            font-size: var(--font-size-md);
            font-family: inherit;
            background: var(--bg-input);
            line-height: 1.8;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        #textDisplay.visible {
            display: block;
        }

        .button-row {
            display: flex;
            gap: var(--spacing-sm);
            align-items: center;
        }

        button {
            background: var(--btn-primary-bg);
            color: var(--btn-primary-text);
            border: none;
            padding: var(--spacing-md) var(--spacing-xxl);
            border-radius: var(--radius-lg);
            font-size: var(--font-size-md);
            font-weight: var(--font-weight-semibold);
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px var(--shadow-medium);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled,
        .copy-btn:disabled,
        .clear-btn:disabled {
            background: var(--btn-disabled-bg) !important;
            color: var(--btn-disabled-text) !important;
            cursor: not-allowed;
            pointer-events: auto;
            opacity: 1;
            transform: none;
            box-shadow: none;
        }

        .clear-btn {
            background: var(--btn-primary-bg);
            color: var(--btn-primary-text);
        }

        .copy-btn {
            background: var(--btn-primary-bg);
            color: var(--btn-primary-text);
        }

        .hidden {
            display: none !important;
        }

        #results {
            margin-top: var(--spacing-xl);
        }

        .stats-row {
            display: flex;
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-xl);
            flex-wrap: wrap;
        }

        .stat-box {
            flex: 1;
            min-width: 150px;
            padding: var(--spacing-md);
            background: var(--bg-input);
            border-radius: var(--radius-lg);
            text-align: center;
        }

        .stat-value {
            font-size: var(--font-size-xl);
            font-weight: var(--font-weight-bold);
            color: var(--color-primary);
            margin-bottom: var(--spacing-xs);
        }

        .stat-label {
            font-size: var(--font-size-sm);
            color: var(--text-muted);
        }

        .signal-indicator {
            display: inline-block;
            margin-top: var(--spacing-xs);
            padding: var(--spacing-xs) var(--spacing-sm);
            border-radius: var(--radius-xl);
            font-size: var(--font-size-xxs);
            font-weight: var(--font-weight-semibold);
            text-transform: uppercase;
        }

        .signal-low {
            background-color: var(--state-success-bg);
            color: var(--state-success-text);
        }

        .signal-moderate {
            background-color: var(--state-warning-bg);
            color: var(--state-warning-text);
        }

        .signal-high {
            background-color: var(--state-danger-bg);
            color: var(--state-danger-text);
        }

        .signal-severe {
            background-color: var(--state-danger-border);
            color: var(--text-white);
        }

        .info-icon {
            display: inline-block;
            margin-left: var(--spacing-sm);
            cursor: help;
            opacity: 0.6;
            font-size: var(--font-size-sm);
        }

        .info-icon:hover {
            opacity: 1;
        }

        .signal-placeholder {
            background: var(--state-warning-bg);
            border-left: 4px solid var(--state-warning-border);
            padding: var(--spacing-lg);
            border-radius: var(--radius-md);
            margin-bottom: var(--spacing-xl);
        }

        .no-results {
            padding: var(--spacing-lg);
            background: var(--state-success-bg);
            border-left: 4px solid var(--state-success-border);
            border-radius: var(--radius-md);
            color: var(--state-success-text);
            font-weight: var(--font-weight-semibold);
            margin-top: var(--spacing-sm);
        }

        .highlight {
            padding: var(--spacing-xs) 0;
            border-radius: var(--radius-sm);
            cursor: help;
            position: relative;
            transition: background-color 0.2s;
        }

        /* Category-specific highlight colors will be injected dynamically */

        /* Dog whistles: Background color, NO underline */
        .highlight.dogwhistle {
            text-decoration: none;
        }

        /* Harmful terms: ONLY underline, NO background color */
        .highlight.harmfulTerm {
            background-color: transparent !important;
            text-decoration: none;
        }

        .tooltip {
            position: fixed;
            background: var(--bg-tooltip);
            color: var(--text-white);
            padding: var(--spacing-md);
            border-radius: var(--radius-lg);
            width: 320px;
            max-width: 90vw;
            box-shadow: 0 5px 20px var(--shadow-light);
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .highlight:hover .tooltip {
            opacity: 1;
            pointer-events: auto;
        }

        /* Tooltip arrow - default (pointing down from top tooltip) */
        .tooltip::after {
            content: '';
            position: absolute;
            border: 8px solid transparent;
        }

        /* Default: tooltip above, arrow points down */
        .tooltip.top::after {
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border-top-color: var(--bg-tooltip);
        }

        /* Tooltip below, arrow points up */
        .tooltip.bottom::after {
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            border-bottom-color: var(--bg-tooltip);
        }

        /* Arrow on left when tooltip is aligned right */
        .tooltip.align-left::after {
            left: 20px;
        }

        /* Arrow on right when tooltip is aligned left */
        .tooltip.align-right::after {
            left: auto;
            right: 20px;
            transform: translateX(0);
        }

        .tooltip-category {
            display: block;
            padding: var(--spacing-sm) var(--spacing-md);
            margin: calc(-1 * var(--spacing-md)) calc(-1 * var(--spacing-md)) var(--spacing-sm) calc(-1 * var(--spacing-md));
            border-radius: var(--radius-lg) var(--radius-lg) 0 0;
            font-size: var(--font-size-xxs);
            font-weight: var(--font-weight-semibold);
            text-transform: uppercase;
            text-align: center;
            color: var(--text-white);
        }

        .category-badge {
            display: block;
            padding: var(--spacing-xs) var(--spacing-sm);
            border-radius: var(--radius-md);
            font-size: var(--font-size-xs);
            font-weight: var(--font-weight-semibold);
            margin: var(--spacing-xs) 0;
            color: var(--text-white);
        }

        .tooltip-item {
            margin-bottom: var(--spacing-sm);
            font-size: var(--font-size-xs);
            line-height: 1.3;
        }

        .tooltip-item:last-child {
            margin-bottom: 0;
        }

        .tooltip-item-label {
            font-weight: var(--font-weight-bold);
            color: var(--text-white);
            margin-bottom: var(--spacing-xs);
            font-size: var(--font-size-sm);
        }

        .tooltip-item-value {
            color: var(--tooltip-text);
            line-height: 1.4;
        }

        .tooltip-variations {
            color: var(--tooltip-text-muted);
            font-style: italic;
        }

        .tooltip-source {
            margin-top: var(--spacing-sm);
            padding-top: var(--spacing-sm);
            border-top: 1px solid var(--tooltip-border);
            font-size: var(--font-size-tiny);
            color: var(--tooltip-text-muted);
        }

        .tooltip-source a {
            color: var(--link-tooltip);
            text-decoration: none;
        }

        .tooltip-source a:hover {
            text-decoration: underline;
        }

        footer {
            margin-top: var(--spacing-sm);
            padding: var(--spacing-xl);
            background: var(--bg-footer-overlay);
            border-radius: var(--radius-xl);
            font-size: var(--font-size-sm);
            color: var(--text-muted);
        }

        .expandable-div {
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            user-select: none;
            padding: var(--spacing-xs) 0;
        }

        .expandable-div h3 {
            color: var(--text-primary);
            margin: 0;
            font-size: 1.1em;
        }

        .expand-div-toggle {
            font-size: 1.2em;
            transition: transform 0.3s;
            color: var(--btn-primary-bg);
        }

        .expand-div-toggle.expanded {
            transform: rotate(180deg);
        }

        .expandable-div-content {
            display: none;
            margin-top: var(--spacing-lg);
        }

        .expandable-div-content.visible {
            display: block;
        }

        footer a {
            color: var(--link-unvisited);
            text-decoration: none;
        }

        footer a:hover {
            text-decoration: underline;
        }

        .loading {
            display: none;
            color: var(--color-primary);
            font-weight: var(--font-weight-semibold);
        }

        .loading.visible {
            display: inline;
        }

        @media (max-width: 600px) {
            h1 {
                font-size: var(--font-size-xl);
            }

            .stats-row {
                flex-direction: column;
            }

            .tooltip {
                width: 280px;
            }

            /* Responsive button styling for mobile */
            .button-row {
                flex-wrap: wrap;
                gap: var(--spacing-xs);
                /* Reduce gap from 8px to 4px */
            }

            button {
                padding: var(--spacing-sm) var(--spacing-md);
                /* 8px 12px instead of 12px 30px */
                font-size: var(--font-size-sm);
                /* 0.9em instead of 1em */
                flex: 1 1 auto;
                /* Allow flexible sizing */
                min-width: 70px;
                /* Prevent buttons from becoming too small */
            }

            .loading {
                width: 100%;
                /* Force loading text to new line */
                text-align: center;
                margin-top: var(--spacing-xs);
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <header>
            <div style="display: inline-flex; align-items: flex-start; justify-content: center;">
                <h1>üêï GoodBoy<span class="betaText"></h1>beta</span>
            </div>
            <p class="tagline">
                Sniffing out coded language
            </p>
        </header>

        <div class="card">
            <div class="input-section">
                <label for="textInput" id="inputLabel">Text to analyze:</label>
                <textarea id="textInput"
                    placeholder="Enter or paste text here to check for coded and harmful language..."></textarea>
                <div id="textDisplay"></div>
            </div>

            <div class="button-row">
                <button id="analyzeBtn" onclick="analyzeText()">Analyze</button>
                <button class="hidden" id="editBtn" onclick="editText()">Edit</button>
                <button class="copy-btn" id="copyBtn" onclick="copyText()">Copy</button>
                <button class="clear-btn" id="clearBtn" onclick="clearAll()">Clear</button>
                <span class="loading" id="loading">Analyzing...</span>
            </div>

            <div id="results" class="hidden">
                <div class="stats-row">
                    <div class="stat-box">
                        <div class="stat-value" id="termCount">0</div>
                        <div class="stat-label">Terms Flagged</div>
                        <div id="termBreakdown" style="margin-top: 8px; font-size: 0.75em; color: var(--color-muted);">
                        </div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="mainCategoryCount">0</div>
                        <div class="stat-label">Main Categories</div>
                        <div id="mainCategoryList" style="margin-top: 10px; font-size: 0.85em; text-align: left;"></div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="subCategoryCount">0</div>
                        <div class="stat-label">Subcategories</div>
                        <div id="subCategoryList" style="margin-top: 10px; font-size: 0.85em; text-align: left;"></div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="signalScore">0%</div>
                        <div class="stat-label">Signal Score</div>
                        <div id="signalIndicator"></div>
                    </div>
                </div>
            </div>
        </div>

        <footer>
            <div class="expandable-div" onclick="toggleSection('instructionContent')">
                <h3>Help</h3>
                <span class="expand-div-toggle">‚ñº</span>
            </div>
            <div class="expandable-div-content" id="instructionContent">
                <table style="width: 100%">
                    <tr>
                        <td style="width: 70%; vertical-align:top">
                            <h3>Instructions</h3>
                            <p>
                                <br>
                                <b>1.</b> Type or paste your text into the input area.<br>
                                <b>2.</b> Click 'Analyze'.<br>
                                <b>3.</b> Hover over highlighted or underlined terms to see their meanings.
                                <br>
                                The highlight / underling color denotes the category (see legend).<br>
                                <b>4.</b> Check the signal score to see how much coded or harmful language appears.
                                <br>
                                <b>5.</b> Hover over the ‚ìò icon for signal score calculation details
                            </p>
                            <p>
                                <b>Notes:</b>
                                <p>
                                A high signal score doesn't automatically indicate harmful intent.
                                </p>
                                <p>
                                There is often considerable crossover between categories, we have done our best to
                                categorise broadly however due to the nature of coded language it is difficult to be
                                absolute. Use context clues in the text to help you decipher intent.
                                </p>
                            </p>
                        </td>
                        <td style="padding-left: var(--spacing-lg); padding-right: var(--spacing-lg); vertical-align:top">
                            <h3>Legend</h3>
                            <div id="legend"></div>
                        </td>
                    </tr>
                </table>
            </div>
        </footer>

        <footer>
            <div class="expandable-div" onclick="toggleSection('aboutContent')">
                <h3>About</h3>
                <span class="expand-div-toggle">‚ñº</span>
            </div>
            <div class="expandable-div-content" id="aboutContent">
                <p>
                    GoodBoy is a free, open-source tool for identifying dog whistles and harmful language, designed to
                    promote understanding of coded rhetoric and help users recognise hateful or discriminatory content.
                </p>
                <p>
                    All analysis happens locally in your browser ‚Äî no data is sent anywhere.
                </p>
                <p>
                    We built GoodBoy to support social awareness and understanding, so it‚Äôs made to be free,
                    privacy-respecting, lightweight, and easy to use in any browser. The goal is simple: make the tool
                    as accessible and frictionless as possible so more people can learn to spot coded language.
                </p>
                <p>
                    Database: <strong><span id="dbTermCount">Loading...</span></strong>
                </p>
                <p>
                    Created by the GoodBoy Team | <a href=https://ko-fi.com/nautiluszaibatsu> Support this project ‚Üó</a>
                    <br>
                    Contributions welcome via the official <a href=https://github.com/NautilusZaibatsu/GoodBoy> GitHub
                        Repository ‚Üó</a>
                </p>
                <p>
                    License: Source-Available. ¬© GoodBoy 2026
                    <br>
                    Free to use. No redistribution, modification, or re-hosting permitted.
                    <br>
                </p>
            </div>
        </footer>

        <footer>
            <div class="expandable-div" onclick="toggleSection('attributionContent')">
                <h3>Data Sources</h3>
                <span class="expand-div-toggle">‚ñº</span>
            </div>
            <div class="expandable-div-content" id="attributionContent">

                <div id="dataset-attributions"></div>

            </div>
        </footer>
    </div>

    <!-- Load the dog whistle database -->
    <script src="data/dogwhistle_data.js"></script>

    <!-- Load the harmful term database -->
    <script src="data/harmful_term_data.js"></script>

    <!-- Load the source  database -->
    <script src="data/source_data.js"></script>

    <!-- Load number obfuscation utilities (must load before obfuscation-utils.js) -->
    <script src="js/number-obfuscation-utils.js"></script>

    <!-- Load shared obfuscation utilities (DRY - single source of truth) -->
    <script src="js/obfuscation-utils.js"></script>


    <!-- Load theme configuration (design system) -->
    <script src="js/theme-config.js"></script>

    <!-- Load category hierarchy (shared with dev-tools) -->
    <script src="js/category-config.js"></script>

    <!-- Load unified place-demonym lookup -->
    <script src="data/place_demonym_lookup.js"></script>

    <!-- Main application logic -->
    <script>
        // Initialize and render the attributions
        renderAttributions();
        // Initialize the pattern matchers
        let matcher = null;
        let harmfulTermMatcher = null;

        // Store original text for re-analysis
        let originalAnalyzedText = '';

        // Initialize the legend for the how to section
        const legendDiv = document.getElementById('legend');
        let legendHtml = '';

        Object.entries(CATEGORY_HIERARCHY).forEach(([slug, cat]) => {
            legendHtml += `<span class="category-badge" style="background-color: ${cat.darkColor}">${cat.label}</span>`;
        });
        legendDiv.innerHTML = legendHtml;

        // Theme configuration loaded from js/theme-config.js
        // THEME_CONFIG and initializeTheme() are now defined in that file

        /**
         * POPULIST PATTERN MATCHING SYSTEM
         *
         * Detects nationalist, regionalist and localist language patterns by recognizing place/group names
         * and checking if similar patterns exist in the dog whistle database with different places.
         *
         * Example: If database contains "America First", it will also flag "Britain First",
         * "Make Liverpool Great Again" (from "MAGA"), "hard-working Indians" (from "hard-working Americans")
         *
         * Hybrid Categorization:
         * - Dynamic patterns with nationalist/regionalist/localist category ‚Üí auto-categorize by place type:
         *   - Countries ‚Üí Nationalist
         *   - Regions  ‚Üí Regionalist
         *   - Regions/cities ‚Üí Localist
         * - Dynamic patterns with other categories (racist, antisemitic, etc.) ‚Üí preserve original category
         */

        // Morphological generator: converts places to group names (demonyms)
        // MorphologyUtils is now imported from /js/morphology-utils.js (shared with dev-tools)

        // Pattern extractor and matcher for populist language
        const PatternMatcher = {
            patterns: [],
            place_demonym_lookup_loaded: false,

            // Initialize by extracting patterns from dog whistles
            initialize(dogWhistles) {
                if (typeof PLACE_DEMONYM_LOOKUP === 'undefined') {
                    console.warn('Place-demonym lookup not loaded yet, pattern matching disabled');
                    return;
                }

                // Build indices for fast lookups
                PLACE_DEMONYM_LOOKUP.buildIndices();

                this.place_demonym_lookup_loaded = true;
                this.allPlaces = PLACE_DEMONYM_LOOKUP.getAllVariants();

                // Build place ‚Üí type mapping for backward compatibility
                this.placeTypes = {};
                ['country', 'region', 'city'].forEach(type => {
                    const places = PLACE_DEMONYM_LOOKUP.getPlacesByType(type);
                    places.forEach(place => {
                        place.variants.forEach(variant => {
                            this.placeTypes[variant.toLowerCase()] = type;
                        });
                    });
                });

                // Extract patterns from dog whistles
                this.extractPatterns(dogWhistles);
            },

            // Extract patterns from existing dog whistles
            extractPatterns(dogWhistles) {
                const seenPatterns = new Set(); // Deduplicate by pattern text

                dogWhistles.forEach(dw => {
                    // SKIP if not dynamic mode - location-specific patterns shouldn't generate variations
                    if (!dw.categoryMode || dw.categoryMode !== 'dynamic') {
                        return; // Don't extract pattern - location-specific (e.g., "Israel Lobby", "China Virus")
                    }

                    // Process root AND all variations
                    const termsToCheck = [dw.root, ...(dw.variations || [])];

                    termsToCheck.forEach(term => {
                        let placeFound = this.findPlaceInText(term);
                        let demonymFound = this.findDemonymInText(term);

                        // If both place and demonym found, check if they overlap
                        // If they overlap, choose the longer match (e.g., "Americans" over "America")
                        if (placeFound && demonymFound) {
                            const lowerTerm = term.toLowerCase();
                            const placeIndex = lowerTerm.indexOf(placeFound.place.toLowerCase());
                            const demonymIndex = lowerTerm.indexOf(demonymFound.demonym.toLowerCase());
                            const placeEnd = placeIndex + placeFound.place.length;
                            const demonymEnd = demonymIndex + demonymFound.demonym.length;

                            // Check for overlap: ranges overlap if start < otherEnd AND end > otherStart
                            if (placeIndex < demonymEnd && placeEnd > demonymIndex) {
                                // They overlap - choose the longer one
                                if (demonymFound.demonym.length > placeFound.place.length) {
                                    placeFound = null; // Keep demonym
                                } else {
                                    demonymFound = null; // Keep place
                                }
                            }
                            // If no overlap, keep both (e.g., "Keep England English")
                        }

                        // 3. Create pattern with placeholders
                        let patternText = term.toLowerCase();
                        let placeholders = [];
                        let demonymForm = null;
                        let basePlace = null;

                        if (placeFound && demonymFound) {
                            // Both place and demonym ‚Üí two placeholders
                            // Replace place first, then demonym to avoid conflicts
                            patternText = patternText
                                .replace(placeFound.matchedText.toLowerCase(), '[place]')
                                .replace(demonymFound.demonym.toLowerCase(), '[demonym]');

                            placeholders = ['place', 'demonym'];
                            demonymForm = demonymFound.form;

                        } else if (placeFound) {
                            // Only place ‚Üí single placeholder (like "America First")
                            patternText = patternText.replace(placeFound.matchedText.toLowerCase(), '[place]');
                            placeholders = ['place'];

                        } else if (demonymFound) {
                            // Only demonym ‚Üí reverse-lookup place, single placeholder
                            patternText = patternText.replace(demonymFound.demonym.toLowerCase(), '[demonym]');
                            placeholders = ['demonym'];
                            demonymForm = demonymFound.form;
                            basePlace = demonymFound.place;
                        }

                        // Only add pattern if we found at least one placeholder and there's context
                        if (placeholders.length > 0) {
                            // Check that there's context around the placeholder(s)
                            const hasContext = patternText.replace(/\[place\]/g, '').replace(/\[demonym\]/g, '').trim().length > 0;

                            if (hasContext) {
                                // Deduplicate: only add if we haven't seen this pattern text before
                                if (!seenPatterns.has(patternText)) {
                                    seenPatterns.add(patternText);
                                    const pattern = {
                                        original: term,
                                        pattern: patternText,
                                        placeholders: placeholders,
                                        demonymForm: demonymForm,
                                        basePlace: basePlace, // For demonym-only patterns
                                        dogWhistle: dw
                                    };
                                    this.patterns.push(pattern);
                                }
                            }
                        }
                    });
                });

                console.log(`Extracted ${this.patterns.length} dynamic patterns`);
            },

            // Find place names in text
            findPlaceInText(text) {
                const lowerText = text.toLowerCase();

                // Iterate through all place variants and check if they appear in text
                for (const placeVariant of this.allPlaces) {
                    const lowerPlace = placeVariant.toLowerCase();
                    const regex = new RegExp(`\\b${lowerPlace}\\b`, 'i');

                    if (regex.test(text)) {
                        const placeData = PLACE_DEMONYM_LOOKUP.findPlaceByVariant(placeVariant);
                        if (placeData) {
                            return {
                                place: placeData.canonical,
                                type: placeData.type,
                                isGroup: false,
                                matchedText: placeVariant  // Add the actual matched variant
                            };
                        }
                    }
                }

                return null;
            },

            // Find demonym in text and return place info (includes hierarchical demonyms)
            findDemonymInText(text) {
                const lowerText = text.toLowerCase();

                // Iterate through all places and check if any of their demonyms (including hierarchical) appear in text
                for (const placeVariant of this.allPlaces) {
                    // Get ALL demonyms including hierarchical ones (e.g., Rome ‚Üí Italian, European)
                    const allDemonyms = PLACE_DEMONYM_LOOKUP.getAllDemonymsWithHierarchy(placeVariant);

                    for (const demonymObj of allDemonyms) {
                        const regex = new RegExp(`\\b${demonymObj.demonym}\\b`, 'i');
                        if (regex.test(text)) {
                            return {
                                demonym: demonymObj.demonym,
                                place: demonymObj.place,  // The place this demonym comes from (could be parent)
                                type: PLACE_DEMONYM_LOOKUP.findPlaceByVariant(placeVariant).type,
                                basePlace: placeVariant  // The base place we're checking
                            };
                        }
                    }
                }

                return null;
            },

            // Analyze text for pattern matches
            analyze(text) {
                if (!this.place_demonym_lookup_loaded || this.patterns.length === 0) {
                    console.log(
                        'Pattern matching skipped:',
                        !this.place_demonym_lookup_loaded ? 'place_demonym_lookup not loaded' : 'no patterns'
                    );
                    return { matches: [] };
                }

                const potentialMatches = [];
                const lowerText = text.toLowerCase();

                this.patterns.forEach(pattern => {
                    this.allPlaces.forEach(placeVariant => {
                        const placeData = PLACE_DEMONYM_LOOKUP.findPlaceByVariant(placeVariant);
                        if (!placeData) return;

                        // Get ALL demonyms including hierarchical ones (e.g., Rome ‚Üí Roman, Italian, European)
                        const allDemonymObjs = PLACE_DEMONYM_LOOKUP.getAllDemonymsWithHierarchy(placeVariant);
                        const allDemonyms = allDemonymObjs.map(d => d.demonym);
                        let expectedTexts = [];

                        if (pattern.placeholders.includes('place') && pattern.placeholders.includes('demonym')) {
                            allDemonyms.forEach(demonym => {
                                const expected = pattern.pattern
                                    .replace('[place]', placeVariant)    // preserve dataset variant capitalization
                                    .replace('[demonym]', demonym);     // preserve demonym capitalization
                                expectedTexts.push({ text: expected, demonym: demonym, isGroup: true });
                            });

                        } else if (pattern.placeholders.includes('place')) {
                            const expected = pattern.pattern.replace('[place]', placeVariant);
                            expectedTexts.push({ text: expected, demonym: null, isGroup: false });

                        } else if (pattern.placeholders.includes('demonym')) {
                            allDemonyms.forEach(demonym => {
                                const expected = pattern.pattern.replace('[demonym]', demonym);
                                expectedTexts.push({ text: expected, demonym: demonym, isGroup: true });
                            });
                        }

                        expectedTexts.forEach(({ text: expectedText, demonym, isGroup }) => {
                            // Case-insensitive flexible matching
                            const patternString = ObfuscationUtils.createFlexiblePattern(expectedText);
                            const flexiblePattern = new RegExp(`${patternString}s?`, 'gi'); // catch plurals

                            let match;
                            while ((match = flexiblePattern.exec(text)) !== null) {
                                const start = match.index;
                                const end = start + match[0].length;
                                const actualMatchedText = text.substring(start, end); // preserves input capitalization

                                const placeInfo = {
                                    place: placeData.canonical,
                                    type: this.placeTypes[placeVariant.toLowerCase()],
                                    isGroup: isGroup
                                };

                                const category = this.determineCategoryForMatch(pattern, placeInfo);

                                potentialMatches.push({
                                    type: 'dogwhistle',
                                    text: actualMatchedText,                       // use matched text for UI
                                    term: `${pattern.dogWhistle.root} ‚Üí ${expectedText}`, // derivation
                                    category: category,
                                    definition: pattern.dogWhistle.definition,
                                    variations: pattern.dogWhistle.variations,
                                    isPatternMatch: true,
                                    originalPattern: pattern.original,
                                    detectedPlace: placeVariant,                  // preserve dataset variant for reference
                                    isDerived: true,
                                    derivedFrom: pattern.dogWhistle.root,
                                    start: start,
                                    end: end,
                                    source: pattern.dogWhistle.source
                                });
                            }
                        });
                    });
                });

                // Filter overlapping matches - keep longest ones
                const matches = [];
                potentialMatches.sort((a, b) => (b.end - b.start) - (a.end - a.start)); // Sort by length (longest first)

                potentialMatches.forEach(match => {
                    // Check if this match overlaps with any already-kept match
                    const hasOverlap = matches.some(existing => {
                        return match.start < existing.end && match.end > existing.start;
                    });

                    if (!hasOverlap) {
                        console.log(`‚úì Pattern match: "${match.text}" (pattern: ${match.originalPattern})`);
                        matches.push(match);
                    }
                });
                return { matches };
            },

            // Determine category based on place type
            determineCategory(placeInfo) {
                // Check place type (countries = nationalist, regions = regionalist, cities = localist)
                if (placeInfo.type === 'country') {
                    return 'nationalist';
                } else if (placeInfo.type === 'region') {
                    return 'regionalist';
                } else if (placeInfo.type === 'city') {
                    return 'localist';
                }
                return 'nationalist'; // Default
            },

            // Determine category for a match using hybrid logic
            determineCategoryForMatch(pattern, placeInfo) {
                const originalCategory = pattern.dogWhistle.category;

                // For dynamic patterns, use hybrid approach:
                // - If original is nationalist/localist ‚Üí auto-categorize by place type
                // - Otherwise (racist, antisemitic, etc.) ‚Üí preserve original category
                if (originalCategory === 'nationalist' || originalCategory === 'localist') {
                    // Auto-categorize based on place type
                    return this.determineCategory(placeInfo);
                }

                // For all other categories, preserve the original
                // This ensures racist patterns stay racist, antisemitic stay antisemitic, etc.
                return originalCategory;
            }
        };

        // ObfuscationUtils is loaded from js/obfuscation-utils.js (DRY principle)
        // Single source of truth for all pattern matching logic

        // Hierarchical category system - Main categories used for highlighting colors
        // Subcategories shown in tooltips and detailed breakdowns
        // CATEGORY_HIERARCHY is now imported from /js/category-config.js

        // Build reverse mapping: subcategory -> main category
        const SUBCATEGORY_TO_MAIN = {};
        Object.keys(CATEGORY_HIERARCHY).forEach(mainKey => {
            const mainCat = CATEGORY_HIERARCHY[mainKey];
            Object.keys(mainCat.sub).forEach(subKey => {
                SUBCATEGORY_TO_MAIN[subKey] = mainKey;
            });
        });

        function renderAttributions() {
            const container = document.getElementById('dataset-attributions');
            container.innerHTML = ''; // Clear previous content if any

            SOURCE_DATA.sources.forEach(source => {
                const p = document.createElement('p');
                p.style.marginTop = '10px';

                // Dataset title
                const strong = document.createElement('strong');
                strong.textContent = source.description || source.string || source.id;
                p.appendChild(strong);

                // Prepare links
                const links = [];
                if (source.url) {
                    const a = document.createElement('a');
                    a.href = source.url;
                    a.target = '_blank';
                    a.rel = 'noopener';
                    a.textContent = 'Website ‚Üó';
                    links.push(a);
                }
                if (source.paper) {
                    const a = document.createElement('a');
                    a.href = source.paper;
                    a.target = '_blank';
                    a.rel = 'noopener';
                    a.textContent = 'Read Paper ‚Üó';
                    links.push(a);
                }
                // Only add links and page break if they exist
                if (links.length > 0) {
                    p.appendChild(document.createElement('br')); // line break after title
                    links.forEach((link, idx) => {
                        p.appendChild(link);
                        if (idx < links.length - 1) {
                            p.appendChild(document.createTextNode(' | '));
                        }
                    });
                }
                container.appendChild(p);
            });
        }

        // Helper to get main category for a subcategory
        function getMainCategory(subcategory) {
            return SUBCATEGORY_TO_MAIN[subcategory?.toLowerCase()] || null;
        }


        // Default colors for unknown categories
        const DEFAULT_COLORS = {
            lightColor: "var(--color-primary)",
            hoverColor: "var(--color-primary)",
            darkColor: "var(--color-primary)"
        };

        // Inject dynamic CSS for MAIN category colors (used for highlighting)
        function injectCategoryStyles() {
            const styleEl = document.createElement('style');
            let css = '';

            // Generate CSS for each MAIN category
            Object.keys(CATEGORY_HIERARCHY).forEach(mainKey => {
                const mainCat = CATEGORY_HIERARCHY[mainKey];
                const className = mainKey.toLowerCase().replace(/\s+/g, '-');

                css += `
                    .highlight.${className} {
                        background-color: ${mainCat.lightColor};
                    }
                    .highlight.${className}:hover {
                        background-color: ${mainCat.hoverColor};
                    }
                `;
            });

            // Add default "other" category
            css += `
                .highlight.other {
                    background-color: ${DEFAULT_COLORS.lightColor};
                }
                .highlight.other:hover {
                    background-color: ${DEFAULT_COLORS.hoverColor};
                }
            `;

            styleEl.textContent = css;
            document.head.appendChild(styleEl);
        }

        // Get the subcategory label and color
        function getSubcategoryInfo(subcategory) {
            const mainKey = getMainCategory(subcategory);
            if (!mainKey) return null;

            const mainCat = CATEGORY_HIERARCHY[mainKey];
            const subInfo = mainCat.sub[subcategory.toLowerCase()];

            return subInfo ? {
                label: subInfo.label,
                darkColor: subInfo.darkColor,
                mainLabel: mainCat.label,
                mainKey: mainKey
            } : null;
        }

        // Get the color for a category (returns subcategory color for tooltips)
        function getCategoryColor(subcategory) {
            const info = getSubcategoryInfo(subcategory);
            return info ? info.darkColor : DEFAULT_COLORS.darkColor;
        }

        // Get the CSS class for highlighting (uses MAIN category)
        function getCategoryClass(subcategory) {
            const mainKey = getMainCategory(subcategory);
            if (!mainKey) return 'other';
            return mainKey.toLowerCase().replace(/\s+/g, '-');
        }

        // Get formatted label for tooltip: "Main : Sub"
        function getFormattedCategoryLabel(subcategory) {
            const info = getSubcategoryInfo(subcategory);
            if (!info) return subcategory;
            return `${info.mainLabel} : ${info.label}`;
        }

        /**
         * Filter redundant variations from database terms
         * Uses ObfuscationUtils to detect and remove variations that our pattern matcher
         * will catch anyway (punctuation, case, hyphenation, plurals, etc.)
         *
         * This maintains DRY by using the SAME logic that our pattern matcher uses,
         * rather than duplicating it in Python.
         */
        function filterRedundantVariations(terms) {
            let totalRemoved = 0;

            const filtered = terms.map(term => {
                const root = term.root;
                const variations = term.variations || [];
                const originalCount = variations.length;

                // Track unique normalized forms to detect duplicates
                const seenNormalized = new Set();

                // Normalize and track root
                const rootNorm = ObfuscationUtils.normalizeText(root);
                const rootClean = rootNorm.replace(/[\s\-_]/g, '');
                seenNormalized.add(rootClean);

                // Filter variations
                const kept = variations.filter(variation => {
                    // Skip exact duplicates of root (case-insensitive)
                    if (variation.toLowerCase() === root.toLowerCase()) {
                        return false;
                    }

                    // Skip if it's a punctuation/case/hyphenation variant of root
                    // BUT: only if the variation isn't a meaningful shorter form
                    // Example: "inner-city" is redundant with "inner city" (filter out)
                    // Example: "13" is NOT redundant with "13%" (keep it - it's a meaningful form)
                    if (ObfuscationUtils.isPunctuationVariant(variation, root)) {
                        // Check if variation is shorter - if so, it might be a meaningful abbreviation
                        // Only filter if they're the same length (just different punctuation)
                        if (variation.length >= root.length) {
                            return false;
                        }
                        // Variation is shorter - keep it as it's likely a meaningful form
                    }

                    // Check for duplicate normalized forms
                    const varNorm = ObfuscationUtils.normalizeText(variation);
                    const varClean = varNorm.replace(/[\s\-_]/g, '');

                    if (seenNormalized.has(varClean)) {
                        // Already seen this normalized form
                        // BUT: if this variation is shorter than the root, keep it (meaningful abbreviation)
                        // Example: "13" should be kept even though "13%" normalizes to the same thing
                        if (variation.length >= root.length) {
                            return false;
                        }
                        // Variation is shorter - keep it
                    }

                    // Check if this is a plural of root or another kept variation
                    if (variation.endsWith('s') && variation.length > 1) {
                        const singular = variation.slice(0, -1);
                        const singularClean = ObfuscationUtils.normalizeText(singular).replace(/[\s\-_]/g, '');

                        // Skip if plural of root
                        if (singularClean === rootClean) {
                            return false;
                        }

                        // Skip if plural of a variation we're keeping
                        if (seenNormalized.has(singularClean)) {
                            return false;
                        }
                    }

                    // Keep this variation and track its normalized form
                    seenNormalized.add(varClean);
                    return true;
                });

                totalRemoved += originalCount - kept.length;

                return { ...term, variations: kept };
            });

            if (totalRemoved > 0) {
                console.log(`‚úì Filtered out ${totalRemoved} redundant variations (punctuation, case, plurals, etc.)`);
            }

            return filtered;
        }

        // Load and prepare data on page load
        window.addEventListener('DOMContentLoaded', () => {
            // Initialize theme (inject CSS custom properties)
            initializeTheme();

            // Inject category-specific CSS styles
            injectCategoryStyles();

            // Set initial disabled state for buttons
            document.getElementById('analyzeBtn').disabled = true;
            document.getElementById('copyBtn').disabled = true;
            document.getElementById('clearBtn').disabled = true;

            let dogWhistleData = null;
            let harmfulTermData = null;

            // Check dog whistle database
            if (typeof GOODBOY_DATA !== 'undefined') {
                // Filter redundant variations using our pattern matching logic
                const filteredTerms = filterRedundantVariations(GOODBOY_DATA.terms);
                dogWhistleData = {
                    ...GOODBOY_DATA,
                    terms: filteredTerms
                };
                console.log(`‚úì Loaded ${GOODBOY_DATA.total} dog whistles`);
            } else {
                console.error('Failed to load dog whistle database');
            }

            // Check harmful term database
            if (typeof GOODBOY_HARMFUL_TERM_DATA !== 'undefined') {
                // Filter redundant variations using our pattern matching logic
                const filteredHarmfulTerms = filterRedundantVariations(GOODBOY_HARMFUL_TERM_DATA.terms);
                harmfulTermData = {
                    ...GOODBOY_HARMFUL_TERM_DATA,
                    terms: filteredHarmfulTerms
                };
                console.log(`‚úì Loaded ${GOODBOY_HARMFUL_TERM_DATA.uniqueTerms} harmful terms`);
            } else {
                console.error('Failed to load harmful term database');
            }

            // Update database term count in footer
            const dbTermCountEl = document.getElementById('dbTermCount');
            if (dbTermCountEl) {
                const dogWhistleCount = dogWhistleData ? dogWhistleData.totalTerms : 0;
                const harmfulTermCount = harmfulTermData ? harmfulTermData.totalTerms : 0;

                if (dogWhistleCount > 0 && harmfulTermCount > 0) {
                    const harmfulTermText = harmfulTermCount === 1 ? 'harmful term' : 'harmful terms';
                    dbTermCountEl.textContent = `${dogWhistleCount} dog whistles and ${harmfulTermCount} ${harmfulTermText}`;
                } else if (dogWhistleCount > 0) {
                    dbTermCountEl.textContent = `${dogWhistleCount} dog whistles`;
                } else if (harmfulTermCount > 0) {
                    const harmfulTermText = harmfulTermCount === 1 ? 'harmful term' : 'harmful terms';
                    dbTermCountEl.textContent = `${harmfulTermCount} ${harmfulTermText}`;
                } else {
                    dbTermCountEl.textContent = 'Error loading';
                }
            }

            // Initialize matchers with the databases
            if (dogWhistleData) {
                matcher = new DogWhistleMatcher(dogWhistleData);
            } else {
                console.error('Error: Failed to load dog whistle database.');
            }

            if (harmfulTermData) {
                harmfulTermMatcher = new HarmfulTermMatcher(harmfulTermData);
            } else {
                console.error('Error: Failed to load harmful term database.');
            }

            // Initialize pattern matcher for populist detection
            if (dogWhistleData && typeof PLACE_DEMONYM_LOOKUP !== 'undefined') {
                PatternMatcher.initialize(dogWhistleData.terms);
                console.log('‚úì Pattern matcher initialized for populist detection');
            } else if (typeof PLACE_DEMONYM_LOOKUP === 'undefined') {
                console.warn('Place-demonym lookup not loaded, populist pattern matching disabled');
            }

            if (!dogWhistleData && !harmfulTermData) {
                alert('Error: Failed to load databases. Please refresh the page.');
            }
        });

        function editText() {
            // User clicked "Edit Text" button - restore editable state
            clearAnalysisHighlights();
        }

        // Helper function to toggle a section of the page
        function toggleSection(div_section) {
            const content = document.getElementById(div_section);
            const toggle = document.querySelector('.expand-div-toggle');
            content.classList.toggle('visible');
            toggle.classList.toggle('expanded');
        }

        function clearAnalysisHighlights() {
            const textInput = document.getElementById('textInput');
            const textDisplay = document.getElementById('textDisplay');
            const analyzeBtn = document.getElementById('analyzeBtn');
            const editBtn = document.getElementById('editBtn');
            const resultsDiv = document.getElementById('results');
            const inputLabel = document.getElementById('inputLabel');

            // Check if analysis is currently displayed
            if (textDisplay.classList.contains('visible') && originalAnalyzedText) {
                // Put original text back into the editable textarea
                textInput.value = originalAnalyzedText;

                // Switch from display div back to editable textarea
                textDisplay.classList.remove('visible');
                textDisplay.innerHTML = '';
                textInput.classList.remove('hidden');

                // Update label
                inputLabel.textContent = 'Text to analyze:';

                // Show Analyze button, hide Edit button (keep Clear button visible)
                analyzeBtn.classList.remove('hidden');
                analyzeBtn.disabled = false;
                editBtn.classList.add('hidden');

                // Hide results stats
                resultsDiv.classList.add('hidden');
            }
        }

        class DogWhistleMatcher {
            constructor(dogWhistleData) {
                // Store dog whistle data
                this.dogWhistleData = dogWhistleData;
                this.dogWhistleTerms = dogWhistleData.terms;

                // Build lookup map for dog whistles using DRY helper
                this.variationMap = ObfuscationUtils.buildVariationMap(this.dogWhistleTerms);
            }

            analyze(text) {
                // Normalize Unicode characters to ensure consistent matching
                text = text.normalize('NFC');

                const allMatches = [];

                // Find all dog whistle matches
                this.variationMap.forEach((termData, variation) => {
                    // Create flexible regex pattern that catches obfuscation
                    const flexiblePattern = ObfuscationUtils.createFlexiblePattern(variation);
                    // Add optional 's' at the end to catch plurals
                    const pluralPattern = `${flexiblePattern}s?`;

                    // Special handling for purely numeric terms (e.g., "88", "28", "1488")
                    // These should match within larger numbers (e.g., "1828" contains "28")
                    // But NOT with leading zeros (e.g., "088") or letters (e.g., "c88")
                    const isNumericTerm = /^\d+$/.test(variation);
                    const isLetterTerm = /^[a-z]+$/i.test(variation);

                    let regex;
                    if (isNumericTerm) {
                        // For numeric terms: match anywhere, validation will filter out bad matches
                        // Allow both "blood88" and "88blood" - validation handles context
                        regex = new RegExp(`${pluralPattern}`, 'gi');
                    } else if (isLetterTerm) {
                        // For purely letter terms (e.g., "hh"): prevent other letters but allow numbers
                        // This allows "hh88" to match "hh"
                        regex = new RegExp(`(?<![a-z])${pluralPattern}(?![a-z])`, 'gi');
                    } else {
                        // For mixed terms: use standard word boundaries
                        // Use lookahead/lookbehind instead of \b to handle non-word chars like $ and @
                        regex = new RegExp(`(?<![a-z0-9])${pluralPattern}(?![a-z0-9])`, 'gi');
                    }

                    let match;
                    let lastIndex = -1;
                    while ((match = regex.exec(text)) !== null) {
                        if (match.index === lastIndex && match[0].length === 0) {
                            regex.lastIndex++;
                            continue;
                        }
                        lastIndex = match.index;

                        // Trim trailing non-alphanumeric characters from the match
                        // This prevents highlighting trailing punctuation like quotes, commas, periods
                        let matchedText = match[0];
                        let trimmedLength = matchedText.length;
                        while (trimmedLength > 0 && /[^a-zA-Z0-9]/.test(matchedText[trimmedLength - 1])) {
                            trimmedLength--;
                        }
                        if (trimmedLength < matchedText.length) {
                            matchedText = matchedText.substring(0, trimmedLength);
                            if (matchedText.length === 0) continue; // Skip if nothing left
                        }

                        // Validate numeric matches - BOTH numeric terms AND non-numeric terms that match digits
                        // Example: variation "lgb" can match "168" via char substitutions (l‚Üí1, g‚Üí6, b‚Üí8)
                        // Also: variation "DEI" can match "de 1" where "1" is from "136"
                        // Strategy: Allow the match UNLESS it's part of a longer number that isn't a known term
                        const matchIsDigits = /^\d+$/.test(matchedText);
                        const matchIsMultiDigit = matchIsDigits && matchedText.length >= 2;
                        const matchContainsDigit = /\d/.test(matchedText);

                        // Validate if: variation is numeric OR match contains digits
                        // For numeric terms: check if surrounding number is also a known term
                        // For non-numeric terms: check if digits are pulled from longer numbers
                        if (isNumericTerm || matchIsMultiDigit || matchContainsDigit) {
                            const matchStart = match.index;
                            const matchEnd = match.index + match[0].length;
                            const matchLength = match[0].length;

                            // For numeric variations (like "168"), validate context
                            // This applies whether matched as digits "168" OR letters "lgb" matching digits

                            // Check surrounding context - look for consecutive digits OR letters in the text
                            let countBefore = 0;
                            let countAfter = 0;

                            // Count similar characters before (digits if match is digits, letters if match is letters)
                            const isDigitMatch = /^\d+$/.test(matchedText);
                            const isLetterMatch = /^[a-z]+$/i.test(matchedText);
                            const isMixedMatch = !isDigitMatch && !isLetterMatch;

                            if (isDigitMatch) {
                                // Count digits before and after
                                for (let i = matchStart - 1; i >= 0 && /\d/.test(text[i]); i--) {
                                    countBefore++;
                                }
                                for (let i = matchEnd; i < text.length && /\d/.test(text[i]); i++) {
                                    countAfter++;
                                }
                            } else if (isLetterMatch) {
                                // For letter obfuscations like "lbg", check if it's in a long digit sequence
                                // by looking at the broader context
                                for (let i = matchStart - 1; i >= 0 && /\d/.test(text[i]); i--) {
                                    countBefore++;
                                }
                                for (let i = matchEnd; i < text.length && /\d/.test(text[i]); i++) {
                                    countAfter++;
                                }
                            } else if (isMixedMatch) {
                                // For mixed matches like "de 1", check if any digit is part of a larger number
                                // Find each digit position in the match and check its context
                                for (let i = 0; i < matchedText.length; i++) {
                                    if (/\d/.test(matchedText[i])) {
                                        const digitPos = matchStart + i;
                                        // Count digits before this digit
                                        let digitCountBefore = 0;
                                        for (let j = digitPos - 1; j >= 0 && /\d/.test(text[j]); j--) {
                                            digitCountBefore++;
                                        }
                                        // Count digits after this digit
                                        let digitCountAfter = 0;
                                        for (let j = digitPos + 1; j < text.length && /\d/.test(text[j]); j++) {
                                            digitCountAfter++;
                                        }
                                        // If this digit has extra digits around it, accumulate
                                        countBefore = Math.max(countBefore, digitCountBefore);
                                        countAfter = Math.max(countAfter, digitCountAfter);
                                    }
                                }
                            }

                            const extraChars = countBefore + countAfter;

                            // Check what's immediately before and after the sequence
                            const seqStart = matchStart - countBefore;
                            const seqEnd = matchEnd + countAfter;
                            const charBefore = seqStart > 0 ? text[seqStart - 1] : '';
                            const charAfter = seqEnd < text.length ? text[seqEnd] : '';

                            // If in a long sequence with no adjacent letters, likely random
                            const hasLetterBefore = /[a-z]/i.test(charBefore);
                            const hasLetterAfter = /[a-z]/i.test(charAfter);

                            // Reject if there are extra digits and no adjacent letters
                            // BUT: allow if extra digits form other known terms (overlapping numeric terms)
                            // This prevents "13" from matching in "135" but allows "13" and "28" in "2813"
                            if (!hasLetterBefore && !hasLetterAfter && extraChars > 0) {
                                let hasKnownOverlap = false;

                                // Check if digits before form a known term
                                if (countBefore > 0) {
                                    const digitsBefore = text.substring(seqStart, matchStart);
                                    if (this.variationMap.has(digitsBefore)) {
                                        hasKnownOverlap = true;
                                    }
                                }

                                // Check if digits after form a known term
                                if (countAfter > 0) {
                                    const digitsAfter = text.substring(matchEnd, seqEnd);
                                    if (this.variationMap.has(digitsAfter)) {
                                        hasKnownOverlap = true;
                                    }
                                }

                                if (!hasKnownOverlap) {
                                    // Extra digits don't form known terms - likely random sequence
                                    continue;
                                }
                                // Otherwise allow it - overlapping with other known numeric terms
                            }
                        }

                        allMatches.push({
                            start: match.index,
                            end: match.index + matchedText.length,
                            length: matchedText.length,
                            text: matchedText,
                            type: 'dogwhistle',
                            term: termData.root,
                            category: termData.category,
                            definition: termData.definition,
                            variations: termData.variations,
                            source: termData.source, // Pass through source field
                            isNumeric: isNumericTerm
                        });
                    }
                });

                // Remove overlapping matches, keeping the longest/most specific ones
                // Sort by: 1) length (descending), 2) position (ascending)
                allMatches.sort((a, b) => {
                    if (b.length !== a.length) return b.length - a.length;
                    return a.start - b.start;
                });

                const matches = [];
                const usedRanges = [];

                // Keep matches that don't overlap with already-selected matches
                // EXCEPT: allow numeric terms to overlap with each other (e.g., "1813" can match both "18" and "13")
                for (const match of allMatches) {
                    const isNumericMatch = match.isNumeric || false;

                    // Check if this match overlaps with any already-selected match
                    let hasBlockingOverlap = false;
                    for (const range of usedRanges) {
                        if (ObfuscationUtils.overlaps(match, range)) {
                            // Allow overlap if BOTH terms are purely numeric
                            const rangeIsNumeric = range.isNumeric;
                            if (!(isNumericMatch && rangeIsNumeric)) {
                                hasBlockingOverlap = true;
                                break;
                            }
                        }
                    }

                    if (!hasBlockingOverlap) {
                        matches.push(match);
                        usedRanges.push({
                            start: match.start,
                            end: match.end,
                            isNumeric: isNumericMatch
                        });
                    }
                }

                // Sort final matches by position for display
                matches.sort((a, b) => a.start - b.start);

                // Count unique categories
                const foundCategories = new Set(matches.map(m => m.category));

                return {
                    matches,
                    categoryCount: foundCategories.size,
                    categories: Array.from(foundCategories)
                };
            }
        }

        class HarmfulTermMatcher {
            constructor(harmfulTermData) {
                // Store harmful term data
                this.harmfulTermData = harmfulTermData;
                this.harmfulTermTerms = harmfulTermData.terms;

                // Build lookup map for harmful terms using DRY helper
                this.variationMap = ObfuscationUtils.buildVariationMap(this.harmfulTermTerms);
            }

            analyze(text) {
                // Normalize Unicode characters to ensure consistent matching
                text = text.normalize('NFC');

                const allMatches = [];

                // Find all harmful term matches
                this.variationMap.forEach((termData, variation) => {
                    // Create flexible regex pattern that catches obfuscation
                    const flexiblePattern = ObfuscationUtils.createFlexiblePattern(variation);
                    // Add optional 's' at the end to catch plurals
                    const pluralPattern = `${flexiblePattern}s?`;

                    // Special handling for purely numeric terms (e.g., "88", "28", "1488")
                    // These should match within larger numbers (e.g., "1828" contains "28")
                    // But NOT with leading zeros (e.g., "088") or letters (e.g., "c88")
                    const isNumericTerm = /^\d+$/.test(variation);
                    const isLetterTerm = /^[a-z]+$/i.test(variation);

                    let regex;
                    if (isNumericTerm) {
                        // For numeric terms: match anywhere, validation will filter out bad matches
                        // Allow both "blood88" and "88blood" - validation handles context
                        regex = new RegExp(`${pluralPattern}`, 'gi');
                    } else if (isLetterTerm) {
                        // For purely letter terms: prevent other letters but allow numbers
                        regex = new RegExp(`(?<![a-z])${pluralPattern}(?![a-z])`, 'gi');
                    } else {
                        // For mixed terms: use standard word boundaries
                        regex = new RegExp(`(?<![a-z0-9])${pluralPattern}(?![a-z0-9])`, 'gi');
                    }

                    let match;
                    let lastIndex = -1;
                    while ((match = regex.exec(text)) !== null) {
                        if (match.index === lastIndex && match[0].length === 0) {
                            regex.lastIndex++;
                            continue;
                        }
                        lastIndex = match.index;

                        // Trim trailing non-alphanumeric characters from the match
                        // This prevents highlighting trailing punctuation like quotes, commas, periods
                        let matchedText = match[0];
                        let trimmedLength = matchedText.length;
                        while (trimmedLength > 0 && /[^a-zA-Z0-9]/.test(matchedText[trimmedLength - 1])) {
                            trimmedLength--;
                        }
                        if (trimmedLength < matchedText.length) {
                            matchedText = matchedText.substring(0, trimmedLength);
                            if (matchedText.length === 0) continue; // Skip if nothing left
                        }

                        // Validate numeric matches - BOTH numeric terms AND non-numeric terms that match digits
                        // Example: variation "lgb" can match "168" via char substitutions (l‚Üí1, g‚Üí6, b‚Üí8)
                        // Also: variation "DEI" can match "de 1" where "1" is from "136"
                        // Strategy: Allow the match UNLESS it's part of a longer number that isn't a known term
                        const matchIsDigits = /^\d+$/.test(matchedText);
                        const matchIsMultiDigit = matchIsDigits && matchedText.length >= 2;
                        const matchContainsDigit = /\d/.test(matchedText);

                        // Validate if: variation is numeric OR match contains digits
                        // For numeric terms: check if surrounding number is also a known term
                        // For non-numeric terms: check if digits are pulled from longer numbers
                        if (isNumericTerm || matchIsMultiDigit || matchContainsDigit) {
                            const matchStart = match.index;
                            const matchEnd = match.index + match[0].length;
                            const matchLength = match[0].length;

                            // For numeric variations (like "168"), validate context
                            // This applies whether matched as digits "168" OR letters "lgb" matching digits

                            // Check surrounding context - look for consecutive digits OR letters in the text
                            let countBefore = 0;
                            let countAfter = 0;

                            // Count similar characters before (digits if match is digits, letters if match is letters)
                            const isDigitMatch = /^\d+$/.test(matchedText);
                            const isLetterMatch = /^[a-z]+$/i.test(matchedText);
                            const isMixedMatch = !isDigitMatch && !isLetterMatch;

                            if (isDigitMatch) {
                                // Count digits before and after
                                for (let i = matchStart - 1; i >= 0 && /\d/.test(text[i]); i--) {
                                    countBefore++;
                                }
                                for (let i = matchEnd; i < text.length && /\d/.test(text[i]); i++) {
                                    countAfter++;
                                }
                            } else if (isLetterMatch) {
                                // For letter obfuscations like "lbg", check if it's in a long digit sequence
                                // by looking at the broader context
                                for (let i = matchStart - 1; i >= 0 && /\d/.test(text[i]); i--) {
                                    countBefore++;
                                }
                                for (let i = matchEnd; i < text.length && /\d/.test(text[i]); i++) {
                                    countAfter++;
                                }
                            } else if (isMixedMatch) {
                                // For mixed matches like "de 1", check if any digit is part of a larger number
                                // Find each digit position in the match and check its context
                                for (let i = 0; i < matchedText.length; i++) {
                                    if (/\d/.test(matchedText[i])) {
                                        const digitPos = matchStart + i;
                                        // Count digits before this digit
                                        let digitCountBefore = 0;
                                        for (let j = digitPos - 1; j >= 0 && /\d/.test(text[j]); j--) {
                                            digitCountBefore++;
                                        }
                                        // Count digits after this digit
                                        let digitCountAfter = 0;
                                        for (let j = digitPos + 1; j < text.length && /\d/.test(text[j]); j++) {
                                            digitCountAfter++;
                                        }
                                        // If this digit has extra digits around it, accumulate
                                        countBefore = Math.max(countBefore, digitCountBefore);
                                        countAfter = Math.max(countAfter, digitCountAfter);
                                    }
                                }
                            }

                            const extraChars = countBefore + countAfter;

                            // Check what's immediately before and after the sequence
                            const seqStart = matchStart - countBefore;
                            const seqEnd = matchEnd + countAfter;
                            const charBefore = seqStart > 0 ? text[seqStart - 1] : '';
                            const charAfter = seqEnd < text.length ? text[seqEnd] : '';

                            // If in a long sequence with no adjacent letters, likely random
                            const hasLetterBefore = /[a-z]/i.test(charBefore);
                            const hasLetterAfter = /[a-z]/i.test(charAfter);

                            // Reject if there are extra digits and no adjacent letters
                            // BUT: allow if extra digits form other known terms (overlapping numeric terms)
                            // This prevents "13" from matching in "135" but allows "13" and "28" in "2813"
                            if (!hasLetterBefore && !hasLetterAfter && extraChars > 0) {
                                let hasKnownOverlap = false;

                                // Check if digits before form a known term
                                if (countBefore > 0) {
                                    const digitsBefore = text.substring(seqStart, matchStart);
                                    if (this.variationMap.has(digitsBefore)) {
                                        hasKnownOverlap = true;
                                    }
                                }

                                // Check if digits after form a known term
                                if (countAfter > 0) {
                                    const digitsAfter = text.substring(matchEnd, seqEnd);
                                    if (this.variationMap.has(digitsAfter)) {
                                        hasKnownOverlap = true;
                                    }
                                }

                                if (!hasKnownOverlap) {
                                    // Extra digits don't form known terms - likely random sequence
                                    continue;
                                }
                                // Otherwise allow it - overlapping with other known numeric terms
                            }
                        }

                        allMatches.push({
                            start: match.index,
                            end: match.index + matchedText.length,
                            length: matchedText.length,
                            text: matchedText,
                            type: 'harmfulTerm',
                            term: termData.root,
                            matchedTerm: variation,
                            category: termData.category,
                            definition: termData.definition,
                            variations: termData.variations,
                            source: termData.source,
                            isNumeric: isNumericTerm
                        });
                    }
                });

                // Remove overlapping matches, keeping the longest/most specific ones
                allMatches.sort((a, b) => {
                    if (b.length !== a.length) return b.length - a.length;
                    return a.start - b.start;
                });

                const matches = [];
                const usedRanges = [];

                // Keep matches that don't overlap with already-selected matches
                // EXCEPT: allow numeric terms to overlap with each other (e.g., "1813" can match both "18" and "13")
                for (const match of allMatches) {
                    const isNumericMatch = match.isNumeric || false;

                    // Check if this match overlaps with any already-selected match
                    let hasBlockingOverlap = false;
                    for (const range of usedRanges) {
                        if (ObfuscationUtils.overlaps(match, range)) {
                            // Allow overlap if BOTH terms are purely numeric
                            const rangeIsNumeric = range.isNumeric;
                            if (!(isNumericMatch && rangeIsNumeric)) {
                                hasBlockingOverlap = true;
                                break;
                            }
                        }
                    }

                    if (!hasBlockingOverlap) {
                        matches.push(match);
                        usedRanges.push({
                            start: match.start,
                            end: match.end,
                            isNumeric: isNumericMatch
                        });
                    }
                }

                // Sort final matches by position for display
                matches.sort((a, b) => a.start - b.start);

                // Count unique categories
                const foundCategories = new Set(matches.map(m => m.category));

                return {
                    matches,
                    categoryCount: foundCategories.size,
                    categories: Array.from(foundCategories)
                };
            }
        }

        function calculateSignalScore(text, matches) {
            // Count words in text
            const wordCount = text.trim().split(/\s+/).length;
            if (matches.length === 0 || wordCount === 0) return {
                total: 0,
                breakdown: {
                    densityScore: 0,
                    typeWeight: 0,
                    categoryScore: 0,
                    densityPercent: 20,
                    typePercent: 50,
                    categoryPercent: 30,
                    matchCount: 0,
                    wordCount: 0,
                    harmfulCount: 0,
                    dogWhistleCount: 0,
                    uniqueCategories: 0
                }
            };

            // 1. Match Density (20%) - Percentage of words that are problematic
            const matchDensity = matches.length / wordCount;
            const densityScore = Math.min(matchDensity * 100, 20);

            // 2. Match Type Weight (50%) - Harmful terms weighted higher than dog whistles
            // Harmful terms are explicit, dog whistles are coded
            const harmfulCount = matches.filter(m => m.type === 'harmfulTerm').length;
            const dogWhistleCount = matches.filter(m => m.type === 'dogwhistle').length;

            // Weight: harmful terms = 2x, dog whistles = 1x
            const weightedMatches = (harmfulCount * 2) + dogWhistleCount;
            const avgWeight = weightedMatches / matches.length;

            // Map avg weight (1.0 to 1.5) to score (0 to 30)
            const typeWeight = ((avgWeight - 1.0) / 0.5) * 30;

            // 3. Category Diversity (10%) - Multiple categories = more problematic
            const uniqueCategories = new Set(matches.map(m => m.category.toLowerCase())).size;
            let categoryScore = 0;
            if (uniqueCategories >= 5) {
                categoryScore = 30;
            } else if (uniqueCategories >= 3) {
                categoryScore = 22.5;
            } else if (uniqueCategories >= 2) {
                categoryScore = 15;
            } else {
                categoryScore = 7.5; // Even 1 category gets some points
            }

            // Calculate final score
            const totalScore = Math.round(densityScore + typeWeight + categoryScore);

            return {
                total: Math.min(totalScore, 100), // Cap at 100%
                breakdown: {
                    densityScore: Math.round(densityScore),
                    typeWeight: Math.round(typeWeight),
                    categoryScore: Math.round(categoryScore),
                    densityPercent: 20,
                    typePercent: 50,
                    categoryPercent: 30,
                    matchCount: matches.length,
                    wordCount: wordCount,
                    harmfulCount: harmfulCount,
                    dogWhistleCount: dogWhistleCount,
                    uniqueCategories: uniqueCategories
                }
            };
        }

        function updateScoreBreakdownTooltip(breakdown) {
            const tooltip = document.querySelector('.info-icon .tooltip');
            if (!tooltip) return;

            const total = breakdown.densityScore + breakdown.typeWeight + breakdown.categoryScore;

            tooltip.innerHTML = `
                <div class="tooltip-item">
                    <div class="tooltip-item-label">Signal Score Breakdown</div>
                </div>
                <div class="tooltip-item">
                    <div class="tooltip-item-label">Match Density (${breakdown.densityPercent}%)</div>
                    <div class="tooltip-item-value">${breakdown.densityScore} points</div>
                    <div class="tooltip-item-value" style="font-size: 0.9em; opacity: 0.8;">${breakdown.matchCount} matches / ${breakdown.wordCount} words</div>
                </div>
                <div class="tooltip-item">
                    <div class="tooltip-item-label">Match Type Weight (${breakdown.typePercent}%)</div>
                    <div class="tooltip-item-value">${breakdown.typeWeight} points</div>
                    <div class="tooltip-item-value" style="font-size: 0.9em; opacity: 0.8;">${breakdown.harmfulCount} harmful, ${breakdown.dogWhistleCount} dog whistles</div>
                </div>
                <div class="tooltip-item">
                    <div class="tooltip-item-label">Category Diversity (${breakdown.categoryPercent}%)</div>
                    <div class="tooltip-item-value">${breakdown.categoryScore} points</div>
                    <div class="tooltip-item-value" style="font-size: 0.9em; opacity: 0.8;">${breakdown.uniqueCategories} unique categories</div>
                </div>
                <div class="tooltip-source" style="text-align: center;">
                    <strong>Total: ${total} points</strong>
                </div>
            `;
        }

        function analyzeText() {
            const textInput = document.getElementById('textInput');

            // Always get text from textarea (it's editable)
            const text = textInput.value.trim();

            if (!text) {
                alert('Please enter some text to analyze.');
                return;
            }

            if (!matcher && !harmfulTermMatcher) {
                alert('Databases not loaded. Please refresh the page.');
                return;
            }

            // Store original text for potential editing
            originalAnalyzedText = text;

            // Show loading state
            document.getElementById('loading').classList.add('visible');
            document.getElementById('analyzeBtn').disabled = true;

            // Use setTimeout to allow UI to update
            setTimeout(() => {
                // Analyze with both matchers
                const dogWhistleResults = matcher ? matcher.analyze(text) : { matches: [], categoryCount: 0, categories: [] };
                const harmfulTermResults = harmfulTermMatcher ? harmfulTermMatcher.analyze(text) : { matches: [], categoryCount: 0, categories: [] };

                // Analyze for populist patterns
                const patternResults = PatternMatcher.place_demonym_lookup_loaded ? PatternMatcher.analyze(text) : { matches: [] };

                // Combine results (pattern matches are also dog whistles)
                const allMatches = [
                    ...dogWhistleResults.matches,
                    ...harmfulTermResults.matches,
                    ...patternResults.matches
                ];

                // Deduplicate overlapping matches from different matchers (keep longest)
                allMatches.sort((a, b) => {
                    if (b.end - b.start !== a.end - a.start) {
                        return (b.end - b.start) - (a.end - a.start); // Sort by length (longest first)
                    }
                    return a.start - b.start; // If same length, sort by position
                });

                const combinedMatches = [];
                const usedRanges = [];

                for (const match of allMatches) {
                    const hasOverlap = usedRanges.some(range =>
                        match.start < range.end && match.end > range.start
                    );
                    if (!hasOverlap) {
                        combinedMatches.push(match);
                        usedRanges.push({ start: match.start, end: match.end });
                    }
                }

                // Sort by position for display
                combinedMatches.sort((a, b) => a.start - b.start);

                // Count all unique categories
                const allCategories = new Set([
                    ...dogWhistleResults.categories,
                    ...harmfulTermResults.categories,
                    ...patternResults.matches.map(m => m.category)
                ]);

                const combinedResults = {
                    matches: combinedMatches,
                    dogWhistleCount: dogWhistleResults.matches.length + patternResults.matches.length,
                    harmfulTermCount: harmfulTermResults.matches.length,
                    categoryCount: allCategories.size,
                    categories: Array.from(allCategories)
                };

                displayResults(text, combinedResults);

                // Hide loading state
                document.getElementById('loading').classList.remove('visible');

                // Track analytics (TODO: implement)
                trackAnalysis(text, combinedResults);
            }, 100);
        }

        function displayResults(originalText, results) {
            const textInput = document.getElementById('textInput');
            const textDisplay = document.getElementById('textDisplay');
            const analyzeBtn = document.getElementById('analyzeBtn');
            const clearBtn = document.getElementById('clearBtn');
            const resultsDiv = document.getElementById('results');
            const termCount = document.getElementById('termCount');
            const categoryCount = document.getElementById('categoryCount');
            const inputLabel = document.getElementById('inputLabel');

            // Count for dog whistles and harmful terms
            const dogWhistleMatches = results.matches.filter(m => m.type === 'dogwhistle');
            const harmfulTermMatches = results.matches.filter(m => m.type === 'harmfulTerm');

            // Update total count
            const totalCount = results.matches.length;
            const dogWhistleCount = dogWhistleMatches.length;
            const harmfulTermCount = harmfulTermMatches.length;

            // Update Terms Flagged count
            termCount.textContent = totalCount;

            // Update breakdown - display on separate lines, ordered by count
            const termBreakdown = document.getElementById('termBreakdown');
            if (termBreakdown) {
                const lines = [];

                if (dogWhistleCount > 0) {
                    const dogWhistleText = dogWhistleCount === 1 ? 'dog whistle' : 'dog whistles';
                    lines.push({ count: dogWhistleCount, text: `${dogWhistleCount} ${dogWhistleText}` });
                }

                if (harmfulTermCount > 0) {
                    const harmfulTermText = harmfulTermCount === 1 ? 'harmful term' : 'harmful terms';
                    lines.push({ count: harmfulTermCount, text: `${harmfulTermCount} ${harmfulTermText}` });
                }

                // Sort by count (descending)
                lines.sort((a, b) => b.count - a.count);

                // Join with line breaks
                termBreakdown.innerHTML = lines.map(line => line.text).join('<br>');
            }

            // Count subcategories and group by main category
            const subCategoryCounts = {};
            const mainCategoryCounts = {};

            results.matches.forEach(match => {
                const subcat = match.category.toLowerCase();
                const mainKey = getMainCategory(subcat);

                // Count subcategories
                subCategoryCounts[subcat] = (subCategoryCounts[subcat] || 0) + 1;

                // Count main categories
                if (mainKey) {
                    mainCategoryCounts[mainKey] = (mainCategoryCounts[mainKey] || 0) + 1;
                }
            });

            // Sort main categories by count (descending)
            const sortedMainCategories = Object.entries(mainCategoryCounts)
                .sort((a, b) => b[1] - a[1]);

            // Sort subcategories by count (descending)
            const sortedSubCategories = Object.entries(subCategoryCounts)
                .sort((a, b) => b[1] - a[1]);

            // Update main category count and display
            document.getElementById('mainCategoryCount').textContent = sortedMainCategories.length;
            const mainCategoryList = document.getElementById('mainCategoryList');
            let mainCategoryHtml = '';
            sortedMainCategories.forEach(([mainKey, count]) => {
                const mainCat = CATEGORY_HIERARCHY[mainKey];
                if (mainCat) {
                    mainCategoryHtml += `<span class="category-badge" style="background-color: ${mainCat.darkColor}">${mainCat.label} (${count})</span>`;
                }
            });
            mainCategoryList.innerHTML = mainCategoryHtml;

            // Update subcategory count and display
            document.getElementById('subCategoryCount').textContent = sortedSubCategories.length;
            const subCategoryList = document.getElementById('subCategoryList');
            let subCategoryHtml = '';
            sortedSubCategories.forEach(([subcat, count]) => {
                const color = getCategoryColor(subcat);
                const info = getSubcategoryInfo(subcat);
                const label = info ? info.label : subcat;
                subCategoryHtml += `<span class="category-badge" style="background-color: ${color}">${label} (${count})</span>`;
            });
            subCategoryList.innerHTML = subCategoryHtml;

            // Calculate Signal Score
            const scoreResult = calculateSignalScore(originalText, results.matches);
            const signalScore = scoreResult.total;
            document.getElementById('signalScore').textContent = `${signalScore}%`;

            // Update signal indicator
            const signalIndicator = document.getElementById('signalIndicator');
            let indicatorClass = '';
            let indicatorText = '';

            if (signalScore === 0) {
                indicatorClass = 'signal-low';
                indicatorText = 'Clean';
            } else if (signalScore <= 25) {
                indicatorClass = 'signal-low';
                indicatorText = 'Low';
            } else if (signalScore <= 50) {
                indicatorClass = 'signal-moderate';
                indicatorText = 'Moderate';
            } else if (signalScore <= 75) {
                indicatorClass = 'signal-high';
                indicatorText = 'High';
            } else {
                indicatorClass = 'signal-severe';
                indicatorText = 'Severe';
            }

            signalIndicator.innerHTML = `<span class="signal-indicator ${indicatorClass}">${indicatorText}</span><span class="highlight info-icon">‚ìò<span class="tooltip"></span></span>`;

            // Update score breakdown tooltip
            updateScoreBreakdownTooltip(scoreResult.breakdown);

            // Build highlighted text
            let displayHtml = '';
            if (results.matches.length === 0) {
                displayHtml = '<div class="no-results">‚úì No dog whistles or harmful terms detected in this text.</div>' +
                    '<div style="margin-top: 15px;">' + escapeHtml(originalText) + '</div>';
            } else {
                let lastIndex = 0;

                results.matches.forEach(match => {
                    // Add text before match
                    displayHtml += escapeHtml(originalText.substring(lastIndex, match.start));

                    // Add highlighted match with tooltip
                    displayHtml += createHighlightedSpan(match);

                    lastIndex = match.end;
                });

                // Add remaining text
                displayHtml += escapeHtml(originalText.substring(lastIndex));
            }

            textDisplay.innerHTML = displayHtml;

            // Switch UI: hide textarea, show display div
            textInput.classList.add('hidden');
            textDisplay.classList.add('visible');
            analyzeBtn.classList.add('hidden');
            document.getElementById('editBtn').classList.remove('hidden');
            clearBtn.classList.remove('hidden');
            document.getElementById('copyBtn').classList.remove('hidden');
            inputLabel.textContent = 'Analysis Results:';

            // Show stats
            resultsDiv.classList.remove('hidden');

            // Setup smart tooltip positioning
            setupTooltips();
        }

        /**
         * Generate matched term HTML if obfuscation is detected
         * DRY helper for both dog whistle and harmful term tooltips
         *
         * @param {string} matchedTerm - The canonical term that was matched
         * @param {string} displayedText - The actual text shown in the document
         * @param {string} label - Label to use ("Term" or "Derivation")
         * @returns {string} HTML string or empty string if no obfuscation
         */
        function getMatchedTermHtml(matchedTerm, displayedText, label = 'Term') {
            if (!matchedTerm) return '';

            // Check if obfuscation detected (case-insensitive comparison)
            const isObfuscated = matchedTerm.toLowerCase() !== displayedText.toLowerCase();

            if (!isObfuscated) return '';

            return `<div class="tooltip-item"><div class="tooltip-item-label">${label}:</div><div class="tooltip-item-value">${escapeHtml(matchedTerm)}</div></div>`;
        }

        /**
         * Format variations list, limiting to 6 random items if list is too long
         *
         * @param {Array<string>} variations - Array of variation strings
         * @returns {string} HTML string or empty string if no variations
         */
        function getVariationsHtml(variations) {
            if (!variations || variations.length === 0) return '';

            let displayVariations = variations;
            let label = 'Variations';

            // If more than 6 variations, select 6 random ones
            if (variations.length > 6) {
                // Shuffle and take first 6
                const shuffled = [...variations].sort(() => Math.random() - 0.5);
                displayVariations = shuffled.slice(0, 6);
                label = `Variations include`;
            }

            return `<div class="tooltip-item"><div class="tooltip-item-label">${label}:</div><div class="tooltip-item-value tooltip-variations">${escapeHtml(displayVariations.join(' / '))}</div></div>`;
        }

        function createHighlightedSpan(match) {
            const typeClass = match.type || 'dogwhistle';
            const categoryClass = getCategoryClass(match.category);
            const categoryColor = getCategoryColor(match.category);
            const formattedCategoryLabel = getFormattedCategoryLabel(match.category);
            const capitalizedDefinition = capitalizeFirst(match.definition);

            if (match.type === 'harmfulTerm') {
                // Harmful term
                const underlineStyle = `border-bottom: 3px solid ${categoryColor}; text-decoration: none;`;
                const sourceHtml = getTooltipSourceHtml(match.source);

                // Show matched term if obfuscation detected (DRY helper)
                const matchedTermHtml = getMatchedTermHtml(match.matchedTerm, match.text, 'Term');

                return `<span class="highlight harmfulTerm" style="${underlineStyle}">${escapeHtml(match.text)}<span class="tooltip"><div class="tooltip-category" style="background-color: ${categoryColor}">${escapeHtml(formattedCategoryLabel)}</div>${matchedTermHtml}<div class="tooltip-item"><div class="tooltip-item-label">Definition:</div><div class="tooltip-item-value">${escapeHtml(capitalizedDefinition)}</div></div>${sourceHtml}</span></span>`;
            } else {
                // Dog whistle
                const sourceHtml = getTooltipSourceHtml(match.source);

                // Determine what to show for the term
                let termHtml = '';
                if (match.isDerived) {
                    // Derived terms always show "Derivation: [root term]"
                    termHtml = `<div class="tooltip-item"><div class="tooltip-item-label">Derivation:</div><div class="tooltip-item-value">${escapeHtml(match.term)}</div></div>`;
                } else {
                    // Non-derived terms: show matched term only if obfuscated (DRY helper)
                    termHtml = getMatchedTermHtml(match.matchedTerm, match.text, 'Term');
                }

                // Limit variations to 6 random items if needed (DRY helper)
                const variationsHtml = getVariationsHtml(match.variations);

                return `<span class="highlight ${categoryClass} dogwhistle">${escapeHtml(match.text)}<span class="tooltip"><div class="tooltip-category" style="background-color: ${categoryColor}">${escapeHtml(formattedCategoryLabel)}</div>${termHtml}${variationsHtml}<div class="tooltip-item"><div class="tooltip-item-label">Dog Whistle:</div><div class="tooltip-item-value">${escapeHtml(capitalizedDefinition)}</div></div>${sourceHtml}</span></span>`;
            }
        }

        /**
        * Returns a tooltip-source string for a given source ID.
        *  Preserves the exact HTML structure you already have.
        */
        function getTooltipSourceHtml(sourceId) {
            if (!sourceId) {
                console.warn("Source id not present in data: " + sourceId);
                return `<div class="tooltip-source">Source: ERROR</div>`;
            }

            const sourceEntry = SOURCE_DATA.sources.find(s => s.id === sourceId);
            if (!sourceEntry) {
                console.warn(`Source id "${sourceId}" not found in SOURCE_DATA: ` + sourceId);
                return `<div class="tooltip-source">Source: ERROR</div>`;
            }

            const displayString = escapeHtml(sourceEntry.string || sourceId);

            if (sourceEntry.url) {
                return `<div class="tooltip-source">Source: ${displayString}</div>`;
            } else {
                return `<div class="tooltip-source">Source: ${displayString}</div>`;
            }
        }


        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function capitalizeFirst(text) {
            if (!text || text.length === 0) return text;
            return text.charAt(0).toUpperCase() + text.slice(1);
        }

        function setupTooltips() {
            const highlights = document.querySelectorAll('.highlight');

            highlights.forEach(highlight => {
                const tooltip = highlight.querySelector('.tooltip');
                if (!tooltip) return;

                // Position tooltip on mouseenter
                highlight.addEventListener('mouseenter', function (e) {
                    positionTooltip(highlight, tooltip);
                });
            });
        }

        function positionTooltip(highlight, tooltip) {
            // Get highlight position
            const highlightRect = highlight.getBoundingClientRect();
            const tooltipWidth = 320; // Match CSS width
            const tooltipHeight = tooltip.offsetHeight || 150; // Estimate if not rendered
            const margin = 10;
            const arrowHeight = 8;

            // Viewport dimensions
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            // Calculate initial centered position
            let left = highlightRect.left + (highlightRect.width / 2) - (tooltipWidth / 2);
            let top = highlightRect.top - tooltipHeight - arrowHeight - margin;

            // Reset classes
            tooltip.classList.remove('top', 'bottom', 'align-left', 'align-right');

            // Check if tooltip fits above
            if (top < margin) {
                // Place below instead
                top = highlightRect.bottom + arrowHeight + margin;
                tooltip.classList.add('bottom');
            } else {
                tooltip.classList.add('top');
            }

            // Check horizontal overflow
            if (left < margin) {
                // Align to left edge
                left = margin;
                tooltip.classList.add('align-left');
            } else if (left + tooltipWidth > viewportWidth - margin) {
                // Align to right edge
                left = viewportWidth - tooltipWidth - margin;
                tooltip.classList.add('align-right');
            }

            // Apply position
            tooltip.style.left = `${left}px`;
            tooltip.style.top = `${top}px`;
        }

        function clearAll() {
            const textInput = document.getElementById('textInput');
            const textDisplay = document.getElementById('textDisplay');
            const analyzeBtn = document.getElementById('analyzeBtn');
            const editBtn = document.getElementById('editBtn');
            const clearBtn = document.getElementById('clearBtn');
            const copyBtn = document.getElementById('copyBtn');
            const resultsDiv = document.getElementById('results');
            const inputLabel = document.getElementById('inputLabel');

            // Clear text
            textInput.value = '';
            textDisplay.innerHTML = '';
            originalAnalyzedText = ''; // Reset stored text

            // Switch UI back: show textarea, hide display div
            textInput.classList.remove('hidden');
            textDisplay.classList.remove('visible');
            analyzeBtn.classList.remove('hidden');
            analyzeBtn.disabled = true;
            clearBtn.disabled = true;
            copyBtn.disabled = true;
            editBtn.classList.add('hidden');
            inputLabel.textContent = 'Paste text to analyze:';

            // Hide stats
            resultsDiv.classList.add('hidden');
        }

        function copyText() {
            // Always copy from the textarea (which contains current editable text)
            const textToCopy = document.getElementById('textInput').value;
            if (!textToCopy.trim()) {
                return; // Nothing to copy
            }
            // Use the Clipboard API
            navigator.clipboard.writeText(textToCopy).then(() => {
                // visual feedback
                const copyBtn = document.getElementById('copyBtn');
                // Temporarily override background with disabled color
                copyBtn.style.background = 'var(--btn-clicked-bg)';
                setTimeout(() => {
                    copyBtn.style.background = '';
                }, buttonClickTimeout);

            }).catch(err => {
                console.error('Failed to copy text:', err);
                alert('Failed to copy text to clipboard');
            });
        }

        function trackAnalysis(text, results) {
            // TODO: Implement analytics tracking
            // Track metrics:
            // 1. Total analyses performed
            // 2. Detection rate
            // 3. Average text length
            // 4. Terms detected distribution
            // 5. Return user rate (localStorage)
            // 6. Country-level data (IP geolocation)
            // 7. Time-based patterns

            // console.log('Analytics placeholder:', {
            //     textLength: text.length,
            //     matchCount: results.matches.length,
            //     categories: results.categories
            // });
        }

        // Allow Enter key to submit (with Ctrl/Cmd)
        document.getElementById('textInput').addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                analyzeText();
            }
        });

        // Enable/disable buttons based on text content
        document.getElementById('textInput').addEventListener('input', (e) => {
            const analyzeBtn = document.getElementById('analyzeBtn');
            const copyBtn = document.getElementById('copyBtn');
            const clearBtn = document.getElementById('clearBtn');
            const textInput = document.getElementById('textInput');

            if (textInput.value.trim()) {
                analyzeBtn.disabled = false;
                copyBtn.disabled = false;
                clearBtn.disabled = false;
            } else {
                analyzeBtn.disabled = true;
                copyBtn.disabled = true;
                clearBtn.disabled = true;
            }
        });

        // Reposition tooltips on window resize or scroll
        let tooltipRepositionTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(tooltipRepositionTimeout);
            tooltipRepositionTimeout = setTimeout(() => {
                // Reposition any visible tooltips
                document.querySelectorAll('.highlight:hover').forEach(highlight => {
                    const tooltip = highlight.querySelector('.tooltip');
                    if (tooltip) {
                        positionTooltip(highlight, tooltip);
                    }
                });
            }, 100);
        });

        window.addEventListener('scroll', () => {
            // Reposition tooltips on scroll (since they use fixed positioning)
            document.querySelectorAll('.highlight:hover').forEach(highlight => {
                const tooltip = highlight.querySelector('.tooltip');
                if (tooltip) {
                    positionTooltip(highlight, tooltip);
                }
            });
        }, { passive: true });
    </script>
</body>

</html>