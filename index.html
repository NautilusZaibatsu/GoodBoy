<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üêï GoodBoy - Sniffing out coded language</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--bg-page);
            background-image: url('images/page_background.png');
            background-repeat: repeat;
            min-height: 100vh;
            padding: var(--spacing-xl);
            color: var(--text-primary);
        }

        a:link {
            color: var(--link-unvisited);
        }

        a:visited {
            color: var(--link-visited);
        }

        a:hover {
            color: var(--link-hover);
        }

        a:active {
            color: var(--link-active);
        }

        p {
            margin-bottom: 1rem;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            color: var(--text-white);
            margin-bottom: var(--spacing-sm);
        }

        h1 {
            font-size: var(--font-size-xxl);
            margin-bottom: var(--spacing-sm);
            text-shadow: 2px 2px 4px var(--shadow-light);
        }

        .betaText {
            font-size: var(--font-size-sm);
            margin-left: var(--spacing-sm);
            margin-top: 0.5em;
            font-weight: var(--weight-normal);
            display: inline-block;
            vertical-align: top;
        }

        .tagline {
            font-size: var(--font-size-lg);
            opacity: 0.95;
            margin-top: var(--spacing-tagline);
        }

        #ticker-container {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: var(--bg-ticker);
            color: var(--text-ticker);
            font-size: var(--font-size-sm);
            white-space: nowrap;
            overflow: hidden;
            height: 30px;
            display: flex;
            align-items: center;
            z-index: 9999;
        }

        #ticker-wrapper {
            display: inline-flex;
        }

        #ticker-text,
        #ticker-text-duplicate {
            display: inline-block;
            white-space: nowrap;
            padding-right: 15px;
            padding-left: var(--spacing-md);
        }

        #ticker-text:hover {
            animation-play-state: paused;
        }

        /* Keyframes for ticker */
        /* move by half, then loop */
        @keyframes scroll {
            0% {
                transform: translateX(0);
            }

            100% {
                transform: translateX(-50%);
            }
        }

        .card {
            background: var(--bg-card);
            border-radius: var(--radius-xl);
            padding: var(--spacing-xxl);
            box-shadow: 0 10px 40px var(--shadow-light);
        }

        .input-section {
            margin-bottom: var(--spacing-xl);
        }

        label {
            display: block;
            font-weight: var(--font-weight-semibold);
            margin-bottom: var(--spacing-sm);
            color: var(--text-secondary);
        }

        #textInput {
            width: 100%;
            min-height: 200px;
            padding: var(--spacing-lg);
            border: 2px solid var(--border-default);
            border-radius: var(--radius-lg);
            font-size: var(--font-size-md);
            font-family: inherit;
            resize: vertical;
            transition: border-color 0.3s;
            display: block;
        }

        #textInput:focus {
            outline: none;
            border-color: var(--border-focus);
        }

        #textInput.hidden {
            display: none;
        }

        #textDisplay {
            display: none;
            width: 100%;
            min-height: 200px;
            padding: var(--spacing-lg);
            border: 2px solid var(--color-primary);
            border-radius: var(--radius-lg);
            font-size: var(--font-size-md);
            font-family: inherit;
            background: var(--bg-input);
            line-height: 1.8;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        #textDisplay.visible {
            display: block;
        }

        .button-row {
            display: flex;
            gap: var(--spacing-sm);
            align-items: center;
        }

        button {
            background: var(--btn-primary-bg);
            color: var(--btn-primary-text);
            border: none;
            padding: var(--spacing-md) var(--spacing-xxl);
            border-radius: var(--radius-lg);
            font-size: var(--font-size-md);
            font-weight: var(--font-weight-semibold);
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px var(--shadow-medium);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled,
        .copy-btn:disabled,
        .clear-btn:disabled {
            background: var(--btn-disabled-bg) !important;
            color: var(--btn-disabled-text) !important;
            cursor: not-allowed;
            pointer-events: auto;
            opacity: 1;
            transform: none;
            box-shadow: none;
        }

        .clear-btn {
            background: var(--btn-primary-bg);
            color: var(--btn-primary-text);
        }

        .copy-btn {
            background: var(--btn-primary-bg);
            color: var(--btn-primary-text);
        }

        .hidden {
            display: none !important;
        }

        #results {
            margin-top: var(--spacing-xl);
        }

        .stats-row {
            display: flex;
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-xl);
            flex-wrap: wrap;
        }

        .stat-box {
            flex: 1;
            min-width: 150px;
            padding: var(--spacing-md);
            background: var(--bg-input);
            border-radius: var(--radius-lg);
            text-align: center;
        }

        .stat-value {
            font-size: var(--font-size-xl);
            font-weight: var(--font-weight-bold);
            color: var(--color-primary);
            margin-bottom: var(--spacing-xs);
        }

        .stat-label {
            font-size: var(--font-size-sm);
            color: var(--text-muted);
        }

        .signal-indicator {
            display: inline-block;
            margin-top: var(--spacing-xs);
            padding: var(--spacing-xs) var(--spacing-sm);
            border-radius: var(--radius-xl);
            font-size: var(--font-size-xxs);
            font-weight: var(--font-weight-semibold);
            text-transform: uppercase;
        }

        .signal-low {
            background-color: var(--state-success-bg);
            color: var(--state-success-text);
        }

        .signal-moderate {
            background-color: var(--state-warning-bg);
            color: var(--state-warning-text);
        }

        .signal-high {
            background-color: var(--state-danger-bg);
            color: var(--state-danger-text);
        }

        .signal-severe {
            background-color: var(--state-danger-border);
            color: var(--text-white);
        }

        .info-icon {
            display: inline-block;
            margin-left: var(--spacing-sm);
            cursor: help;
            opacity: 0.6;
            font-size: var(--font-size-sm);
        }

        .info-icon:hover {
            opacity: 1;
        }

        .signal-placeholder {
            background: var(--state-warning-bg);
            border-left: 4px solid var(--state-warning-border);
            padding: var(--spacing-lg);
            border-radius: var(--radius-md);
            margin-bottom: var(--spacing-xl);
        }

        .no-results {
            padding: var(--spacing-lg);
            background: var(--state-success-bg);
            border-left: 4px solid var(--state-success-border);
            border-radius: var(--radius-md);
            color: var(--state-success-text);
            font-weight: var(--font-weight-semibold);
            margin-top: var(--spacing-sm);
        }

        .highlight {
            padding: var(--spacing-xs) 0;
            border-radius: var(--radius-sm);
            cursor: help;
            position: relative;
            transition: background-color 0.2s;
        }

        /* Category-specific highlight colors will be injected dynamically */

        /* coded terms: Background color, NO underline */
        .highlight.codedTerm {
            text-decoration: none;
        }

        /* Harmful terms: ONLY underline, NO background color */
        .highlight.harmfulTerm {
            background-color: transparent !important;
            text-decoration: none;
        }

        .tooltip {
            position: fixed;
            background: var(--bg-tooltip);
            color: var(--text-white);
            padding: var(--spacing-md);
            border-radius: var(--radius-lg);
            width: 320px;
            max-width: 90vw;
            box-shadow: 0 5px 20px var(--shadow-light);
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .highlight:hover .tooltip {
            opacity: 1;
            pointer-events: auto;
        }

        /* Mobile touch visibility control */
        .tooltip.tooltip-touch-active {
            opacity: 1 !important;
            pointer-events: auto !important;
        }

        /* Tooltip arrow - default (pointing down from top tooltip) */
        .tooltip::after {
            content: '';
            position: absolute;
            border: 8px solid transparent;
        }

        /* Default: tooltip above, arrow points down */
        .tooltip.top::after {
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border-top-color: var(--bg-tooltip);
        }

        /* Tooltip below, arrow points up */
        .tooltip.bottom::after {
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            border-bottom-color: var(--bg-tooltip);
        }

        /* Arrow on left when tooltip is aligned right */
        .tooltip.align-left::after {
            left: 20px;
        }

        /* Arrow on right when tooltip is aligned left */
        .tooltip.align-right::after {
            left: auto;
            right: 20px;
            transform: translateX(0);
        }

        .tooltip-category {
            display: block;
            padding: var(--spacing-sm) var(--spacing-md);
            margin: calc(-1 * var(--spacing-md)) calc(-1 * var(--spacing-md)) var(--spacing-sm) calc(-1 * var(--spacing-md));
            border-radius: var(--radius-lg) var(--radius-lg) 0 0;
            font-size: var(--font-size-xxs);
            font-weight: var(--font-weight-semibold);
            text-transform: uppercase;
            text-align: center;
            color: var(--text-white);
        }

        .category-badge {
            display: block;
            padding: var(--spacing-xs) var(--spacing-sm);
            border-radius: var(--radius-md);
            font-size: var(--font-size-xs);
            font-weight: var(--font-weight-semibold);
            margin: var(--spacing-xs) 0;
            color: var(--text-white);
        }

        .tooltip-item {
            margin-bottom: var(--spacing-sm);
            font-size: var(--font-size-xs);
            line-height: 1.3;
        }

        .tooltip-item:last-child {
            margin-bottom: 0;
        }

        .tooltip-item-label {
            font-weight: var(--font-weight-bold);
            color: var(--text-white);
            margin-bottom: var(--spacing-xs);
            font-size: var(--font-size-sm);
        }

        .tooltip-item-value {
            color: var(--tooltip-text);
            line-height: 1.4;
        }

        .tooltip-variations {
            color: var(--tooltip-text-muted);
            font-style: italic;
        }

        .tooltip-source {
            margin-top: var(--spacing-sm);
            padding-top: var(--spacing-sm);
            border-top: 1px solid var(--tooltip-border);
            font-size: var(--font-size-tiny);
            color: var(--tooltip-text-muted);
        }

        .tooltip-source a {
            color: var(--link-tooltip);
            text-decoration: none;
        }

        .tooltip-source a:hover {
            text-decoration: underline;
        }

        footer {
            margin-top: var(--spacing-sm);
            padding: var(--spacing-xl);
            background: var(--bg-footer-overlay);
            border-radius: var(--radius-xl);
            font-size: var(--font-size-sm);
            color: var(--text-muted);
        }

        .expandable-div {
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            user-select: none;
            padding: var(--spacing-xs) 0;
        }

        .expandable-div h3 {
            color: var(--text-primary);
            margin: 0;
            font-size: 1.1em;
        }

        .expand-div-toggle {
            font-size: 1.2em;
            transition: transform 0.3s;
            color: var(--btn-primary-bg);
        }

        .expand-div-toggle.expanded {
            transform: rotate(180deg);
        }

        .expandable-div-content {
            display: none;
            margin-top: var(--spacing-lg);
        }

        .expandable-div-content.visible {
            display: block;
        }

        footer a {
            color: var(--link-unvisited);
            text-decoration: none;
        }

        footer a:hover {
            text-decoration: underline;
        }

        .loading {
            display: none;
            color: var(--color-primary);
            font-weight: var(--font-weight-semibold);
        }

        .loading.visible {
            display: inline;
        }

        @media (max-width: 600px) {
            h1 {
                font-size: var(--font-size-xl);
            }

            .stats-row {
                flex-direction: column;
            }

            .tooltip {
                width: 280px;
            }

            /* Responsive button styling for mobile */
            .button-row {
                flex-wrap: wrap;
                gap: var(--spacing-xs);
                /* Reduce gap from 8px to 4px */
            }

            button {
                padding: var(--spacing-sm) var(--spacing-md);
                /* 8px 12px instead of 12px 30px */
                font-size: var(--font-size-sm);
                /* 0.9em instead of 1em */
                flex: 1 1 auto;
                /* Allow flexible sizing */
                min-width: 70px;
                /* Prevent buttons from becoming too small */
            }

            .loading {
                width: 100%;
                /* Force loading text to new line */
                text-align: center;
                margin-top: var(--spacing-xs);
            }
        }
    </style>
</head>

<body>
    <div id="ticker-container">
        <div id="ticker-wrapper">
            <div id="ticker-text"></div>
            <div id="ticker-text-duplicate"></div>
        </div>
    </div>
    <div class="container">
        <header>
            <div style="display: inline-flex; align-items: flex-start; justify-content: center;">
                <h1>üêï GoodBoy<span class="betaText"></h1>beta</span>
            </div>
            <p class="tagline">
                Sniffing out coded language
            </p>
        </header>

        <div class="card">
            <div class="input-section">
                <label for="textInput" id="inputLabel">Text to analyze:</label>
                <textarea id="textInput"
                    placeholder="Enter or paste text here to check for coded and harmful language..."></textarea>
                <div id="textDisplay"></div>
            </div>

            <div class="button-row">
                <button id="analyzeBtn" onclick="analyzeText()">Analyze</button>
                <button class="hidden" id="editBtn" onclick="editText()">Edit</button>
                <button class="copy-btn" id="copyBtn" onclick="copyText()">Copy</button>
                <button class="clear-btn" id="clearBtn" onclick="clearAll()">Clear</button>
                <span class="loading" id="loading">Analyzing...</span>
            </div>

            <div id="results" class="hidden">
                <div class="stats-row">
                    <div class="stat-box">
                        <div class="stat-value" id="termCount">0</div>
                        <div class="stat-label">Terms Flagged</div>
                        <div id="termBreakdown" style="margin-top: 8px; font-size: 0.75em; color: var(--color-muted);">
                        </div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="mainCategoryCount">0</div>
                        <div class="stat-label">Main Categories</div>
                        <div id="mainCategoryList" style="margin-top: 10px; font-size: 0.85em; text-align: left;"></div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="subCategoryCount">0</div>
                        <div class="stat-label">Subcategories</div>
                        <div id="subCategoryList" style="margin-top: 10px; font-size: 0.85em; text-align: left;"></div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="signalScore">0%</div>
                        <div class="stat-label">Signal Score</div>
                        <div id="signalIndicator"></div>
                    </div>
                </div>
            </div>
        </div>

        <footer>
            <div class="expandable-div" onclick="toggleSection('instructionContent')">
                <h3>Help</h3>
                <span class="expand-div-toggle">‚ñº</span>
            </div>
            <div class="expandable-div-content" id="instructionContent">
                <table style="width: 100%">
                    <tr>
                        <td style="width: 70%; vertical-align:top">
                            <h3>Instructions</h3>
                            <p>
                                <br>
                                <b>1.</b> Type or paste your text into the input area.<br>
                                <b>2.</b> Click 'Analyze'.<br>
                                <b>3.</b> Hover over or touch highlighted / underlined terms to see their meanings.
                                <br>
                                On touch enabled devices, touch anywhere other than the term to close the tooltip.
                                <br>
                                Highlighting indicates potentially coded language, underlining indicates a potentially
                                harmful term.
                                <br>
                                The highlight / underling color denotes the category (see legend).<br>
                                <b>4.</b> Check the signal score to see how much coded or harmful language appears.
                                <br>
                                <b>5.</b> Hover over or touch the ‚ìò icon for signal score calculation details.
                            </p>
                            <p>
                                <b>Notes:</b>
                            <p>
                                A high signal score doesn't automatically indicate harmful intent.
                            </p>
                            <p>
                                There is often considerable crossover between categories, we have done our best to
                                categorise broadly however due to the nature of coded language it is difficult to be
                                absolute. Use context clues in the text to help you decipher intent.
                            </p>
                            </p>
                        </td>
                        <td
                            style="padding-left: var(--spacing-lg); padding-right: var(--spacing-lg); vertical-align:top">
                            <h3>Legend</h3>
                            <div id="legend"></div>
                        </td>
                    </tr>
                </table>
            </div>
        </footer>

        <footer>
            <div class="expandable-div" onclick="toggleSection('aboutContent')">
                <h3>About</h3>
                <span class="expand-div-toggle">‚ñº</span>
            </div>
            <div class="expandable-div-content" id="aboutContent">
                <p>
                    GoodBoy is a free, open-source tool for identifying coded terms and harmful language, designed to
                    promote understanding of coded rhetoric and help users recognise hateful or discriminatory content.
                </p>
                <p>
                    All analysis happens locally in your browser ‚Äî no data is sent anywhere.
                </p>
                <p>
                    We built GoodBoy to support social awareness and understanding, so it‚Äôs made to be free,
                    privacy-respecting, lightweight, and easy to use in any browser. The goal is simple: make the tool
                    as accessible and frictionless as possible so more people can learn to spot coded language.
                </p>
                <p>
                    Database: <strong><span id="dbTermCount">Loading...</span></strong>
                </p>
                <p>
                    Created by the GoodBoy Team | <a href=https://ko-fi.com/nautiluszaibatsu> Support this project ‚Üó</a>
                    <br>
                    Contributions welcome via the <a href=https://github.com/NautilusZaibatsu/GoodBoy> GitHub
                        Repository ‚Üó</a>
                </p>
                <p>
                    License: Source-Available. ¬© GoodBoy 2026
                    <br>
                    Free to use. No redistribution, modification, or re-hosting permitted.
                    <br>
                </p>
            </div>
        </footer>

        <footer>
            <div class="expandable-div" onclick="toggleSection('attributionContent')">
                <h3>Sources</h3>
                <span class="expand-div-toggle">‚ñº</span>
            </div>
            <div class="expandable-div-content" id="attributionContent">

                <div id="dataset-attributions"></div>

            </div>
        </footer>
    </div>

    <!-- Load the coded term database -->
    <script src="data/coded_term_data.js"></script>

    <!-- Load the harmful term database -->
    <script src="data/harmful_term_data.js"></script>

    <!-- Load the source  database -->
    <script src="data/source_data.js"></script>

    <!-- Load number obfuscation utilities (must load before obfuscation-utils.js) -->
    <script src="js/number-obfuscation-utils.js"></script>

    <!-- Load shared obfuscation utilities (DRY - single source of truth) -->
    <script src="js/obfuscation-utils.js"></script>
    <script src="js/matchers.js"></script>

    <!-- Load theme configuration (design system) -->
    <script src="js/theme-config.js"></script>

    <!-- Load the ticker -->
    <script src="js/ticker.js"></script>

    <!-- Load category hierarchy (shared with dev-tools) -->
    <script src="js/category-config.js"></script>

    <!-- Load signal score calculator module -->
    <script src="js/signal-score.js"></script>

    <!-- Load religionym lookup -->
    <script src="data/religionym_lookup.js"></script>

    <!-- Load unified place-demonym lookup -->
    <script src="data/place_demonym_lookup.js"></script>

    <!-- Main application logic -->
    <script>
        // Initialize the ticker
        initTicker();

        // Initialize and render the attributions
        renderAttributions();
        // Initialize the pattern matchers
        let matcher = null;
        let harmfulTermMatcher = null;

        // Store original text for re-analysis
        let originalAnalyzedText = '';

        // Initialize the legend for the how to section
        const legendDiv = document.getElementById('legend');
        let legendHtml = '';

        Object.entries(CATEGORY_HIERARCHY).forEach(([slug, cat]) => {
            legendHtml += `<span class="category-badge" style="background-color: ${cat.darkColor}">${cat.label}</span>`;
        });
        legendDiv.innerHTML = legendHtml;

        // Initialize matchers when data is loaded
        const codedTermData = typeof GOODBOY_DATA !== 'undefined' ? GOODBOY_DATA : null;
        const harmfulTermData = typeof GOODBOY_HARMFUL_TERM_DATA !== 'undefined' ? GOODBOY_HARMFUL_TERM_DATA : null;

        if (codedTermData) {
            matcher = new CodedTermMatcher(codedTermData);
        } else {
            console.error('Error: Failed to load coded term database.');
        }

        if (harmfulTermData) {
            harmfulTermMatcher = new HarmfulTermMatcher(harmfulTermData);
        } else {
            console.error('Error: Failed to load harmful term database.');
        }

        // Initialize pattern matcher for populist detection
        if (codedTermData && typeof PLACE_DEMONYM_LOOKUP !== 'undefined') {
            PatternMatcher.initialize(codedTermData.terms);
            console.log('‚úì Pattern matcher initialized for populist detection');
        } else if (typeof PLACE_DEMONYM_LOOKUP === 'undefined') {
            console.warn('Place-demonym lookup not loaded, populist pattern matching disabled');
        }

        if (!codedTermData && !harmfulTermData) {
            alert('Error: Failed to load databases. Please refresh the page.');
        }

        // Theme configuration loaded from js/theme-config.js

        /**
         * POPULIST PATTERN MATCHING SYSTEM
         *
         * Detects nationalist, regionalist and localist language patterns by recognizing place/group names
         * and checking if similar patterns exist in the coded term database with different places.
         *
         * Example: If database contains "America First", it will also flag "Britain First",
         * "Make Liverpool Great Again" (from "MAGA"), "hard-working Indians" (from "hard-working Americans")
         *
         * Hybrid Categorization:
         * - Dynamic patterns with nationalist/regionalist/localist category ‚Üí auto-categorize by place type:
         *   - Countries ‚Üí Nationalist
         *   - Regions  ‚Üí Regionalist
         *   - Regions/cities ‚Üí Localist
         * - Dynamic patterns with other categories (racist, antisemitic, etc.) ‚Üí preserve original category
         */

        // Build reverse mapping: subcategory -> main category
        const SUBCATEGORY_TO_MAIN = {};
        Object.keys(CATEGORY_HIERARCHY).forEach(mainKey => {
            const mainCat = CATEGORY_HIERARCHY[mainKey];
            Object.keys(mainCat.sub).forEach(subKey => {
                SUBCATEGORY_TO_MAIN[subKey] = mainKey;
            });
        });

        function renderAttributions() {
            const container = document.getElementById('dataset-attributions');
            container.innerHTML = ''; // Clear previous content if any

            SOURCE_DATA.sources.forEach(source => {
                // Dataset title
                const text = document.createTextNode(source.description || source.string || source.id);
                container.appendChild(text);
                // Prepare links
                const links = [];
                if (source.url) {
                    const a = document.createElement('a');
                    a.href = source.url;
                    a.target = '_blank';
                    a.rel = 'noopener';
                    a.textContent = ' ‚Üó';
                    links.push(a);
                }
                if (source.paper) {
                    const a = document.createElement('a');
                    a.href = source.paper;
                    a.target = '_blank';
                    a.rel = 'noopener';
                    a.textContent = 'Read Paper ‚Üó';
                    links.push(a);
                }

                if (links.length > 0) {
                    container.appendChild(document.createTextNode(' ')); // space after title
                    links.forEach((link, idx) => {
                        container.appendChild(link);
                        if (idx < links.length - 1) {
                            container.appendChild(document.createTextNode(' | '));
                        }
                    });
                }

                // Line break after each source
                container.appendChild(document.createElement('br'));
            });
        }


        // Helper to get main category for a subcategory
        function getMainCategory(subcategory) {
            return SUBCATEGORY_TO_MAIN[subcategory?.toLowerCase()] || null;
        }
        // Default colors for unknown categories
        const DEFAULT_COLORS = {
            lightColor: "var(--color-primary)",
            hoverColor: "var(--color-primary)",
            darkColor: "var(--color-primary)"
        };

        // Inject dynamic CSS for MAIN category colors (used for highlighting)
        function injectCategoryStyles() {
            const styleEl = document.createElement('style');
            let css = '';

            // Generate CSS for each MAIN category
            Object.keys(CATEGORY_HIERARCHY).forEach(mainKey => {
                const mainCat = CATEGORY_HIERARCHY[mainKey];
                const className = mainKey.toLowerCase().replace(/\s+/g, '-');

                css += `
                    .highlight.${className} {
                        background-color: ${mainCat.lightColor};
                    }
                    .highlight.${className}:hover {
                        background-color: ${mainCat.hoverColor};
                    }
                `;
            });

            // Add default "other" category
            css += `
                .highlight.other {
                    background-color: ${DEFAULT_COLORS.lightColor};
                }
                .highlight.other:hover {
                    background-color: ${DEFAULT_COLORS.hoverColor};
                }
            `;

            styleEl.textContent = css;
            document.head.appendChild(styleEl);
        }

        // Get the subcategory label and color
        function getSubcategoryInfo(subcategory) {
            const mainKey = getMainCategory(subcategory);
            if (!mainKey) return null;

            const mainCat = CATEGORY_HIERARCHY[mainKey];
            const subInfo = mainCat.sub[subcategory.toLowerCase()];

            return subInfo ? {
                label: subInfo.label,
                darkColor: subInfo.darkColor,
                mainLabel: mainCat.label,
                mainKey: mainKey
            } : null;
        }

        // Get the color for a category (returns subcategory color for tooltips)
        function getCategoryColor(subcategory) {
            const info = getSubcategoryInfo(subcategory);
            return info ? info.darkColor : DEFAULT_COLORS.darkColor;
        }

        // Get the CSS class for highlighting (uses MAIN category)
        function getCategoryClass(subcategory) {
            const mainKey = getMainCategory(subcategory);
            if (!mainKey) return 'other';
            return mainKey.toLowerCase().replace(/\s+/g, '-');
        }

        // Get formatted label for tooltip: "Main : Sub"
        function getFormattedCategoryLabel(subcategory) {
            const info = getSubcategoryInfo(subcategory);
            if (!info) return subcategory;
            return `${info.mainLabel} : ${info.label}`;
        }

        /**
         * Filter redundant variations from database terms
         * Uses ObfuscationUtils to detect and remove variations that our pattern matcher
         * will catch anyway (punctuation, case, hyphenation, plurals, etc.)
         *
         * This maintains DRY by using the SAME logic that our pattern matcher uses,
         * rather than duplicating it in Python.
         */
        function filterRedundantVariations(terms) {
            let totalRemoved = 0;
            const filtered = terms.map(term => {
                const root = term.root;
                const variations = term.variations || [];
                const originalCount = variations.length;

                // Track unique normalized forms to detect duplicates
                const seenNormalized = new Set();

                // Normalize and track root
                const rootNorm = ObfuscationUtils.normalizeText(root);
                const rootClean = rootNorm.replace(/[\s\-_]/g, '');
                seenNormalized.add(rootClean);

                // Filter variations
                const kept = variations.filter(variation => {
                    // Skip exact duplicates of root (case-insensitive)
                    if (variation.toLowerCase() === root.toLowerCase()) {
                        console.log("üßπ Filtered term: " + variation);
                        return false;
                    }

                    // Skip if it's a punctuation/case/hyphenation variant of root
                    // BUT: only if the variation isn't a meaningful shorter form
                    // Example: "inner-city" is redundant with "inner city" (filter out)
                    // Example: "13" is NOT redundant with "13%" (keep it - it's a meaningful form)
                    if (ObfuscationUtils.isPunctuationVariant(variation, root)) {
                        // Check if variation is shorter - if so, it might be a meaningful abbreviation
                        // Only filter if they're the same length (just different punctuation)
                        if (variation.length >= root.length) {
                            console.log("üßπ Filtered term: " + variation);
                            return false;
                        }
                        // Variation is shorter - keep it as it's likely a meaningful form
                    }

                    // Check for duplicate normalized forms
                    const varNorm = ObfuscationUtils.normalizeText(variation);
                    const varClean = varNorm.replace(/[\s\-_]/g, '');

                    if (seenNormalized.has(varClean)) {
                        // Already seen this normalized form
                        // BUT: if this variation is shorter than the root, keep it (meaningful abbreviation)
                        // Example: "13" should be kept even though "13%" normalizes to the same thing
                        if (variation.length >= root.length) {
                            console.log("üßπ Filtered term: " + variation);
                            return false;
                        }
                        // Variation is shorter - keep it
                    }

                    // Check if this is a plural of root or another kept variation
                    if (variation.endsWith('s') && variation.length > 1) {
                        const singular = variation.slice(0, -1);
                        const singularClean = ObfuscationUtils.normalizeText(singular).replace(/[\s\-_]/g, '');

                        // Skip if plural of root
                        if (singularClean === rootClean) {
                            console.log("üßπ Filtered term: " + variation);
                            return false;
                        }

                        // Skip if plural of a variation we're keeping
                        if (seenNormalized.has(singularClean)) {
                            console.log("üßπ Filtered term: " + variation);
                            return false;
                        }
                    }

                    // Keep this variation and track its normalized form
                    seenNormalized.add(varClean);
                    return true;
                });

                totalRemoved += originalCount - kept.length;

                return { ...term, variations: kept };
            });

            if (totalRemoved > 0) {
                console.log(`‚úì Filtered out ${totalRemoved} redundant variations (punctuation, case, plurals, etc.)`);
            }

            return filtered;
        }

        // Load and prepare data on page load
        window.addEventListener('DOMContentLoaded', () => {
            // Initialize theme (inject CSS custom properties)
            initializeTheme();

            // Inject category-specific CSS styles
            injectCategoryStyles();

            // Set initial disabled state for buttons
            document.getElementById('analyzeBtn').disabled = true;
            document.getElementById('copyBtn').disabled = true;
            document.getElementById('clearBtn').disabled = true;

            let codedTermData = null;
            let harmfulTermData = null;

            // Check coded term database
            if (typeof GOODBOY_DATA !== 'undefined') {
                // Filter redundant variations using our pattern matching logic
                const filteredTerms = filterRedundantVariations(GOODBOY_DATA.terms);
                codedTermData = {
                    ...GOODBOY_DATA,
                    terms: filteredTerms
                };
                console.log(`‚úì Loaded ${GOODBOY_DATA.total} coded terms`);
            } else {
                console.error('Failed to load coded term database');
            }

            // Check harmful term database
            if (typeof GOODBOY_HARMFUL_TERM_DATA !== 'undefined') {
                // Filter redundant variations using our pattern matching logic
                const filteredHarmfulTerms = filterRedundantVariations(GOODBOY_HARMFUL_TERM_DATA.terms);
                harmfulTermData = {
                    ...GOODBOY_HARMFUL_TERM_DATA,
                    terms: filteredHarmfulTerms
                };
                console.log(`‚úì Loaded ${GOODBOY_HARMFUL_TERM_DATA.uniqueTerms} harmful terms`);
            } else {
                console.error('Failed to load harmful term database');
            }

            // Update database term count in footer
            const dbTermCountEl = document.getElementById('dbTermCount');
            if (dbTermCountEl) {
                const codedTermCount = codedTermData ? codedTermData.totalTerms : 0;
                const harmfulTermCount = harmfulTermData ? harmfulTermData.totalTerms : 0;

                if (codedTermCount > 0 && harmfulTermCount > 0) {
                    const harmfulTermText = harmfulTermCount === 1 ? 'harmful term' : 'harmful terms';
                    dbTermCountEl.textContent = `${codedTermCount} coded terms and ${harmfulTermCount} ${harmfulTermText}`;
                } else if (codedTermCount > 0) {
                    dbTermCountEl.textContent = `${codedTermCount} coded terms`;
                } else if (harmfulTermCount > 0) {
                    const harmfulTermText = harmfulTermCount === 1 ? 'harmful term' : 'harmful terms';
                    dbTermCountEl.textContent = `${harmfulTermCount} ${harmfulTermText}`;
                } else {
                    dbTermCountEl.textContent = 'Error loading';
                }
            }

            // Initialize matchers with the databases
            if (codedTermData) {
                matcher = new CodedTermMatcher(codedTermData);
            } else {
                console.error('Error: Failed to load coded term database.');
            }

            if (harmfulTermData) {
                harmfulTermMatcher = new HarmfulTermMatcher(harmfulTermData);
            } else {
                console.error('Error: Failed to load harmful term database.');
            }

            // Initialize pattern matcher for populist detection
            if (codedTermData && typeof PLACE_DEMONYM_LOOKUP !== 'undefined') {
                PatternMatcher.initialize(codedTermData.terms);
                console.log('‚úì Pattern matcher initialized for populist detection');
            } else if (typeof PLACE_DEMONYM_LOOKUP === 'undefined') {
                console.warn('Place-demonym lookup not loaded, populist pattern matching disabled');
            }

            if (!codedTermData && !harmfulTermData) {
                alert('Error: Failed to load databases. Please refresh the page.');
            }
        });

        function editText() {
            // User clicked "Edit Text" button - restore editable state
            clearAnalysisHighlights();
        }

        // Helper function to toggle a section of the page
        function toggleSection(div_section) {
            const content = document.getElementById(div_section);
            const toggle = document.querySelector('.expand-div-toggle');
            content.classList.toggle('visible');
            toggle.classList.toggle('expanded');
        }

        function clearAnalysisHighlights() {
            const textInput = document.getElementById('textInput');
            const textDisplay = document.getElementById('textDisplay');
            const analyzeBtn = document.getElementById('analyzeBtn');
            const editBtn = document.getElementById('editBtn');
            const resultsDiv = document.getElementById('results');
            const inputLabel = document.getElementById('inputLabel');

            // Check if analysis is currently displayed
            if (textDisplay.classList.contains('visible') && originalAnalyzedText) {
                // Put original text back into the editable textarea
                textInput.value = originalAnalyzedText;

                // Switch from display div back to editable textarea
                textDisplay.classList.remove('visible');
                textDisplay.innerHTML = '';
                textInput.classList.remove('hidden');

                // Update label
                inputLabel.textContent = 'Text to analyze:';

                // Show Analyze button, hide Edit button (keep Clear button visible)
                analyzeBtn.classList.remove('hidden');
                analyzeBtn.disabled = false;
                editBtn.classList.add('hidden');

                // Hide results stats
                resultsDiv.classList.add('hidden');
            }
        }

        let analyzedYet = false;

        function analyzeText() {

            const textInput = document.getElementById('textInput');

            // Always get text from textarea (it's editable)
            const text = textInput.value.trim();

            if (!text) {
                alert('Please enter some text to analyze.');
                return;
            }

            if (!matcher && !harmfulTermMatcher) {
                alert('Databases not loaded. Please refresh the page.');
                return;
            }

            // Store original text for potential editing
            originalAnalyzedText = text;

            // Show loading state
            document.getElementById('loading').classList.add('visible');
            document.getElementById('analyzeBtn').disabled = true;

            // Use setTimeout to allow UI to update
            setTimeout(() => {
                // Analyze with both matchers
                const codedTermResults = matcher ? matcher.analyze(text) : { matches: [], categoryCount: 0, categories: [] };
                const harmfulTermResults = harmfulTermMatcher ? harmfulTermMatcher.analyze(text) : { matches: [], categoryCount: 0, categories: [] };

                // Analyze for populist patterns
                const patternResults = PatternMatcher.place_demonym_lookup_loaded ? PatternMatcher.analyze(text) : { matches: [] };

                // Combine results (pattern matches are also coded terms)
                const allMatches = [
                    ...codedTermResults.matches,
                    ...harmfulTermResults.matches,
                    ...patternResults.matches
                ];

                allMatches.sort((a, b) => {
                    if (b.end - b.start !== a.end - a.start) {
                        return (b.end - b.start) - (a.end - a.start); // Sort by length (longest first)
                    }
                    return a.start - b.start; // If same length, sort by position
                });

                const combinedMatches = [];
                const usedRanges = [];

                // Check if we have deliberated split a match into segments, such as from emoji-split terms so we can deduplicate
                // e.g., "False" and "Flag" from "FalseüêëFlag"
                for (const match of allMatches) {
                    let hasOverlap = false;

                    for (const range of usedRanges) {
                        if (match.start < range.end && match.end > range.start) {
                            // Check if this match is in a gap of a displayRanges match
                            let isInGap = false;
                            if (range.displayRanges && range.displayRanges.length > 0) {
                                for (let i = 0; i < range.displayRanges.length - 1; i++) {
                                    const gapStart = range.displayRanges[i].end;
                                    const gapEnd = range.displayRanges[i + 1].start;
                                    if (match.start >= gapStart && match.end <= gapEnd) {
                                        isInGap = true;
                                        break;
                                    }
                                }
                            }

                            if (!isInGap) {
                                hasOverlap = true;
                                break;
                            }
                        }
                    }

                    if (!hasOverlap) {
                        combinedMatches.push(match);
                        usedRanges.push({
                            start: match.start,
                            end: match.end,
                            displayRanges: match.displayRanges
                        });
                    }
                }

                // Sort by position for display
                combinedMatches.sort((a, b) => a.start - b.start);

                // Deduplicate segments for counting purposes
                const matchesForCounting = [];
                const seenParentTerms = new Set();

                for (const match of combinedMatches) {
                    if (match.isSegment && match.parentTerm) {
                        // This is a segment of a multi-word term split by emojis
                        // Only count once per parentTerm
                        if (!seenParentTerms.has(match.parentTerm)) {
                            seenParentTerms.add(match.parentTerm);
                            matchesForCounting.push(match);
                        }
                    } else {
                        // Not a segment, count normally (includes emojis, regular matches)
                        matchesForCounting.push(match);
                    }
                }

                // Count all unique categories
                const allCategories = new Set([
                    ...codedTermResults.categories,
                    ...harmfulTermResults.categories,
                    ...patternResults.matches.map(m => m.category)
                ]);

                // Separate deduplicated counts by type
                const deduplicatedCodedTerms = matchesForCounting.filter(m => m.type === 'codedTerm');
                const deduplicatedHarmfulTerms = matchesForCounting.filter(m => m.type === 'harmfulTerm');

                const combinedResults = {
                    matches: combinedMatches,  // All matches for display (includes duplicate segments)
                    deduplicatedMatches: matchesForCounting,  // Deduplicated matches for counting/stats
                    codedTermCount: deduplicatedCodedTerms.length,
                    harmfulTermCount: deduplicatedHarmfulTerms.length,
                    categoryCount: allCategories.size,
                    categories: Array.from(allCategories)
                };

                displayResults(text, combinedResults);

                // Hide loading state
                document.getElementById('loading').classList.remove('visible');

                // Track analytics (TODO: implement)
                trackAnalysis(text, combinedResults);
            }, 100);
        }

        function displayResults(originalText, results) {
            const textInput = document.getElementById('textInput');
            const textDisplay = document.getElementById('textDisplay');
            const analyzeBtn = document.getElementById('analyzeBtn');
            const clearBtn = document.getElementById('clearBtn');
            const resultsDiv = document.getElementById('results');
            const termCount = document.getElementById('termCount');
            const categoryCount = document.getElementById('categoryCount');
            const inputLabel = document.getElementById('inputLabel');

            // Use deduplicated counts from results (already calculated during analysis)
            const codedTermCount = results.codedTermCount;
            const harmfulTermCount = results.harmfulTermCount;
            const totalCount = codedTermCount + harmfulTermCount;

            // Update Terms Flagged count
            termCount.textContent = totalCount;

            // Update breakdown - display on separate lines, ordered by count
            const termBreakdown = document.getElementById('termBreakdown');
            if (termBreakdown) {
                const lines = [];

                if (codedTermCount > 0) {
                    const codedTermText = codedTermCount === 1 ? 'coded term' : 'coded terms';
                    lines.push({ count: codedTermCount, text: `${codedTermCount} ${codedTermText}` });
                }

                if (harmfulTermCount > 0) {
                    const harmfulTermText = harmfulTermCount === 1 ? 'harmful term' : 'harmful terms';
                    lines.push({ count: harmfulTermCount, text: `${harmfulTermCount} ${harmfulTermText}` });
                }

                // Sort by count (descending)
                lines.sort((a, b) => b.count - a.count);

                // Join with line breaks
                termBreakdown.innerHTML = lines.map(line => line.text).join('<br>');
            }

            // Count subcategories and group by main category
            const subCategoryCounts = {};
            const mainCategoryCounts = {};

            // Use deduplicated matches for counting (not the display matches with duplicate segments)
            const matchesToCount = results.deduplicatedMatches || results.matches;
            matchesToCount.forEach(match => {
                const subcat = match.category.toLowerCase();
                const mainKey = getMainCategory(subcat);

                // Count subcategories
                subCategoryCounts[subcat] = (subCategoryCounts[subcat] || 0) + 1;

                // Count main categories
                if (mainKey) {
                    mainCategoryCounts[mainKey] = (mainCategoryCounts[mainKey] || 0) + 1;
                }
            });

            // Sort main categories by count (descending)
            const sortedMainCategories = Object.entries(mainCategoryCounts)
                .sort((a, b) => b[1] - a[1]);

            // Sort subcategories by count (descending)
            const sortedSubCategories = Object.entries(subCategoryCounts)
                .sort((a, b) => b[1] - a[1]);

            // Update main category count and display
            document.getElementById('mainCategoryCount').textContent = sortedMainCategories.length;
            const mainCategoryList = document.getElementById('mainCategoryList');
            let mainCategoryHtml = '';
            sortedMainCategories.forEach(([mainKey, count]) => {
                const mainCat = CATEGORY_HIERARCHY[mainKey];
                if (mainCat) {
                    mainCategoryHtml += `<span class="category-badge" style="background-color: ${mainCat.darkColor}">${mainCat.label} (${count})</span>`;
                }
            });
            mainCategoryList.innerHTML = mainCategoryHtml;

            // Update subcategory count and display
            document.getElementById('subCategoryCount').textContent = sortedSubCategories.length;
            const subCategoryList = document.getElementById('subCategoryList');
            let subCategoryHtml = '';
            sortedSubCategories.forEach(([subcat, count]) => {
                const color = getCategoryColor(subcat);
                const info = getSubcategoryInfo(subcat);
                const label = info ? info.label : subcat;
                subCategoryHtml += `<span class="category-badge" style="background-color: ${color}">${label} (${count})</span>`;
            });
            subCategoryList.innerHTML = subCategoryHtml;

            // Calculate Signal Score using deduplicated matches
            const scoreResult = SignalScore.calculate(originalText, matchesToCount);
            const signalScore = scoreResult.total;
            document.getElementById('signalScore').textContent = `${signalScore}%`;

            // Update signal indicator
            const signalIndicator = document.getElementById('signalIndicator');
            const signalLevel = SignalScore.getSignalLevel(signalScore);
            const indicatorClass = signalLevel.className;
            const indicatorText = signalLevel.level;

            signalIndicator.innerHTML = `<span class="signal-indicator ${indicatorClass}">${indicatorText}</span><span class="highlight info-icon">‚ìò<span class="tooltip"></span></span>`;

            // Update score breakdown tooltip
            SignalScore.updateTooltip(scoreResult.breakdown);

            // Build highlighted text
            let displayHtml = '';
            if (results.matches.length === 0) {
                displayHtml = '<div class="no-results">‚úì No coded terms or harmful terms detected in this text.</div>' +
                    '<div style="margin-top: 15px;">' + escapeHtml(originalText) + '</div>';
            } else {
                let lastIndex = 0;

                results.matches.forEach(match => {
                    // Add text before match
                    displayHtml += escapeHtml(originalText.substring(lastIndex, match.start));

                    // Add highlighted match with tooltip
                    displayHtml += createHighlightedSpan(match, originalText);

                    lastIndex = match.end;
                });

                // Add remaining text
                displayHtml += escapeHtml(originalText.substring(lastIndex));
            }

            textDisplay.innerHTML = displayHtml;

            // Switch UI: hide textarea, show display div
            textInput.classList.add('hidden');
            textDisplay.classList.add('visible');
            analyzeBtn.classList.add('hidden');
            document.getElementById('editBtn').classList.remove('hidden');
            clearBtn.classList.remove('hidden');
            document.getElementById('copyBtn').classList.remove('hidden');
            inputLabel.textContent = 'Analysis Results:';

            // Show stats
            resultsDiv.classList.remove('hidden');

            // Setup smart tooltip positioning
            setupTooltips();
        }

        /**
         * Generate matched term HTML if obfuscation is detected
         * DRY helper for both coded term and harmful term tooltips
         *
         * @param {string} matchedTerm - The canonical term that was matched
         * @param {string} displayedText - The actual text shown in the document
         * @param {string} label - Label to use ("Term" or "Derivation")
         * @returns {string} HTML string or empty string if no obfuscation
         */
        function getMatchedTermHtml(matchedTerm, displayedText, label = 'Term') {
            if (!matchedTerm) return '';

            // Check if obfuscation detected (case-insensitive comparison)
            const isObfuscated = matchedTerm.toLowerCase() !== displayedText.toLowerCase();

            if (!isObfuscated) return '';

            return `<div class="tooltip-item"><div class="tooltip-item-label">${label}:</div><div class="tooltip-item-value">${escapeHtml(matchedTerm)}</div></div>`;
        }

        /**
         * Format variations list, limiting to 6 random items if list is too long
         *
         * @param {Array<string>} variations - Array of variation strings
         * @returns {string} HTML string or empty string if no variations
         */
        function getVariationsHtml(variations) {
            if (!variations || variations.length === 0) return '';

            let displayVariations = variations;
            let label = 'Variations';

            // If more than 6 variations, select 6 random ones
            if (variations.length > 6) {
                // Shuffle and take first 6
                const shuffled = [...variations].sort(() => Math.random() - 0.5);
                displayVariations = shuffled.slice(0, 6);
                label = `Variations include`;
            }

            return `<div class="tooltip-item"><div class="tooltip-item-label">${label}:</div><div class="tooltip-item-value tooltip-variations">${escapeHtml(displayVariations.join(' / '))}</div></div>`;
        }

        function createHighlightedSpan(match, originalText) {
            const typeClass = match.type || 'codedTerm';
            const categoryClass = getCategoryClass(match.category);
            const categoryColor = getCategoryColor(match.category);
            const formattedCategoryLabel = getFormattedCategoryLabel(match.category);
            const capitalizedDefinition = capitalizeFirst(match.definition);

            // Extract the actual text from original (preserves emojis)
            const displayText = originalText.substring(match.start, match.end);

            if (match.type === 'harmfulTerm') {
                // Harmful term
                const underlineStyle = `border-bottom: 3px solid ${categoryColor}; text-decoration: none;`;
                const sourceHtml = getTooltipSourceHtml(match.source);

                // Show matched term if obfuscation detected (DRY helper)
                const matchedTermHtml = getMatchedTermHtml(match.matchedTerm, match.text, 'Term');

                // Type indicator
                const typeHtml = `<div class="tooltip-item"><div class="tooltip-item-label">‚ò£Ô∏è Harmful Term</div></div>`;

                return `<span class="highlight harmfulTerm" style="${underlineStyle}">${escapeHtml(displayText)}<span class="tooltip"><div class="tooltip-category" style="background-color: ${categoryColor}">${escapeHtml(formattedCategoryLabel)}</div>${typeHtml}${matchedTermHtml}<div class="tooltip-item"><div class="tooltip-item-label">Definition:</div><div class="tooltip-item-value">${escapeHtml(capitalizedDefinition)}</div></div>${sourceHtml}</span></span>`;
            } else {
                // Coded term
                const sourceHtml = getTooltipSourceHtml(match.source);

                // Determine what to show for the term
                let termHtml = '';
                if (match.isDerived && match.category !== "religious-populism") {
                    // Derived regionalist/localist/regionalist terms always show "Derivation: [root term]"
                    termHtml = `<div class="tooltip-item"><div class="tooltip-item-label">Derivation:</div><div class="tooltip-item-value">${escapeHtml(match.term)}</div></div>`;
                } else {
                    // Non-derived terms: show matched term only if obfuscated (DRY helper)
                    termHtml = getMatchedTermHtml(match.matchedTerm, match.text, 'Term');
                }

                // Limit variations to 6 random items if needed (DRY helper)
                const variationsHtml = getVariationsHtml(match.variations);

                // Type indicator
                const typeHtml = `<div class="tooltip-item"><div class="tooltip-item-label">üî£ Coded Term</div></div>`;

                return `<span class="highlight ${categoryClass} codedTerm">${escapeHtml(displayText)}<span class="tooltip"><div class="tooltip-category" style="background-color: ${categoryColor}">${escapeHtml(formattedCategoryLabel)}</div>${typeHtml}${termHtml}${variationsHtml}<div class="tooltip-item"><div class="tooltip-item-label">Coded term:</div><div class="tooltip-item-value">${escapeHtml(capitalizedDefinition)}</div></div>${sourceHtml}</span></span>`;
            }
        }

        /**
        * Returns a tooltip-source string for a given source ID.
        *  Preserves the exact HTML structure you already have.
        */
        function getTooltipSourceHtml(sourceId) {
            if (!sourceId) {
                console.warn("Source id not present in data: " + sourceId);
                return `<div class="tooltip-source">Source: ERROR</div>`;
            }

            const sourceEntry = SOURCE_DATA.sources.find(s => s.id === sourceId);
            if (!sourceEntry) {
                console.warn(`Source id "${sourceId}" not found in SOURCE_DATA: ` + sourceId);
                return `<div class="tooltip-source">Source: ERROR</div>`;
            }

            const displayString = escapeHtml(sourceEntry.string || sourceId);

            if (sourceEntry.url) {
                return `<div class="tooltip-source">Source: ${displayString}</div>`;
            } else {
                return `<div class="tooltip-source">Source: ${displayString}</div>`;
            }
        }


        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function capitalizeFirst(text) {
            if (!text || text.length === 0) return text;
            return text.charAt(0).toUpperCase() + text.slice(1);
        }

        // Track currently visible tooltip on mobile
        let activeTooltip = null;

        // Detect if device supports touch (mobile/tablet) - used by multiple functions
        const isTouchDevice = window.matchMedia('(hover: none)').matches
            || ('ontouchstart' in window);

        function setupTooltips() {
            const highlights = document.querySelectorAll('.highlight');

            if (isTouchDevice) {
                setupTouchBehavior(highlights);
            } else {
                setupHoverBehavior(highlights);
            }
        }

        function setupHoverBehavior(highlights) {
            highlights.forEach(highlight => {
                const tooltip = highlight.querySelector('.tooltip');
                if (!tooltip) return;

                // Position tooltip on mouseenter
                highlight.addEventListener('mouseenter', function (e) {
                    positionTooltip(highlight, tooltip);
                });
            });
        }

        function setupTouchBehavior(highlights) {
            // Touch on highlight: show tooltip
            highlights.forEach(highlight => {
                const tooltip = highlight.querySelector('.tooltip');
                if (!tooltip) return;

                highlight.addEventListener('touchstart', (e) => {
                    e.preventDefault(); // Prevent default touch behavior
                    e.stopPropagation(); // Don't trigger document listener

                    // Hide previous tooltip if different
                    if (activeTooltip && activeTooltip !== tooltip) {
                        hideTooltip(activeTooltip);
                    }

                    // Show this tooltip
                    showTooltip(highlight, tooltip);
                    activeTooltip = tooltip;
                });
            });

            // Touch anywhere else: hide tooltip
            document.addEventListener('touchstart', () => {
                if (activeTooltip) {
                    hideTooltip(activeTooltip);
                    activeTooltip = null;
                }
            });
        }

        function showTooltip(highlight, tooltip) {
            tooltip.classList.add('tooltip-touch-active');
            positionTooltip(highlight, tooltip);
        }

        function hideTooltip(tooltip) {
            tooltip.classList.remove('tooltip-touch-active');
        }

        function positionTooltip(highlight, tooltip) {
            // Get highlight position
            const highlightRect = highlight.getBoundingClientRect();
            const tooltipWidth = 320; // Match CSS width
            const tooltipHeight = tooltip.offsetHeight || 150; // Estimate if not rendered
            const margin = 10;
            const arrowHeight = 8;

            // Viewport dimensions
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            // Calculate initial centered position
            let left = highlightRect.left + (highlightRect.width / 2) - (tooltipWidth / 2);
            let top = highlightRect.top - tooltipHeight - arrowHeight - margin;

            // Reset classes
            tooltip.classList.remove('top', 'bottom', 'align-left', 'align-right');

            // Check if tooltip fits above
            if (top < margin) {
                // Place below instead
                top = highlightRect.bottom + arrowHeight + margin;
                tooltip.classList.add('bottom');
            } else {
                tooltip.classList.add('top');
            }

            // Check horizontal overflow
            if (left < margin) {
                // Align to left edge
                left = margin;
                tooltip.classList.add('align-left');
            } else if (left + tooltipWidth > viewportWidth - margin) {
                // Align to right edge
                left = viewportWidth - tooltipWidth - margin;
                tooltip.classList.add('align-right');
            }

            // Apply position
            tooltip.style.left = `${left}px`;
            tooltip.style.top = `${top}px`;
        }

        function clearAll() {
            const textInput = document.getElementById('textInput');
            const textDisplay = document.getElementById('textDisplay');
            const analyzeBtn = document.getElementById('analyzeBtn');
            const editBtn = document.getElementById('editBtn');
            const clearBtn = document.getElementById('clearBtn');
            const copyBtn = document.getElementById('copyBtn');
            const resultsDiv = document.getElementById('results');
            const inputLabel = document.getElementById('inputLabel');

            // Clear text
            textInput.value = '';
            textDisplay.innerHTML = '';
            originalAnalyzedText = ''; // Reset stored text

            // Switch UI back: show textarea, hide display div
            textInput.classList.remove('hidden');
            textDisplay.classList.remove('visible');
            analyzeBtn.classList.remove('hidden');
            analyzeBtn.disabled = true;
            clearBtn.disabled = true;
            copyBtn.disabled = true;
            editBtn.classList.add('hidden');
            inputLabel.textContent = 'Paste text to analyze:';

            // Hide stats
            resultsDiv.classList.add('hidden');
        }

        function copyText() {
            // Always copy from the textarea (which contains current editable text)
            const textToCopy = document.getElementById('textInput').value;
            if (!textToCopy.trim()) {
                return; // Nothing to copy
            }
            // Use the Clipboard API
            navigator.clipboard.writeText(textToCopy).then(() => {
                // visual feedback
                const copyBtn = document.getElementById('copyBtn');
                // Temporarily override background with disabled color
                copyBtn.style.background = 'var(--btn-clicked-bg)';
                setTimeout(() => {
                    copyBtn.style.background = '';
                }, buttonClickTimeout);

            }).catch(err => {
                console.error('Failed to copy text:', err);
                alert('Failed to copy text to clipboard');
            });
        }

        function trackAnalysis(text, results) {
            // TODO: Implement analytics tracking
            // Track metrics:
            // 1. Total analyses performed
            // 2. Detection rate
            // 3. Average text length
            // 4. Terms detected distribution
            // 5. Return user rate (localStorage)
            // 6. Country-level data (IP geolocation)
            // 7. Time-based patterns

            // console.log('Analytics placeholder:', {
            //     textLength: text.length,
            //     matchCount: results.matches.length,
            //     categories: results.categories
            // });
        }

        // Prevent the user from highlighting text outside the text area
        const selectable = document.getElementById('textInput');
        document.addEventListener('selectstart', (e) => {
            if (!selectable.contains(e.target)) {
                e.preventDefault(); // Prevent selection
            }
        });

        // Allow Enter key to submit (with Ctrl/Cmd)
        document.getElementById('textInput').addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                analyzeText();
            }
        });

        // Enable/disable buttons based on text content
        document.getElementById('textInput').addEventListener('input', (e) => {
            const analyzeBtn = document.getElementById('analyzeBtn');
            const copyBtn = document.getElementById('copyBtn');
            const clearBtn = document.getElementById('clearBtn');
            const textInput = document.getElementById('textInput');

            if (textInput.value.trim()) {
                analyzeBtn.disabled = false;
                copyBtn.disabled = false;
                clearBtn.disabled = false;
            } else {
                analyzeBtn.disabled = true;
                copyBtn.disabled = true;
                clearBtn.disabled = true;
            }
        });

        // Reposition tooltips on window resize or scroll
        let tooltipRepositionTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(tooltipRepositionTimeout);
            tooltipRepositionTimeout = setTimeout(() => {
                // Reposition any visible tooltips
                // Desktop: use hover selector, Mobile: use .tooltip-touch-active selector
                const selector = isTouchDevice ? '.tooltip.tooltip-touch-active' : '.highlight:hover .tooltip';
                const visibleTooltips = document.querySelectorAll(selector);

                visibleTooltips.forEach(tooltip => {
                    const highlight = tooltip.closest('.highlight');
                    if (highlight) {
                        positionTooltip(highlight, tooltip);
                    }
                });
            }, 100);
        });

        window.addEventListener('scroll', () => {
            // Reposition tooltips on scroll (since they use fixed positioning)
            // Desktop: use hover selector, Mobile: use .tooltip-touch-active selector
            const selector = isTouchDevice ? '.tooltip.tooltip-touch-active' : '.highlight:hover .tooltip';
            const visibleTooltips = document.querySelectorAll(selector);

            visibleTooltips.forEach(tooltip => {
                const highlight = tooltip.closest('.highlight');
                if (highlight) {
                    positionTooltip(highlight, tooltip);
                }
            });
        }, { passive: true });
    </script>
</body>

</html>